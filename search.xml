<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react-redux_todos]]></title>
    <url>%2Fpost%2F6ae1620d.html</url>
    <content type="text"><![CDATA[官网react+redux todos分析入口文件index.js 12345678910111213141516171819import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './components/App';import * as serviceWorker from './serviceWorker';import &#123; Provider &#125; from 'react-redux'import store from './store'import 'todomvc-app-css/index.css'ReactDOM.render( &lt;React.StrictMode&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt; , document.getElementById('root'));serviceWorker.unregister(); connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。 它的原理是React组件的context属性，请看源码。1234567891011121314class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;Provider.childContextTypes = &#123; store: React.PropTypes.object&#125; 上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store，代码大致如下。12345678910111213141516171819class VisibleTodoList extends Component &#123; componentDidMount() &#123; const &#123; store &#125; = this.context; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); &#125; render() &#123; const props = this.props; const &#123; store &#125; = this.context; const state = store.getState(); // ... &#125;&#125;VisibleTodoList.contextTypes = &#123; store: React.PropTypes.object&#125; 创建 ActionTypes 以及 Action./store/constants/ActionTypes.js Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。添加新 todo 任务的 action 是这样的：12345const ADD_TODO = 'ADD_TODO'&#123; type: ADD_TODO, text: 'Build my first Redux app'&#125; Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。1import &#123; ADD_TODO, DELETE_TODO &#125; from '../actionTypes' 除了 type 字段外，action 对象的结构完全由你自己决定。参照 Flux 标准 Action 获取关于如何构造 action 的建议。 这时，我们还需要再添加一个 action index 来表示用户完成任务的动作序列号。因为数据是存放在数组中的，所以我们通过下标 index 来引用特定的任务。而实际项目中一般会在新建数据的时候生成唯一的 ID 作为数据的引用标识。1234&#123; type: DELETE_TODO, index: 1&#125; 我们应该尽量减少在 action 中传递的数据。比如上面的例子，传递 index 就比把整个任务对象传过去要好。 Action 创建函数Action 创建函数 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。在 Redux 中的 action 创建函数只是简单的返回一个 action:1export const addTodo = text =&gt; (&#123; type: types.ADD_TODO, text &#125;); 这样做将使 action 创建函数更容易被移植和测试。在 传统的 Flux 实现中，当调用 action 创建函数时，一般会触发一个 dispatch，像这样：1234567function addTodoWithDispatch(text) &#123; const action = &#123; type: ADD_TODO, text &#125; dispatch(action)&#125; 不同的是，Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。12dispatch(addTodo(text))dispatch(completeTodo(index)) 或者创建一个 被绑定的 action 创建函数 来自动 dispatch, 然后直接调用它们：12345const boundAddTodo = text =&gt; dispatch(addTodo(text))const boundCompleteTodo = index =&gt; dispatch(completeTodo(index))boundAddTodo(text);boundCompleteTodo(index); store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux 提供的 connect() 帮助器来调用。bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。Action 创建函数也可以是异步非纯函数，要借助redux中间件完成，常见的有redux-thunk以及redux-saga 1234567export const ADD_TODO = 'ADD_TODO'export const DELETE_TODO = 'DELETE_TODO'export const EDIT_TODO = 'EDIT_TODO'export const COMPLETE_TODO = 'COMPLETE_TODO'export const COMPLETE_ALL_TODOS = 'COMPLETE_ALL_TODOS'export const CLEAR_COMPLETED = 'CLEAR_COMPLETED'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER' ./store/actions/index.js123456789101112import * as types from '../constants/ActionTypes'export const addTodo = text =&gt; (&#123; type: types.ADD_TODO, text &#125;);export const deleteTodo = id =&gt; (&#123; type: types.DELETE_TODO, id &#125;);export const editTodo = (id, text) =&gt; (&#123; type: types.EDIT_TODO, id, text &#125;);export const completeTodo = id =&gt; (&#123; type: types.COMPLETE_TODO, id &#125;);export const completeAllTodos = () =&gt; (&#123; type: types.COMPLETE_ALL_TODOS &#125;);export const clearCompleted = () =&gt; (&#123; type: types.CLEAR_COMPLETED &#125;);export const setVisibilityFilter = filter =&gt; (&#123; type: types.SET_VISIBILITY_FILTER, filter&#125;); Reducers./store/reducers/todos.jsReducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。（当组件调用dispatch(action)时，同时会通知reducers, reducers会根据相应的action返回对应的state）在 Redux 应用中，所有的 state 都被保存在一个单一对象中。建议在写代码前先想一下这个对象的结构。如何才能以最简的形式把应用的 state 用对象描述出来？以 todo 应用为例，需要保存两种不同的数据： 当前选中的任务过滤条件； 完整的任务列表。通常，这个 state 树还需要存放其它一些数据，以及一些 UI 相关的 state。这样做没问题，但尽量把这些数据与 UI 相关的 state 分开。12345678910111213&#123; visibilityFilter: 'SHOW_ALL', todos: [ &#123; text: 'Consider using Redux', completed: true, &#125;, &#123; text: 'Keep all state in a single tree', completed: false &#125; ]&#125; 处理 Reducer 关系时的注意事项开发复杂的应用时，不可避免会有一些数据相互引用。建议你尽可能地把 state 范式化，不存在嵌套。把所有数据放到一个对象里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数据。把应用的 state 想像成数据库。这种方法在 normalizr 文档里有详细阐述。例如，实际开发中，在 state 里同时存放 todosById: { id -&gt; todo } 和 todos: array 是比较好的方式，本文中为了保持示例简单没有这样处理。 现在我们已经确定了 state 对象的结构，就可以开始开发 reducer。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。1(previousState, action) =&gt; newState 之所以将这样的函数称之为reducer，是因为这种函数与被传入 Array.prototype.reduce(reducer, ?initialValue) 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。谨记 reducer 一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。 注意 不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; ADD_TODO, DELETE_TODO, EDIT_TODO, COMPLETE_TODO, COMPLETE_ALL_TODOS, CLEAR_COMPLETED&#125; from '../constants/ActionTypes'const initialState = [&#123; text: 'Use Redux', completed: false, id: 0&#125;]export default function todos (state = initialState, action) &#123; switch (action.type) &#123; case ADD_TODO: return [ ...state, &#123; id: state.reduce((maxId, todo) =&gt; Math.max(todo.id, maxId), -1) + 1, completed: false, text: action.text &#125; ] case DELETE_TODO: return state.filter(todo =&gt; todo.id !== action.id ) case EDIT_TODO: return state.map(todo =&gt; todo.id === action.id ? &#123; ...todo, text: action.text &#125; : todo ) case COMPLETE_TODO: return state.map(todo =&gt; todo.id === action.id ? &#123; ...todo, completed: !todo.completed &#125; : todo ) case COMPLETE_ALL_TODOS: // every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。 const areAllMarked = state.every(todo =&gt; todo.completed) return state.map(todo =&gt; (&#123; ...todo, completed: !areAllMarked &#125;)) case CLEAR_COMPLETED: return state.filter(todo =&gt; todo.completed === false) default: return state &#125;&#125; ./store/reducers/visibilityFilter.js12345678910111213import &#123; SET_VISIBILITY_FILTER &#125; from '../constants/ActionTypes'import &#123; SHOW_ALL &#125; from '../constants/TodoFilters'const visibilityFilter = (state = SHOW_ALL, action) =&gt; &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return action.filter default: return state &#125;&#125;export default visibilityFilter ./store/reducers/index.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。import &#123; combineReducers &#125; from 'redux'import todos from './todos'import visibilityFilter from './visibilityFilter'const rootReducer = combineReducers(&#123; todos, visibilityFilter&#125;)export default rootReducer// 注意上面的写法和下面完全等价：export default function todoApp(state = &#123;&#125;, action) &#123; return &#123; visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) &#125;&#125;// 延伸// 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125;// 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成//一个大的 State 对象。// 下面是combineReducer的简单实现。const combineReducers = reducers =&gt; &#123; return (state = &#123;&#125;, action) =&gt; &#123; return Object.keys(reducers).reduce( (nextState, key) =&gt; &#123; nextState[key] = reducers[key](state[key], action); return nextState; &#125;, &#123;&#125; ); &#125;;&#125; 展示组件./components/App.js123456789101112131415import React from 'react';import Header from '../containers/Header'import MainSection from '../containers/MainSection'import './App.css';function App() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;MainSection /&gt; &lt;/div&gt; );&#125;export default App; ./components/MainSection.js123456789101112131415161718192021222324252627282930313233343536373839import React from 'react'import PropTypes from 'prop-types'import Footer from './Footer'import VisibleTodoList from '../containers/VisibleTodoList'const MainSection = (&#123; todosCount, completedCount, actions &#125;) =&gt; ( &lt;section className="main"&gt; &#123; !!todosCount &amp;&amp; &lt;span&gt; &lt;input className="toggle-all" type="checkbox" checked=&#123;completedCount === todosCount&#125; onChange=&#123;actions.completeAllTodos&#125; /&gt; &lt;label onClick=&#123;actions.completeAllTodos&#125;/&gt; &lt;/span&gt; &#125; &lt;VisibleTodoList /&gt; &#123; !!todosCount &amp;&amp; &lt;Footer completedCount=&#123;completedCount&#125; activeCount=&#123;todosCount - completedCount&#125; onClearCompleted=&#123;actions.clearCompleted&#125; /&gt; &#125; &lt;/section&gt; )MainSection.propTypes = &#123; todosCount: PropTypes.number.isRequired, completedCount: PropTypes.number.isRequired, actions: PropTypes.object.isRequired&#125;export default MainSection; ./components/TodoList.js12345678910111213141516171819202122import React from 'react'import PropTypes from 'prop-types'import TodoItem from './TodoItem'const TodoList = (&#123; filteredTodos, actions &#125;) =&gt; ( &lt;ul className="todo-list"&gt; &#123;filteredTodos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; &#123;...actions&#125; /&gt; )&#125; &lt;/ul&gt;)TodoList.propTypes = &#123; filteredTodos: PropTypes.arrayOf(PropTypes.shape(&#123; id: PropTypes.number.isRequired, completed: PropTypes.bool.isRequired, text: PropTypes.string.isRequired &#125;).isRequired).isRequired, actions: PropTypes.object.isRequired&#125;export default TodoList ./components/TodoItem.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'import classnames from 'classnames'import TodoTextInput from './TodoTextInput'export default class TodoItem extends Component &#123; static propTypes = &#123; todo: PropTypes.object.isRequired, editTodo: PropTypes.func.isRequired, deleteTodo: PropTypes.func.isRequired, completeTodo: PropTypes.func.isRequired &#125; state = &#123; editing: false &#125; handleDoubleClick = () =&gt; &#123; this.setState(&#123; editing: true &#125;) &#125; handleSave = (id, text) =&gt; &#123; if (text.length === 0) &#123; this.props.deleteTodo(id) &#125; else &#123; this.props.editTodo(id, text) &#125; this.setState(&#123; editing: false &#125;) &#125; render() &#123; const &#123; todo, completeTodo, deleteTodo &#125; = this.props let element if (this.state.editing) &#123; element = ( &lt;TodoTextInput text=&#123;todo.text&#125; editing=&#123;this.state.editing&#125; onSave=&#123;(text) =&gt; this.handleSave(todo.id, text)&#125; /&gt; ) &#125; else &#123; element = ( &lt;div className="view"&gt; &lt;input className="toggle" type="checkbox" checked=&#123;todo.completed&#125; onChange=&#123;() =&gt; completeTodo(todo.id)&#125; /&gt; &lt;label onDoubleClick=&#123;this.handleDoubleClick&#125;&gt; &#123;todo.text&#125; &lt;/label&gt; &lt;button className="destroy" onClick=&#123;() =&gt; deleteTodo(todo.id)&#125; /&gt; &lt;/div&gt; ) &#125; return ( &lt;li className=&#123;classnames(&#123; completed: todo.completed, editing: this.state.editing &#125;)&#125;&gt; &#123;element&#125; &lt;/li&gt; ) &#125;&#125; ./components/TodoTextInput.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'import classnames from 'classnames'export default class TodoTextInput extends Component &#123; static propTypes = &#123; onSave: PropTypes.func.isRequired, text: PropTypes.string, placeholder: PropTypes.string, editing: PropTypes.bool, newTodo: PropTypes.bool &#125; state = &#123; text: this.props.text || '' &#125; //在render函数调用前判断：如果前后state中text不变，通过return false阻止render调用 shouldComponentUpdate(nextProps,nextState)&#123; if(nextState.text === this.state.text)&#123; return false &#125; return true &#125; handleBlur = e =&gt; &#123; if (!this.props.newTodo) &#123; this.props.onSave(e.target.value) &#125; &#125; handleChange = e =&gt;&#123; this.setState(&#123;text: e.target.value&#125;) &#125; handleSubmit = e =&gt; &#123; const text = e.target.value.trim() if (e.which === 13) &#123; this.props.onSave(text) if (this.props.newTodo) &#123; this.setState(&#123; text: '' &#125;, () =&gt; &#123; console.log(this.state.text) &#125;) &#125; &#125; &#125; render () &#123; return ( &lt;input className=&#123; classnames(&#123; edit: this.props.editing, 'new-todo': this.props.newTodo &#125;) &#125; type='text' placeholder=&#123;this.props.placeholder&#125; autoFocus=&#123;true&#125; value=&#123;this.state.text&#125; onChange=&#123;this.handleChange&#125; onBlur=&#123;this.handleBlur&#125; onFocus=&#123;this.handleChange&#125; onKeyDown=&#123;this.handleSubmit&#125;/&gt; ) &#125;&#125; ./components/Footer.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from 'react'import PropTypes from 'prop-types'import FilterLink from '../containers/FilterLink'import &#123; SHOW_ALL, SHOW_COMPLETED, SHOW_ACTIVE &#125; from '../store/constants/TodoFilters'const FILTER_TITLES = &#123; [SHOW_ALL]: 'All', [SHOW_ACTIVE]: 'Active', [SHOW_COMPLETED]: 'Completed'&#125;const Footer = (props) =&gt; &#123; const &#123; activeCount, completedCount, onClearCompleted &#125; = props const itemWord = activeCount === 1 ? 'item' : 'items' return ( &lt;footer className="footer"&gt; &lt;span className="todo-count"&gt; &lt;strong&gt;&#123;activeCount || 'No'&#125;&lt;/strong&gt; &#123;itemWord&#125; left &lt;/span&gt; &lt;ul className="filters"&gt; &#123;Object.keys(FILTER_TITLES).map(filter =&gt; &lt;li key=&#123;filter&#125;&gt; &lt;FilterLink filter=&#123;filter&#125;&gt; &#123;FILTER_TITLES[filter]&#125; &lt;/FilterLink&gt; &lt;/li&gt; )&#125; &lt;/ul&gt; &#123; !!completedCount &amp;&amp; &lt;button className="clear-completed" onClick=&#123;onClearCompleted&#125; &gt;Clear completed&lt;/button&gt; &#125; &lt;/footer&gt; )&#125;Footer.propTypes = &#123; completedCount: PropTypes.number.isRequired, activeCount: PropTypes.number.isRequired, onClearCompleted: PropTypes.func.isRequired,&#125;export default Footer 容器组件containers/Header.js1234567891011121314151617181920212223242526import React from 'react'import &#123; connect &#125; from 'react-redux'import PropTypes from "prop-types"import TodoTextInput from "../components/TodoTextInput";import &#123; addTodo &#125; from '../store/actions'const Header = (&#123; addTodo &#125;) =&gt; ( &lt;header className="header"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;TodoTextInput newTodo onSave=&#123;text =&gt; &#123; if (text.length !== 0) &#123; addTodo(text) &#125; &#125;&#125; placeholder="What needs to be done?" /&gt; &lt;/header&gt;)Header.propTypes = &#123; addTodo: PropTypes.func.isRequired&#125;;export default connect(null, &#123; addTodo &#125;)(Header); containers/MainSection.js12345678910111213141516171819202122import &#123; connect &#125; from 'react-redux'import * as TodoActions from '../store/actions'import &#123; bindActionCreators &#125; from 'redux'import MainSection from '../components/MainSection'import &#123; getCompletedTodoCount &#125; from '../store/selectors'const mapStateToProps = state =&gt; (&#123; todosCount: state.todos.length, completedCount: getCompletedTodoCount(state)&#125;)const mapDispatchToProps = dispatch =&gt; (&#123; actions: bindActionCreators(TodoActions, dispatch)&#125;)export default connect( mapStateToProps, mapDispatchToProps)(MainSection) containers/VisibleTodoList.js123456789101112131415161718192021import &#123; connect &#125; from 'react-redux'import &#123; bindActionCreators &#125; from 'redux'import * as TodoActions from '../store/actions'import TodoList from '../components/TodoList'import &#123; getVisibleTodos &#125; from '../store/selectors'const mapStateToProps = state =&gt; (&#123; filteredTodos: getVisibleTodos(state)&#125;)const mapDispatchToProps = dispatch =&gt; (&#123; actions: bindActionCreators(TodoActions, dispatch)&#125;)const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList containers/FilterLink.js123456789101112131415161718import &#123; connect &#125; from 'react-redux'import &#123; setVisibilityFilter &#125; from '../store/actions'import Link from '../components/Link'const mapStateToProps = (state, ownProps) =&gt; (&#123; active: ownProps.filter === state.visibilityFilter&#125;)const mapDispatchToProps = (dispatch, ownProps) =&gt; (&#123; setFilter: () =&gt; &#123; dispatch(setVisibilityFilter(ownProps.filter)) &#125;&#125;)export default connect( mapStateToProps, mapDispatchToProps)(Link) connect()React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连接起来。12import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect()(TodoList); 上面代码中，TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件。 但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。 输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数 输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。 因此，connect方法的完整 API 如下。123456import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) 上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。 mapStateToProps()mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。12345const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; 上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。下面就是getVisibleTodos的一个例子，用来算出todos。123456789101112const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) default: throw new Error('Unknown filter: ' + filter) &#125;&#125; mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。12345678910// 容器组件的代码// &lt;FilterLink filter="SHOW_ALL"&gt;// All// &lt;/FilterLink&gt;const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; active: ownProps.filter === state.visibilityFilter &#125;&#125; 使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。 connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。 mapDispatchToProps()mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。 12345678910const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter &#125;); &#125; &#125;;&#125; 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。123456const mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; 其他组件/store/selectors/index.js12345678910111213141516171819202122232425262728293031import &#123; createSelector &#125; from 'reselect'import &#123; SHOW_ALL, SHOW_COMPLETED, SHOW_ACTIVE &#125; from '../constants/TodoFilters'const getVisibilityFilter = state =&gt; state.visibilityFilterconst getTodos = state =&gt; state.todosexport const getVisibleTodos = createSelector( [getVisibilityFilter, getTodos], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case SHOW_ALL: return todos case SHOW_COMPLETED: return todos.filter(t =&gt; t.completed) case SHOW_ACTIVE: return todos.filter(t =&gt; !t.completed) default: throw new Error('Unknown filter: ' + visibilityFilter) &#125; &#125;)export const getCompletedTodoCount = createSelector( [getTodos], todos =&gt; ( todos.reduce((count, todo) =&gt; todo.completed ? count + 1 : count, 0 ) ))]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程化]]></title>
    <url>%2Fpost%2F7db00131.html</url>
    <content type="text"><![CDATA[人们常说的前端工程化到底是什么 Webpack与Grunt，Gulp 的区别Grunt 是开创者 Grunt 的出现是前端构建工具从0到1的变革，是具有开创意义的。在它之前我们经常都是通过 bash 或者 make 调用 closure-compiler 之类的工具。前端并不存在一个统一的构建工具和标准。Grunt的出现终结了这种混乱的局面，前端领域有了自己的构建工具，和大部分人都差不多采用的构建流程。 Grunt 虽然是开创者的地位，但是，他仅仅是把混乱的构建过程统一化了，用起来方便了，其实本质上没有变。本质上我们依然是把 CSS, JS, HTML，图片等 各自打包，一个JS模块依赖的 CSS 等外部资源依然没有任何语法上的声明，我们甚至需要在组件说明中强调这个组件依赖哪个CSS，依赖那几张图片。也就是说，模块依赖的问题依然没有解决。 另外 Grunt 是直接面向文件操作的，每一个任务都是输入一个文件，然后输出一个文件。这样导致如果一个文件需要经过多次处理，在中间每一步都会写文件，这些文件其实并没有必要写。这样就导致Grunt的效率比较低。 比如我编译JS的时候，可能需要先 CoffeeScript 编译一下，然后 Uglify 一下，那么很多时候 Coffee 编译的文件我并不需要，我只要 Uglify 之后的文件，而写文件是很耗时的。 Gulp 只是做了改良 Gulp 基于Stream 就明显比 Grunt要更高效，且更任务组合灵活。我可以读入一个文件，然后进行多个操作，最终直接输出我要的结果，不存在中间的临时文件。 然而 Gulp 只是一个量变，它依然没能解决模块依赖的问题。 Webpack 划时代的解决了模块依赖的问题 Webpack 的出现比较完美解决了前端模块依赖的问题，任何资源都是JS，任何资源都可以在JS中声明依赖。这是具有划时代意义的。甚至我是这样认为的，在webpack之前前端是没有真正的通用的模块化开发的（特定框架的不算）。 Webpack原理简述以及plugins和loaders的实现原理 核心概念JavaScript 的 模块打包工具 (module bundler)。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。 Entry: 入口文件，Webpack 会从该文件开始进行分析与编译； Output: 出口路径，打包后创建 bundler 的文件路径以及文件名； Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包； Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能； Loader: 模块加载器，进行各种文件类型的加载与转换； Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改； 工作流程 (加载 - 编译 - 输出) 读取配置文件，按命令 初始化 配置参数，创建 Compiler 对象； 调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译； 按文件类型，调用相应的 Loader 对模块进行 编译，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 依赖查找 到所依赖的模块，递归执行第三步； 将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 输出内容。这个步骤，仍然可以通过 Plugin 进行文件的修改; 最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程； 模块包装:123456789101112131415161718192021222324252627282930313233343536373839404142(function(modules) &#123; // 模拟 require 函数，从内存中加载模块； function __webpack_require__(moduleId) &#123; // 缓存模块 if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // 执行代码； modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag: 标记是否加载完成； module.l = true; return module.exports; &#125; // ... // 开始执行加载入口文件； return __webpack_require__(__webpack_require__.s = "./src/index.js"); &#125;)(&#123; "./src/index.js": function (module, __webpack_exports__, __webpack_require__) &#123; // 使用 eval 执行编译后的代码； // 继续递归引用模块内部依赖； // 实际情况并不是使用模板字符串，这里是为了代码的可读性； eval(` __webpack_require__.r(__webpack_exports__); // var _test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("test", ./src/test.js"); `); &#125;, "./src/test.js": function (module, __webpack_exports__, __webpack_require__) &#123; // ... &#125;, &#125;) 总结: 模块机制: webpack 自己实现了一套模拟模块的机制，将其包裹于业务代码的外部，从而提供了一套模块机制； 文件编译: webpack 规定了一套编译规则，通过 Loader 和 Plugin，以管道的形式对文件字符串进行处理； 2. Loader由于 Webpack 是基于 Node，因此 Webpack 其实是只能识别 js 模块，比如 css / html / 图片等类型的文件并无法加载，因此就需要一个对不同格式文件转换器。其实 Loader 做的事，也并不难理解: 对 Webpack 传入的字符串进行按需修改。例如一个最简单的 Loader:123456// html-loader/index.jsmodule.exports = function(htmlSource) &#123; // 返回处理后的代码字符串 // 删除 html 文件中的所有注释 return htmlSource.replace(/&lt;!--[\w\W]*?--&gt;/g, '')&#125; 当然，实际的 Loader 不会这么简单，通常是需要将代码进行分析，构建 AST (抽象语法树)， 遍历进行定向的修改后，再重新生成新的代码字符串。如我们常用的 Babel-loader 会执行以下步骤: babylon 将 ES6/ES7 代码解析成 AST babel-traverse 对 AST 进行遍历转译，得到新的 AST 新 AST 通过 babel-generator 转换成 ES5 Loader 特性: 链式传递，按照配置时相反的顺序链式执行； 基于 Node 环境，拥有 较高权限，比如文件的增删查改； 可同步也可异步； 常用 Loader: file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能； url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求； babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题； ts-loader: 加载 ts / tsx 文件，编译 TypeScript； style-loader: 将 css 代码以&lt;style&gt;标签的形式插入到 html 中； css-loader: 分析@import和url()，引用 css 文件与对应的资源； postcss-loader: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等； less-loader / sass-loader: css预处理器，在 css 中新增了许多语法，提高了开发效率； 编写原则: 单一原则: 每个 Loader 只做一件事； 链式调用: Webpack 会按顺序链式调用每个 Loader； 统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用； Plugin插件系统是 Webpack 成功的一个关键性因素。在编译的整个生命周期中，Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。 一个最简单的 plugin 是这样的: 12345678910class Plugin&#123; // 注册插件时，会调用 apply 方法 // apply 方法接收 compiler 对象 // 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作 apply(compiler)&#123; // compilation 是监听每次编译循环 // 每次文件变化，都会生成新的 compilation 对象并触发该事件 compiler.plugin('compilation',function(compilation) &#123;&#125;) &#125;&#125; 注册插件: 123456// webpack.config.jsmodule.export = &#123; plugins:[ new Plugin(options), ]&#125; 事件流机制: Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 与 Plugin 的一道道处理，最后输出结果。 通过链式调用，按顺序串起一个个 Loader； 通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中； Webpack 事件流编程范式的核心是基础类 Tapable，是一种 观察者模式 的实现事件的订阅与广播： 123456789101112const &#123; SyncHook &#125; = require("tapable")const hook = new SyncHook(['arg'])// 订阅hook.tap('event', (arg) =&gt; &#123; // 'event-hook' console.log(arg)&#125;)// 广播hook.call('event-hook') Webpack 中两个最重要的类 Compiler 与 Compilation 便是继承于 Tapable，也拥有这样的事件流机制。 Compiler: 可以简单的理解为 Webpack 实例，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递； Compilation: 可以称为 编译实例。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可以监听每次编译过程中触发的事件钩子； 区别: Compiler 全局唯一，且从启动生存到结束； Compilation 对应每次编译，每轮编译循环均会重新创建； 常用 Plugin: UglifyJsPlugin: 压缩、混淆代码; CommonsChunkPlugin: 代码分割； ProvidePlugin: 自动加载模块； html-webpack-plugin: 加载 html 文件，并引入 css / js 文件； extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量； optimize-css-assets-webpack-plugin: CSS 代码去重； webpack-bundle-analyzer: 代码分析； compression-webpack-plugin: 使用 gzip 压缩 js 和 css； happypack: 使用多进程，加速代码构建； EnvironmentPlugin: 定义环境变量； 4. 编译优化 代码优化: 无用代码消除, 是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 删除不可能执行的代码； * 例如我们的 UglifyJs，它就会帮我们在生产环境中删除不可能被执行的代码，例如: 1234567var fn = function() &#123; return 1; // 下面代码便属于 不可能执行的代码； // 通过 UglifyJs (Webpack4+ 已内置) 便会进行 DCE； var a = 1; return a;&#125; 摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 “摇” 我们打包后的 js 代码，将没有使用到的无用代码 “摇” 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。 原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。 问题: 具有 副作用 的函数无法被 tree-shaking。 在引用一些第三方库，需要去观察其引入的代码量是不是符合预期； 尽量写纯函数，减少函数的副作用； 可使用 webpack-deep-scope-plugin，可以进行作用域分析，减少此类情况的发生，但仍需要注意； code-spliting: 代码分割 技术，将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载； Webpack 中使用 SplitChunksPlugin 进行拆分 按 页面 拆分: 不同页面打包成不同的文件； 按 功能 拆分: 将类似于播放器，计算库等大模块进行拆分后再懒加载引入； 提取复用的业务代码，减少冗余代码； 按 文件修改频率 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存； scope hoisting: 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗； 编译性能优化: 升级至 最新 版本的 webpack，能有效提升编译性能； 使用 dev-server / 模块热替换 (HMR) 提升开发体验； 监听文件变动 忽略 node_modules 目录能有效提高监听时的编译效率； 缩小编译范围: modules: 指定模块路径，减少递归搜索； mainFields: 指定入口文件描述字段，减少搜索； noParse: 避免对非模块化文件的加载； includes/exclude: 指定搜索范围/排除不必要的搜索范围； alias: 缓存目录，避免重复寻址； babel-loader: 忽略node_moudles，避免编译第三方库中已经被编译过的代码； 使用cacheDirectory，可以缓存编译结果，避免多次重复编译； 多进程并发: webpack-parallel-uglify-plugin: 可多进程并发压缩 js 文件，提高压缩速度； HappyPack: 多进程并发文件的 Loader 解析； 第三方库模块缓存: DLLPlugin 和 DLLReferencePlugin 可以提前进行打包并缓存，避免每次都重新编译； 使用分析: Webpack Analyse / webpack-bundle-analyzer 对打包后的文件进行分析，寻找可优化的地方； 配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方； source-map: 开发: cheap-module-eval-source-map； 生产: hidden-source-map； webpack 热更新原理参考 .jpg).jpg) 初始化的时候，client.js 会启动一个 socket 和 webpack-dev-server 建立连接，然后等待 hash 和 ok 消息。 当有文件内容改动的时候，首先会收到 webpack-dev-server 发来的 hash 消息，得到新的 哈希值并保存起来。 然后会立刻接收到 ok 消息，表示现在可以加载最新的代码了，于是进入 reloadApp 方法。 reloadApp -&gt; check() check =&gt; hotDownloadManifest, 这里会下载一个本次热更新的manifest文件，url就是用上面存的 hash 拼接出来的，大概这样：8b52a72952cca784407e.hot-update.json，结果大概长这样：{“h”:”8b52a72952cca784407e”,”c”:{“0”:true}}。这里仔细观察会发现，每一次取到的manifest中的hash 都是上一次 hash 消息的值，这样应该是为了保证顺序。 hotDownloadManifest 下载完配置文件后，可以看到其中有一个 h ，这个hash就是我们等会要取编译后的新代码的地址，在 hotEnsureUpdateChunk 方法中最终会通过 jsonp的方式把新的代码加载进来。 加载到新的模块代码后，会有一系列的对 依赖树 比如 installedModules 的更新操作。 最终，在 hotApply 中会执行我们的 module.hot.accept 注册的回调函数 Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信) 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端 HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档 hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。 webpack 生命周期参考 如何编写loaders和plugins参考 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？ npm 模块安装机制： 发出npm install命令 查询node_modules目录之中是否已经存在指定模块 若存在，不再重新安装 若不存在 npm 向 registry 查询模块压缩包的网址 下载压缩包，存放在根目录下的.npm目录里 解压压缩包到当前项目的node_modules目录 webpack 打包 vue 速度太慢怎么办？ eslint代码校验其实是一个很费时间的一个步奏。 ：可以把eslint的范围缩小到src,且只检查.js 和 .vue ：生产环境不开启lint，使用pre-commit或者husky在提交前校验。 happypack多进程进行。 动态链接库（DllPlugin），有点类似配置的externals。 补充一下： 缺点：将不能按需加载，会将配置的第三方库全部打包进去。 推荐：可以将使用率较高的包采用dll方案。（将一些不做修改的依赖文件，提前打包）。 HardSourceWebpackPlugin会将模块编译后进行缓存，第一次之后速度会明显提升。 参考：webpack 源码解析]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全]]></title>
    <url>%2Fpost%2F843888ab.html</url>
    <content type="text"><![CDATA[XSS防御，以及Content-Security-Policy细节参考 XSS攻击: 全称跨站脚本攻击，注入恶意代码 攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 cookie 设置 httpOnly // 客户端脚本就无法访问cookie 转义页面上的输入内容和输出内容 CSRF: 跨站请求伪造CSRF CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 防护: get 不修改数据 不被第三方网站访问到用户的 cookie 设置白名单，不被第三方网站请求 请求校验 如何预防中间人攻击 双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由公钥的正确性来保证。 公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由数字证书的正确性来保证了。 数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。那么安全性就是由上级 CA 证书的正确性保证的了。 但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统根证书的私钥不被泄露或者其公钥不被篡改来保证的了。 根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中内置签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了。 至此，整个信任链就建立起来了，只需要有一台设备上安装了可以信任的根证书，就可以用来分发更多安全的操作系统了。之后的所有信任链都是安全的了。]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2Fpost%2F616f4683.html</url>
    <content type="text"><![CDATA[前端性能优化手段页面基础优化 引入位置: css 文件中引入， js 文件底部引入； 影响首屏的，优先级很高的 js 也可以头部引入，甚至内联； 减少请求: (http 1.0 - 1.1)，合并请求，正确设置 http 缓存； 减少文件体积: 删除多余代码: tree-shaking UglifyJs code-spliting 混淆 / 压缩代码，开启 gzip 压缩； 多份编译文件按条件引入: 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件； 可以利用&lt;script type=&quot;module&quot;&gt; / &lt;script type=&quot;module&quot;&gt;进行条件引入用 动态 polyfill，只针对不支持的浏览器引入 polyfill； 图片优化: 小图片合成 雪碧图，低于 5K 的图片可以转换成 base64 内嵌； 合适场景下，使用 iconfont 或者 svg； 使用缓存: 浏览器缓存: 通过设置请求的过期时间，合理运用浏览器缓存； CDN缓存: 静态文件合理使用 CDN 缓存技术 HTML 放于自己的服务器上； 打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值； 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制； 服务器缓存: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上； 数据缓存: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间； 图片懒加载实现图片懒加载图片懒加载原理:先将img标签的src链接设为同一张图片（比如空白图片），然后给img标签设置自定义属性（比如 data-src）,然后将真正的图片地址存储在data-src中，当JS监听到该图片元素进入可视窗口时，将自定义属性中的地址存储到src属性中。达到懒加载的效果。 这样做能防止页面一次性向服务器发送大量请求，导致服务器响应面，页面卡顿崩溃等。 如何解决同步调用代码耗时太高的问题异步处理：setTimeout利用的是浏览器给js开辟新线程的方式，在规定时间之后将预定任务加入到js线程中执行，并且会排在当前js任务之后执行。所以不需要给延迟时间，只需要把耗时任务放在timeout里面，它就会等loading开始之后才会执行内部的耗时代码了。 SSR对性能优化的提升在哪里参考 浏览器缓存前端缓存]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器相关问题]]></title>
    <url>%2Fpost%2F6782413a.html</url>
    <content type="text"><![CDATA[重绘和回流（Repaint &amp; Reflow），以及优化方式 浏览器渲染机制 浏览器采用流式布局模型（Flow Based Layout） 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。 Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。 Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层） 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。 回流 前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。 回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。大部分的回流将导致页面的重新渲染 回流必定会发生重绘，重绘不一定会引发回流。 重绘 我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。 浏览器优化 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。 主要包括以下属性或方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight width、height getComputedStyle() getBoundingClientRect() 何时发生回流重绘 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 页面一开始渲染的时候（这肯定避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 减少重绘与回流 CSS 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局 避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。 尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。 将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。 避免使用CSS表达式，可能会引发回流。 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。 CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 JavaScript 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 说说浏览器和 Node 事件循环的区别 浏览器事件循环 一个完整的 Event Loop 过程，可以概括为以下阶段： .jpg) 一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。 执行渲染操作，更新界面。 检查是否存在 Web worker 任务，如果有，则对其进行处理。 上述过程循环往复，直到两个队列都清空。 当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。 Node 中的 Event Loop Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎， 而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。 cookie 和 token 都存放在 header 中，为什么不会劫持 token？1、首先token不是防止XSS的，而是为了防止CSRF的； 2、CSRF攻击的原因是浏览器会自动带上cookie，而浏览器不会自动带上token。 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？ 能够完成整个 HTTP 请求+响应（尽管不需要响应内容） 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据 跨域友好 执行过程无阻塞 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好 GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[到展现涉及哪些缓存环节]]></title>
    <url>%2Fpost%2F5f15b63e.html</url>
    <content type="text"><![CDATA[目录 地址栏网址缓存 检查 HSTS 预加载列表 DNS 缓存 ARP（地址解析协议）缓存 TCP 发送缓冲区 &amp; 接收缓冲区 HTTP 请求缓存（ CDN 节点缓存、代理服务器缓存、浏览器缓存、后端动态计算结果缓存等 ） 一、地址栏网址缓存输入 url 后遇到的第一个缓存环节就是地址栏网址缓存。 但我们输入一个常用的网址时，经常会有这样的情况，我们只是输入了几个字母，浏览器就自动补全了该网址。如下图：我只输入 j，就自动给我补全了 juejin.im： 当我们使用这个自动补全的网址时，你会发现请求的相关的静态资源也是从缓存中取得的。 注意：不论什么时候，我们获取的主页面资源 timeline, 都应该是重新请求服务器而获得的，不可以使用本地浏览器的缓存。至于为什么？你看到静态资源文件名的 hash 值你就应该清楚了。 转换非 ASCII 的 Unicode 字符浏览器检查输入是否含有不是 a-z，A-Z，0-9， - 或者 . 的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码 二、 检查 HSTS 预加载列表1HSTS（ HTTP Strict Transport Security ）国际互联网工程组织 IETE 正在推行一种新的 Web 安全协议，作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建连接。 采用 HSTS 后：支持这个协议的浏览器，在输入 URL 后会检查自带的 HSTS 预加载列表（这个列表里包含了那些请求浏览器只使用 HTTPS 进行连接的域名），若网站在这个列表里，浏览器会使用 HTTPS 协议并且返回码为 307。而不支持 HSTS 的浏览器访问我们的网站，则不会产生跳转，从而提高了兼容性。这个机制对于不支持 HTTPS 的搜索引擎来说是非常友好的！ 如掘金输入 http://juejin.im/timeline 会跳转到 https://juejin.im/timeline: 查看 HSTS 预加载列表是否存在你想访问的域名你可以在输入 qqbrowser://net-internals/#hsts，若存在会返回信息： 三、DNS 缓存但你输入 juejin.im 按下回车后，就开始对 juejin.im 进行域名解析。域名解析最少涉及了三个地方的缓存： 浏览器的 DNS 缓存 操作系统中的 DNS 缓存 索操作系统的 hosts 文件（可手动写入的缓存） 域名解析的具体过程 浏览器搜索自己的 DNS 缓存（浏览器维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步； 搜索操作系统中的 DNS 缓存；如果没有命中，进入下一步； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步； 1234567891.操作系统将域名发送至 LDNS （本地区域名服务器），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：2.LDNS向 Root Name Server（根域名服务器，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址；3.LDNS 向 im 域的顶级域名服务器发起请求，返回 juejin.im 域名服务器地址；4.LDNS 向 juejin.im 域名服务器发起请求，得到 juejin.im 的 IP 地址；5.LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来。 DNS Prefetch即 DNS 预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 1.减少 DNS 的请求次数 2.进行 DNS 预获取 典型的一次 DNS 解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。 1你可以通过 chrome://net-internals/#dns 查找目前系统中的 DNS 缓存和 Chrome 中使用的情况。 问：浏览器 DNS 缓存的时间一般不会太长，一分钟左右。为什么缓存不设置较长时间呢？ 答：虽然 DNS 缓存可以提高获取 DNS 的速度，但缓存时间过长也会影响 DNS 在 IP 变更时不能及时解析到最新的 IP。 四、ARP（地址解析协议）缓存1ARP 是一种用以解释地址的协议，根据通信方的 IP 地址就可以反查出对应方的 MAC 地址。 ARP 缓存是个用来储存 IP 地址和 MAC 地址的缓冲区，其本质就是一个 IP 地址与 MAC 地址的对应表，表中每一个条目分别记录了其他主机的 IP 地址和对应的 MAC 地址。 当地址解析协议被询问一个已知 IP 地址节点的 MAC 地址时，先在 AR 缓存中查看，若存在，就直接返回与之对应的MAC地址；若不存在，才发送 ARP 请求查询。 五、TCP 发送缓冲区 &amp; 接收缓冲区建立 TCP 连接这一步也涉及到缓存 —— 用来临时存放双方通信的数据，保证通信数据不会丢包。 每个 TCP 连接在内核中都有一个发送缓冲区和接收缓冲区，TCP 的全双工的工作模式以及 TCP 的流量(拥塞)控制便是依赖于这两个独立的 buffer 以及 buffer 的填充状态。 发送缓冲区1发送缓冲区存放的是 send() 方法从应用缓冲区拷贝过来的数据。 内核基本上是按照 MSS（Maximum Segment Size，最大报文段长度） 从缓冲区中取数据发送出去，当缓冲区中数据小于 MSS，则将剩余数据全部发送出去。TCP 的发送缓冲区必须为已发送的数据保留一个副本，直到它被对端确认为止，才能从缓冲区中删掉已确认的数据。 接收缓冲区1接收缓冲区被 TCP 用来保存接收到的数据，直到应用程序来读取。 流控制(Flow Control)12A mechanism to prevent a TCP sender from overwhelming a TCP receiver.TCP 流控制主要用于匹配发送端和接收端的速度，即根据接收端当前的接收能力来调整发送端的发送速度。 由于发送速度可能大于接收速度，接收端的应用程序未能及时从接收缓冲区读取数据，接收缓冲区不够大不能缓存所有接收到的报文等原因，TCP接收端的接收缓冲区很快就会被塞满；从而导致不能接收后续的数据，发送端此后发送数据是无效的，因此需要流控制。 六、HTTP 请求缓存（ CDN 节点缓存、代理服务器缓存、浏览器缓存、后端动态计算结果缓存等 ）在建立了 TCP 连接之后，就开始 HTTP 请求了 强缓存 ( Cache-Control 和 Expires ) 强缓存主要是采用响应头中的 Cache-Control 和 Expires 两个字段进行控制的。 1其中 Expires 是 HTTP 1.0 中定义的，它指定了一个绝对的过期时期。而 Cache-Control 是 HTTP 1.1 时出现的缓存控制字段。 由于 Expires 是 HTTP1.0 时代的产物，因此设计之初就存在着一些缺陷，如果本地时间和服务器时间相差太大，就会导致缓存错乱。 这两个字段同时使用的时候 Cache-Control 的优先级会更高一点。 这两个字段的效果是类似的，客户端都会通过对比本地时间和服务器返回的生存时间来检测缓存是否可用。如果缓存没有超出它的生存时间，客户端就会直接采用本地的缓存。如果生存日期已经过了，这个缓存也就宣告失效。接着客户端将再次与服务器进行通信来验证这个缓存是否需要更新。 在请求头中使用 Cache-Control 时，它可选的值有： 指令 说明 no-cache 使用代理服务器的缓存之前提交原始服务器验证，验证通过才能使用 no-store 在客户端或是代理服务器都不缓存请求或响应的任何内容 max-age=[秒] 告知服务器客户端可接受资源的存在最大时间 max-stale(=[秒]) 可接受（代理服务器缓存的）过期资源，参数可省略 min-fresh=[秒] 可接受（代理服务器缓存的）资源更新时间小于指定时间 no-transform 代理服务器不可以更改媒体类型 only-if-cached 客户端只接受已缓存的响应，若缓存不命中，则返回 504 错误 cache-extension 自定义扩展值，若服务器不知别该指令，就直接忽略 在响应头中使用 Cache-Control 时，它可选的值有： 指令 说明 public 表明该资源可以给多个用户使用 private(= name) 该资源是私有资源，指定的用户可以使用的缓存 no-cache 强制每次请求直接发送给源服务器，而不经过本地缓存版本的校验。 no-store 在客户端或是代理服务器都不缓存请求或响应的任何内容 no-transform 代理服务器不可以更改媒体类型 must-revalidate 可缓存但必须再向源服务器进行请求确认 proxy-revalidate 要求缓存服务器返回缓存的时候向源服务器进行请求确认 max-age=[秒] 告知客户端该资源在规定时间内是新鲜的，无需向服务器确认 s-maxage=[秒] 告知缓存服务该资源在规定时间内是新鲜的，无需向服务器确认 cache-extension 自定义扩展值，若服务器不识别该指令，就直接忽略 可缓存性1.public：响应可以被任何对象（客户端、代理服务器等）缓存。 2.private：只能被单个用户缓存，不能作为共享缓存。 3.no-cache：使用缓存副本之前，需要将请求提交给原始服务器进行验证，验证通过才可以使用。 4.only-if-cached：客户端只接受已缓存的响应，并且不向原始服务器检查是否有更新的拷贝。 到期1.max-age=：缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与 Expires 相反，时间是相对于请求的时间 2.s-maxage=：覆盖 max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略 3.max-stale[=]：表明客户端愿意接收一个已经过期的资源。可选的设置一个时间(单位秒)，表示响应不能超过的过时时间 4.min-fresh=：表示客户端希望在指定的时间内获取最新的响应 重新验证和重新加载1.must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。 2.proxy-revalidate：与 must-revalidate 作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略 其他 no-store：彻底得禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取。 no-transform：不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type 等 HTTP 头不能由代理修改。 协商缓存 ( Last-Modified 和 Etag )协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（ Not Modified ），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。 Last-Modified 和 If-Modified-Since1基于资源在服务器修改时间而验证缓存的过期机制 当客户端再次请求该资源的时候，会在其请求头上附带上 If-Modified-Since 字段（值就是第一次获取请求资源时响应头中返回的 Last-Modified 值）。如果修改时间未改变则表明资源未过期，命中缓存，服务器就直接返回 304 状态码，客户端直接使用本地的资源。否则，服务器重新发送响应资源，从而保证资源的有效性。 Etag 和 If-None-Match 1基于资源校验码（一般为md5值）而验证缓存的过期机制 当客户端再次请求该资源的时候，会在其请求头上附带上 If-None-Match 字段（值就是第一次获取请求资源时响应头中返回的 Etag 值），其值与服务器端资源文件的验证码进行对比，如果匹配成功直接返回 304 状态码，从浏览器本地缓存取资源文件。如果不匹配，服务器会把新的验证码放在请求头的 Etag 字段中，并且以 200 状态码返回资源。 需要注意的是当响应头中同时存在 Etag 和 Last-Modified 的时候，会先对 Etag 进行比对，随后才是 Last-Modified。 Etag 的问题 相同的资源，在两台服务器产生的 Etag 是不是相同的，所以对于使用服务器集群来处理请求的网站来说，Etag 的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。 静态资源和动态资源的请求过程解析 静态资源 第一次请求肯定是从服务器请求过来的资源，这个没有什么疑问，我们先看看第一次请求的响应头的内容： 我们发现第一次的响应头中包含可强缓存的相关字段 cache-control ,同时也包含了协商缓存的相关字段 etag 和 last-modified; 当强缓存和协商缓存字段同时存在时会进行以下步骤来请求资源： 1.强缓存和协商缓存同时存在，如果强缓存还在有效期内则直接使用缓存；如果强缓存不在有效期，协商缓存生效。即：强缓存优先级 &gt; 协商缓存优先级 2.强缓存的 expires 和 cache-control 同时存在时，cache-control 会覆盖 expires 的效果，expires 无论有没有过期，都无效。即：cache-control 优先级 &gt; expires 优先级。 3.协商缓存的 Etag 和 Last-Modified 同时存在时，会先对 Etag 进行比对，随后才是 Last-Modified。 即：ETag 优先级 &gt; Last-Modified 优先级。 第二次请求该资源的时候，就直接是从缓存中读取的： 1其实我们第一次获取的资源极有可能是从 CDN 节点的缓存中获取的，也很有可能是从中间代理服务器（nginx，node 等）的缓存中读取的；其中的好处不言而喻。 动态资源由于动态资源的返回结果不一致，所以这个我们肯定不会在浏览器（中间代理服务器）缓存动态的结果。 不过这里我们可以在后端缓存一些重复率比较高的相关的计算结果。 关于动态资源一般前端是不做缓存的。 后端缓存主要通过保留数据库连接，存储处理结果等方式缩短处理时间，尽快响应客户端请求。]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2Fpost%2F7f0ab579.html</url>
    <content type="text"><![CDATA[一、缓存的作用 减少冗余的数据传输，可节省流量 缓解带宽瓶颈问题，可更快加载页面 缓解瞬间拥塞，可缓解原始服务器的压力 降低距离延时，加快响应速度 二、缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1.Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 2.Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 3.Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先当前系统内存使用率高的话，文件优先存储进硬盘 4.Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 三、缓存过程分析浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 四、强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 1.Expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 2.Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。 no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 3.Expires和Cache-Control两者对比其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 五、协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存失效，返回200和请求结果。 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 1.Last-Modified和If-Modified-Since浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； 1Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match。 2.ETag和If-None-MatchEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 3.两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag。 六、缓存机制强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 七、实际场景应用缓存策略 频繁变动的资源1Cache-Control: no-cache 对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 不常变化的资源1Cache-Control: max-age=31536000 通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。 八、用户行为对浏览器缓存的影响所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种： 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。 参考：一文读懂前端缓存]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从URL输入到页面展现到底发生什么?]]></title>
    <url>%2Fpost%2Fb883e279.html</url>
    <content type="text"><![CDATA[打开浏览器从输入网址到网页呈现在大家面前，背后到底发生了什么？经历怎么样的一个过程？先给大家来张总体流程图，具体步骤请看下文分解！ 总体来说分为以下几个过程: DNS 解析:将域名解析成 IP 地址 TCP 连接：TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接：TCP 四次挥手 一、URL 到底是啥URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。比如 http://www.w3school.com.cn/html/index.asp，遵守以下的语法规则： scheme://host.domain:port/path/filename 各部分解释如下： scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。 host - 定义域主机(http 的默认主机是 www) domain - 定义因特网域名，比如 w3school.com.cn port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 二、域名解析（DNS）在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。大家这里或许会有个疑问—-计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 www.hackr.jp。那怎么不一开始就赋予个 IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址 IP 地址 IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。 域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。 什么是域名解析DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。 1例如 baidu.com 220.114.23.56（服务器外网IP地址）80（服务器端口号） 浏览器如何通过域名去查询 URL 对应的 IP 呢 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。 路由缓存：路由器也有 DNS 缓存。 ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推） 小结 浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。 三、TCP 三次握手在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。 TCP 三次握手的过程如下： 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了) 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧） 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧） 为啥需要三次握手 谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。 四、发送 HTTP 请求TCP 三次握手结束后，开始发送 HTTP 请求报文。请求报文由请求行（request line）、请求头（header）、请求体三个部分组成,如下图所示： 请求行包含请求方法、URL、协议版本 请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 URL 即请求地址，由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成 协议版本即 http 版本号 1POST /chapter17/user.html HTTP/1.1 以上代码中“POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。 1name=tom&amp;password=1234&amp;realName=tomson 上面代码，承载着 name、password、realName 三个请求参数。 五、服务器处理请求并返回 HTTP 报文 服务器 服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。 web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。 MVC 后台处理阶段 后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。 1、视图（view） 它是提供给用户的操作界面，是程序的外壳。 2、模型（model） 模型主要负责数据交互。在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。 3.控制器（controller） 它负责根据用户从”视图层”输入的指令，选取”模型层”中的数据，然后对其进行相应的操作，产生最终结果。控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。 这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。 至于这一阶段发生什么？简而言之，首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。 http 响应报文 响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示： (1) 响应行包含：协议版本，状态码，状态码描述 状态码规则如下： 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 (2) 响应头部包含响应报文的附加信息，由 名/值 对组成 (3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据 六、浏览器解析渲染页面浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制 浏览器解析渲染页面分为一下五个步骤： 根据 HTML 解析出 DOM 树 根据 CSS 解析生成 CSS 规则树 结合 DOM 树和 CSS 规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 根据 HTML 解析 DOM 树 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。 根据 CSS 解析生成 CSS 规则树 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。 浏览器在 CSS 规则树生成之前不会进行渲染。 结合 DOM 树和 CSS 规则树，生成渲染树 DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。 根据渲染树计算每一个节点的信息（布局） 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 根据计算好的信息绘制页面 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。 七、断开连接当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。几个字段需要重点介绍下:（1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。 （B）ACK：确认序号有效。 （C）PSH：接收方应该尽快将这个报文交给应用层。 （D）RST：重置连接。 （E）SYN：发起一个新连接。 （F）FIN：释放一个连接。 需要注意的是：（A）不要将确认序号Ack与标志位中的ACK搞混了。 （B）确认方Ack=发起方Req+1，两端配对。 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧) 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧) 参考地址: https://github.com/ljianshu/Blog/issues/24]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui常见问题]]></title>
    <url>%2Fpost%2F98ebfde1.html</url>
    <content type="text"><![CDATA[表单校验（多层嵌套）elementUI对表单的校验有自己的方法，要求传入model的必须为一个对象。但如果数据结构比较复杂，对象里面又嵌套对象，该如何校验？本文给出多层对象嵌套的方法。12345678910111213141516171819202122&lt;template&gt; &lt;el-form :model="formData" :rules="formRule" ref="formData" label-width="100px"&gt; &lt;el-form-item prop="name" label="姓名"&gt; &lt;el-input v-model="formData.name" &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="password" label="密码"&gt; &lt;el-input v-model="formData.password" &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="user.tel" label="手机号" &gt; &lt;el-input v-model="formData.user.tel" &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="phones[0].model" label="手机号"&gt; &lt;el-input v-model="formData.phones[0].model"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item v-for="(phone, index) in formData.phones" :label="phone.brand" :key="phone.brand" :prop="'phones.' + index + '.model'" :rules="&#123; required: true, message: 'model不能为空', trigger: 'blur' &#125;"&gt; &lt;el-input v-model="phone.model"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-button @click="handleSubmit"&gt;提交&lt;/el-button&gt; &lt;/template&gt; 1234567891011121314151617181920212223242526272829303132333435data () &#123; return &#123; formData:&#123; name: '', password: '', user: &#123; tel: '' &#125;, phones: [ &#123; brand: '华为', model: 'P9' &#125;, &#123; brand: '小米', model: 'MI8' &#125; ] &#125;, formRule:&#123; name: [&#123;required: true, message: '不能为空', trigger: 'blur'&#125;, &#123;pattern: /^[\u4E00-\u9FA5]+$/, message: '用户名只能为中文', trigger: 'blur'&#125;], password: [&#123;required: true, message: '不能为空', trigger: 'blur'&#125;, &#123;validator: Verify.validatePassword, trigger: 'blur'&#125;, ], 'user.tel' : [&#123;required: true, message: '手机号码不能为空', trigger: 'blur'&#125;], 'phones[0].model': [&#123;required: true, message: 'model不能为空', trigger: 'blur'&#125;], &#125;, &#125;&#125;, methods: &#123; handleSubmit()&#123; const t = this; t.$refs['formData'].validate((valid) =&gt; &#123; if(valid)&#123; console.log(this.formData); &#125; &#125;) &#125;&#125; 校验方法model绑定的formData中内层user也是一个对象，现在想要对tel进行校验，在prop中传递user.tel，并且在rules中也要指定user.tel即可。 对于验证规则，可以通过pattern或者validator来实现，pattern里面可以直接写正则表达式，不知道为啥文档中没有提到这点。之前的验证一般都是通过validator来实现的，验证方法单独写在一个文件中，这样可以做到整个项目公用，用到时只需通过import引一下即可。 table组件的单元格如何插入html内容(el-table-column同一行中读取多个数据)12345&lt;el-table-column label="列标题"&gt; &lt;template slot-scope="scope"&gt; &#123;&#123;scope.row&#125;&#125; &lt;/template&gt;&lt;/el-table-column&gt; 父子表单 父组件点击提交按钮验证子组件表单必填项解决方法：子组件先验证表单 传一个回调 父组件接受回调参数 提交成功 1234567891011121314151617父组件： // 提交 singleSampleDispatch() &#123; this.$refs['sampleMessage'].validate((valid) =&gt; &#123; if (valid) &#123; //提交表单 &#125; &#125;); &#125;子组件： validate(callback) &#123; this.$refs['sampleMessage'].validate((valid) =&gt; &#123; callback(valid); &#125;); &#125; 日期选择器时间选择范围限制官方文档中使用picker-options属性来限制可选择的日期，这里举例子稍做补充。 单个输入框的123456&lt;el-date-picker v-model="value1" type="date" placeholder="选择日期" :picker-options="pickerOptions0"&gt;&lt;/el-date-picker&gt; 情景1: 设置选择今天以及今天之后的日期12345678910data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &lt; Date.now() - 8.64e7; // return time.getTime() &lt; Date.now(); （不能选择当天时间） &#125; &#125;, &#125; &#125; 情景2: 设置选择今天以及今天以前的日期12345678910data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; return time.getTime() &gt; Date.now() - 8.64e6 // return time.getTime() &lt; Date.now(); （不能选择当天时间） &#125; &#125;, &#125; &#125; 情景3: 设置选择三个月之前到今天的日期123456789101112data ()&#123; return &#123; pickerOptions0: &#123; disabledDate(time) &#123; let curDate = (new Date()).getTime(); let three = 90 * 24 * 3600 * 1000; let threeMonths = curDate - three; return time.getTime() &gt; Date.now() || time.getTime() &lt; threeMonths;; &#125; &#125;, &#125; &#125; 两个输入框123456789101112&lt;el-date-picker v-model="value1" type="date" placeholder="开始日期" :picker-options="pickerOptions0"&gt;&lt;/el-date-picker&gt;&lt;el-date-picker v-model="value2" type="date" placeholder="结束日期" :picker-options="pickerOptions1"&gt;&lt;/el-date-picker&gt; 12345678910111213141516171819data()&#123; return &#123; pickerOptions0: &#123; disabledDate: (time) =&gt; &#123; if (this.value2 != "") &#123; return time.getTime() &gt; Date.now() || time.getTime() &gt; this.value2; &#125; else &#123; return time.getTime() &gt; Date.now(); &#125; &#125; &#125;, pickerOptions1: &#123; disabledDate: (time) =&gt; &#123; return time.getTime() &lt; this.value1 || time.getTime() &gt; Date.now(); &#125; &#125;, &#125; &#125; 关于上传图片的问题如果一个页面有很多个上传，并且这个上传功能是根据数据动态渲染的，那么如果让上传跟字段绑定呢？1234567&lt;el-upload :ref="item.fieldName" :action="importFileUrl" :on-change="(res,file)=&gt;&#123;return uploadFileImage(res,file, item.fieldName)&#125;" :on-preview="handlePreview" :file-list="form[item.fieldName]"&gt; &lt;/el-upload&gt; 这里我想表达的是on-change方法后边的函数，正常on-change方法会返给我们2个字段，一个res,file，但是我们这样写，就可以往下多传递个需要的字段。 el-checkbox-group动态绑定的问题，会出现点击一个结果全部选中的问题12345&lt;el-form-item v-if="item.type==='checkbox'" :label="item.name"&gt; &lt;el-checkbox-group v-model="form[item.fieldName]"&gt; &lt;el-checkbox v-for="(checkboxArr,radcheckbox) in item.options.options" :label="checkboxArr.name" :value="checkboxArr.fieldName"&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt;&lt;/el-form-item&gt; 这个问题主要是 这里v-model必须绑定的是个数组，切记。但是我们这样form[item.fieldName]，会默认绑定的是个字符串类型，我们可以在created里遍历数据强制this.$set(this.form, val.fieldName, [])把数据类型转换成数组类型 在表格中使用el-popover和el-input1234567891011121314151617181920&lt;el-table-column prop="wares_id" label="商品ID" align="center"&gt; &lt;template scope="scope"&gt; &lt;el-popover :ref="'popover_id_' + scope.row.id" trigger="click" placement="top" width="255"&gt; &lt;div class="editTitle"&gt;编辑商品ID&lt;/div&gt; &lt;hr&gt; &lt;div class="editContent"&gt; &lt;el-input v-model="scope.row.wares_id" class="edit" icon="circle-cross" :id="'wares_id_' + scope.row.id" :on-icon-click="clearInput"&gt;&lt;/el-input&gt; &lt;img src="/src/assets/sure.png" @click="modifyWares('wares_id', scope.row.id)" align="center"&gt; &lt;img src="/src/assets/cancel.png" @click="cancelModifyWares('id', scope.row.id)" align="center"&gt; &lt;/div&gt; &lt;el-button slot="reference" class="tableData" type="text" @click="getInputValue('wares_id', scope.row.id, scope.row.wares_id)"&gt; &#123;&#123;scope.row.wares_id&#125;&#125; &lt;/el-button&gt; &lt;/el-popover&gt; &lt;/template&gt;&lt;/el-table-column&gt; JS部分，用doClose()方法关闭el-popover 123cancelModifyWares (str, id) &#123; this.$refs['popover_' + str + '_' + id].doClose();&#125; 为el-input控件赋值，el-input是对input控件的封装，打印出el-input可以看到它就是一个div，里面放了一个input，所以为里面的input赋值即为为el-input赋值123getInputValue (field, id, value) &#123; document.getElementById(field + '_' + id).getElementsByTagName("input")[0].value = value;&#125;, el-input控件里放一个清除icon，点击该icon，里面内容清空，可以将event打印出来，寻找其他方法 123clearInput (event) &#123; event.target.nextSibling.value = "";&#125;, 回车自动提交表单解决：（阻止表单提交）12&lt;el-form :inline="true" :model="params" @submit.native.prevent&gt;&lt;/el-form&gt; 监听input回车1&lt;el-input v-on:keyup.enter.native="login"&gt;&lt;/el-input&gt; tree组件增删改参考 https://segmentfault.com/a/1190000011574698 table组件expand每次只展开一项文档没有具体属性，但是在issue找的方法都是结合row-key和expand-row-keys来实现这个功能参考 https://github.com/ElemeFE/element/issues/3747 解决: 123456&lt;el-table @expand="handleExpandRow" ref="row_table"&gt;&lt;/el-table&gt;//method:handleExpandRow(row,expanded)&#123; this.$refs.row_table.store.states.expandRows = expanded ? [row] : [];&#125;]]></content>
      <categories>
        <category>Element</category>
      </categories>
      <tags>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2Fpost%2Fe255a10a.html</url>
    <content type="text"><![CDATA[五层因特网协议栈五层因特网协议栈这个知识点对你来说或许有点枯燥，不过当你对这个协议栈有了一个初步的了解之后，你之前的某些疑问就会很明朗。 一、应用层 应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。 我们把应用层交互的数据单元称为报文 域名系统域名系统( Domain Name System )是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。 http 协议超文本传输协议（ HyperText Transfer Protocol ）是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。 二、传输层 传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。 传输层常用的两种协议 传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。 用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。 TCP（Transmisson Control Protocol） TCP 是面向连接的（需要先建立连接）； 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是一对一； TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。 UDP（User Datagram Protocol） UDP 是无连接的； UDP 是尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态； UDP 是面向报文的； UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如直播，实时视频会议等）； UDP 支持一对一、一对多、多对一和多对多的交互通信； UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。 单工数据传输只支持数据在一个方向上传输 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信； 全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 三、网络层 网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。 互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 四、数据链路层 数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层接下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。 五、物理层 在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。 同 OSI 七层协议模型、TCP/IP 四层模型的区别 OSI 七层模型 OSI七层协议模型主要是： 应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。 TCP/IP四层模型 TCP/IP是一个四层的体系结构，主要包括： 应用层、传输层、网络层和链路层。 各层对应 以下一张图很好的说明了这三种协议的区别 负责传输的 IP 协议按层次分，IP（Internet Protocol）网际协议位于网络层，IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件，其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。 IP 地址和 MAC 地址： 指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址，IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。 使用 ARP 协议凭借 MAC 地址进行通信 IP 间的通信依赖 MAC 地址。 ARP 是一种用以解释地址的协议，根据通信方的 IP 地址就可以反查出对应方的 MAC 地址。 TCP 协议如何保持传输的可靠性 TCP提供一种面向连接的、可靠的字节流服务。 面向连接 意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信； 字节流服务 意味着两个应用程序通过 TCP 连接交换 8bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。 TCP 之所以可靠，大体上由于以下原因： 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据； 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。 TCP/IP 通信传输流 借用图解 HTTP 一书中的图文： 发送端在层与层之间传输数据时，每经过一层必定会加上一个该层的首部信息。反之，接收端在层与层之间传输数据时，每经过一层会把相关的首部信息去掉。 TCP 三次握手和四次挥手TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC793 定义。 三次握手 第一次握手： 建立连接时，向服务器发出连接请求报文，这是报文首部中的同部位 SYN = 1，同时选择一个初始序列号 seq = x ，客户端进程进入了 SYN-SENT （同步已发送状态）状态,等待服务器确认； 第二次握手： 服务器收到 syn 包后，如果同意连接，则发出确认报文; 确认报文 ACK = 1，SYN = 1，确认号是 ack = x + 1，同时也要为自己初始化一个序列号 seq = y，此时服务器进程进入了 SYN-RCVD（同步收到）状态； 第三次握手： 客户端收到服务器的 SYN+ACK 包，要向服务器给出确认。确认报文的 ACK = 1，ack = y + 1，自己的序列号 seq = x + 1，此时，TCP 连接建立，客户端进入 ESTABLISHED （已建立连接）状态。 完成三次握手，客户端与服务器开始传送数据。 注： seq:”sequance” 序列号； ack:”acknowledge” 确认号； SYN:”synchronize” 请求同步标志； ACK:”acknowledge” 确认标志； FIN:”Finally” 结束标 未连接队列 在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户端发出确认，正在等待客户端的确认包。这些条目所标识的连接在服务器处于 SYN_RECV状态，当服务器收到客户端的确认包时，删除该条目，服务器进入ESTABLISHED状态。 建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由 TCP 的半关闭（half-close）造成的。 四次挥手 第一次挥手： 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN=1，其序列号为 seq = u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入 FIN-WAIT-1（终止等待1）状态。 第二次挥手： 服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。 TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 第三次挥手： 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1，ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。 第四次挥手： 客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1，而自己的序列号是 seq = u + 1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。 注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。 可以看到，服务器结束 TCP 连接的时间要比客户端早一些。 四次的原因 这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。 但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你未必会马上会关闭 SOCKET ,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的. 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 DNS 域名解析当你在浏览器的地址栏输入 https://juejin.im 后会发生什么，大家在心中肯定是有一个大概的，这里我将 DNS 域名解析 这个步骤详细的讲一遍。在讲概念之前我先放上一张经典的图文供大家思考一分钟。 查找域名对应的 IP 地址的具体过程 浏览器搜索自己的 DNS 缓存（浏览器维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步； 搜索操作系统中的 DNS 缓存；如果没有命中，进入下一步； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步； (1) 操作系统将域名发送至 LDNS （本地区域名服务器），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：(2) LDNS向 Root Name Server（根域名服务器，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址；(3) LDNS 向 im 域的顶级域名服务器发起请求，返回 juejin.im 域名服务器地址；(4) LDNS 向 juejin.im 域名服务器发起请求，得到 juejin.im 的 IP 地址；(5) LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来。 DNS Prefetch即 DNS 预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 减少 DNS 的请求次数 进行 DNS 预获取 典型的一次 DNS 解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。 CDN 带来的性能优化CDN的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 CDN的优势 CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低； 大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载。CDN 的核心点有两个: 一个是缓存，一个是回源。 关键技术 内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处； 内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应； 内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量； 性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。 五类 IP 地址 网络地址：用于识别主机所在的网络；主机地址：用于识别该网络中的主机。 IP地址分为五类： A 类保留给政府机构 B 类分配给中等规模的公司 C 类分配给任何需要的人 D 类用于用于特殊用途. 又称做广播地址 E 类暂时保留 各类可容纳的地址数目不同。其中A类、B类、和C类这三类地址用于 TCP/IP 节点，其它两类D类和E类被用于特殊用途。 首先用一张图给大家一个初步的概念： 一. A类地址第一个八位段为网络地址，其它为主机地址，第一个八位段首位一定为0；范围：1.0.0.1—126.155.255.254；私有地址和保留地址：10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。127.X.X.X是保留地址，用做循环测试用的。 二. B类地址第一个八位段和第二个八位段为网络地址，其它为主机地址，第一个八位段首位一定为10；范围：128.0.0.1—191.255.255.254。私有地址和保留地址:172.16.0.0—172.31.255.255是私有地址169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。 三. C类地址前三个八位段为网络地址，第4个个字节为主机地址，第一个八位段首位一定为110。范围：192.0.0.1—223.255.255.254。私有地址：192.168.X.X是私有地址。 四. D类地址不分网络地址和主机地址，第一个八位段首位一定为1110。范围：224.0.0.1—239.255.255.254 五. E类地址不分网络地址和主机地址，第一个八位段首位一定为11110。范围：240.0.0.1—255.255.255.254 HTTP 与 HTTPS 的区别 区别 HTTP HTTPS 协议 运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。 端口 80 443 资源消耗 较少 由于加解密处理，会消耗更多的 CPU 和内存资源 开销 无需证书 需要证书，而证书一般需要向认证机构购买 加密机制 无 共享密钥加密和公开密钥加密并用的混合加密机制 安全性 弱 由于加密机制，安全性强 对称加密与非对称加密对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方； 而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢. 综上：我们还是用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 HTTP2在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。 HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。 http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来 http2.0的一些特性： 多路复用（即一个tcp/ip连接可以请求多个资源） 首部压缩（http头部压缩，减少体积） 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量） 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端） 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。） 长连接与短连接 首先看tcp/ip层面的定义： 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包） 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接 然后在http层面： http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接 http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接 注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript闭包]]></title>
    <url>%2Fpost%2F7f0c7f23.html</url>
    <content type="text"><![CDATA[闭包定义123456789function a()&#123; //建立函数a var i=0; //定义变量i function b()&#123; //在函数a内套入函数b alert(++i); //提示框，输出i的值 &#125; return b; //返回函数b的值&#125;var c = a(); //将函数a赋给变量cc(); //输出c 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 要理解闭包，需要先理解全局作用域和局部作用域的区别。函数内部可以访问全局作用域下定义的全局变量，而函数外部却无法访问到函数内部定义(局部作用域)的局部变量。1234567var a = 1;function keith() &#123; return a; var b = 2; &#125; console.log(keith()); //1 console.log(b); //ReferenceError: b is not defined 上面代码中，全局变量a可以在函数keith内部访问。可是局部变量b却无法在函数外部访问。 如果需要得到函数内部的局部变量，只有通过在函数的内部，再定义一个函数。1234567891011121314151617function keith()&#123; var a=1; function rascal()&#123; return a; &#125; return rascal;&#125;var result=keith();console.log(result()); //1function keith()&#123; var a=1; return function()&#123; return a; &#125;;&#125;var result=keith();console.log(result()) //1 上面代码中，两种写法相同，唯一的区别是内部函数是否是匿名函数。函数rascal就在函数keith内部，这时keith内部的所有局部变量，对rascal都是可见的。但是反过来就不行，rascal内部的局部变量，对keith就是不可见的。这就是JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。函数keith的返回值就是函数rascal，由于rascal可以读取keith的内部变量，所以就可以在外部获得keith的内部变量了。 闭包就是函数rascal，即能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如rascal记住了它诞生的环境keith，所以从rascal可以得到keith的内部变量。 闭包可以使得它诞生环境一直存在。看下面一个例子，闭包使得内部变量记住上一次调用时的运算结果。123456789function keith(num) &#123; return function() &#123; return num++; &#125;;&#125;var result = keith(2);console.log(result()) //2console.log(result()) //3console.log(result()) //4 上面代码中，参数num其实就相当于函数keith内部定义的局部变量。通过闭包，num的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包result使得函数keith的内部环境，一直存在。 通过以上的例子，总结一下闭包的特点： 1：在一个函数内部定义另外一个函数，并且返回内部函数或者立即执行内部函数。2：内部函数可以读取外部函数定义的局部变量3：让局部变量始终保存在内存中。也就是说，闭包可以使得它诞生环境一直存在。 闭包的作用以上函数为例，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC（垃圾回收机制）不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。那么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。123456789101112131415161718function Keith(name) &#123; var age; function setAge(n) &#123; age = n; &#125; function getAge() &#123; return age; &#125; return &#123; name: name, setAge: setAge, getAge: getAge &#125;;&#125;var person = Keith('keith');person.setAge(21);console.log(person.name); // 'keith'console.log(person.getAge()); //21 闭包的应用场景 保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。 在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。 立即调用的函数表达式（IIFE）通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 循环中的闭包一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号12345for(var i=0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i); //10 &#125;, 1000)&#125; 上面代码中，不会符合我们的预期，输出数字0-9。而是会输出数字10十次。 当匿名函数被调用的时候，匿名函数保持着对全局变量 i 的引用，也就是说会记住i循环时执行的结果。此时for循环结束，i 的值被修改成了10。 为了得到想要的效果，避免引用错误，我们应该使用IIFE来在每次循环中创建全局变量 i 的拷贝。 1234567for(var i = 0; i &lt; 10; i++) &#123; (function(e) &#123; setTimeout(function() &#123; console.log(e); //1,2,3,....,10 &#125;, 1000); &#125;)(i); &#125; 外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 e 变量就拥有了 i 的一个拷贝。当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。 参考链接]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生javascript相关问题总结]]></title>
    <url>%2Fpost%2Ff76aca3e.html</url>
    <content type="text"><![CDATA[new 的过程和实现12345678function myNew (Parent, ...rest) &#123; // 1. 以构造函数的prototype属性为原型，创建新对象 let child = Object.create(Parent.prototype) // 将新对象的__proto__指向Parent.prototype obj.__proto__ = Parent.prototype // 2. 执行构造函数，并将this执行新对象(将this和调用参数传给构造器执行) let result = Parent.apply(child, rest) // 3. 如果构造器没有手动返回对象，则返回第一步的对象 return typeof result === 'object' ? result : child;&#125; 优先级问题优先级由高到低：小括号(xxx) &gt; 属性访问. &gt; new foo() &gt; foo()12345678910111213141516171819202122232425function getName () &#123; console.log(1)&#125;function Foo () &#123; this.getName = function () &#123; console.log(2) &#125; console.log('123', this) return this&#125;Foo.getName = function () &#123; console.log(3)&#125;//先从.属性访问符号开始往前面找一个最近的对象，同时注意new Foo()优先于Foo();var a = new Foo.getName();//3;// 属性.的优先级高于new foo()，所以===new (Foo.getName)();返回Foo.getName类型的实例var b = new Foo().getName() // 2 new foo()的优先级高于foo()，所以就相当于new foo()的属性，===(new Foo()).getName()；返回Foo.getName类型的实例var c = new new Foo().getName() //2// new foo()优先级低于属性.，所以其实相当于就是new一个new foo()的getName属性函数，===new (new Foo().getName)();返回undefinednew Date().getTime();//===((new Date()).getTime)()(new Date).getTime();//===((new Date()).getTime)()new Date.getTime();//Uncaught TypeError: Date(...).getTime is not a function；===new (Date.getTime)() JavaScript中call、apply、bind作用：可以指定函数运行时的this（执行上下文context）。然后在所指定的作用域中，调用该函数。并且会立即执行该函数。call和apply方法都是在调用之后立即执行的。而bind调用之后是返回原函数，需要再调用一次才行区别： call的传参方式为若干参数列表 xx.call(null, arg1, arg2) apply的传参方式为一个包含多个参数的数组 xx.apply(null, [arg1, arg2]) bind的传参方式与call一样，然后返回一个新函数。bind方法并非立即执行一个函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Function.prototype.fakeCall = function (obj) &#123; // 处理传入的值是基本数据类型的情况，特别是 null obj = typeof obj !== 'object' ? window : obj || window // 取出除 obj 参数外剩下的参数 let args = [].slice.call(arguments, 1) // 在传入的 obj 上创建一个属性，将该属性指向调用的函数 obj.fn = this // 然后执行 fn，则会将调用的函数的 this 指向 obj let result = obj.fn(...args) // 最后将创建的 fn 属性删除 delete obj.fn // 返回函数执行结果 return result&#125;let foo = &#123; value: 1&#125;function bar(name, age) &#123; console.log(name) // xuedinge console.log(age) // 20 return &#123; color: "yuanliangse" &#125;&#125;console.log(bar.fakeCall(undefined, "xuedinge", "20")) // &#123;color: "yuanliangse"&#125;Function.prototype.fakeApply = function (obj) &#123; obj = typeof !== 'object' ? window : obj | window obj.fn = this let args = [].slice.call(arguments, 1) obj.fn(...args[0]) delete obj.fn return result&#125;Function.prototype.fakeBind = function(context) &#123; const self = this // bind 方法传的参数 const bindArgs = [].slice.call(arguments, 1) const fn = function() &#123;&#125; const fBound = function() &#123; // bind 方法返回的函数传入的参数 const newArgs = [].slice.call(arguments) // bind方法返回的新函数当构造函数使用时，bind方法提供的this要失效,this要指向new构造出来的实例, // 关于这一点，简单来说就是新的函数this指向的问题，那么我们在给新的函数绑定this时，判断下是不是当构造函数使用就可以了。 return self.apply( // 当作构造函数使用时，this 指向实例，this instanceof fBound 为 true this instanceof fn ? this : context, bindArgs.concat(newArgs) ) &#125; // 将实例的原型指向绑定函数的原型 // fBound.prototype = this.prototype // 这里需要注意一点，我们手动修改fBound的原型时（fBound.prototype = &#123;&#125;），也会修改绑定函数的原型（复杂类型，指针指向共同的堆内存），所以，我们使用一个空函数中转一下绑定函数的原型 fn.prototype = this.prototype fBound.prototype = new fn() return fBound&#125;// 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：var value = 2; var foo = &#123;value: 1 &#125;; function bar(name, age) &#123; this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age); &#125; bar.prototype.friend = 'kevin'; var bindFoo = bar.bind(foo, 'daisy'); var obj = new bindFoo('18'); // undefined // daisy // 18 console.log(obj.habit); console.log(obj.friend); // shopping // kevin// 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 js 难点之 bind 实现 JavaScript中this关键字的理解this的基本概念： this指的是函数运行时所在的环境，当前执行函数的上下文，具体值和函数的调用方式有关。this绑定的规则 默认绑定 隐式绑定 硬绑定 new绑定 默认绑定默认绑定是在不能应用其他绑定规则时使用的默认规则，通常是独立函数调用。12345function sayHi () &#123; console.log('Hello', this.name)&#125;var name = 'abc'sayHi(); 在调用Hi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。 上面的代码，如果在浏览器环境中运行，那么结果就是 Hello,abc 但是如果在node环境中运行，结果就是 Hello,undefined.这是因为node中name并不是挂在全局对象上的。 隐式绑定函数调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为XXX.fun()123456789function sayHi () &#123; console.log('Heollo', this.name)&#125;var person = &#123; name: 'abc', sayHi: sayHi&#125;var name = 'bcd'person.sayHi() 打印的结果是 Hello,abc. sayHi函数声明在外部，严格来说并不属于person，但是在调用sayHi时,调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this(即此例sayHi函数中的this)绑定到这个上下文对象（即此例中的person） 需要注意的是：对象属性链中只有最后一层会影响到调用位置。123456789101112function sayHi()&#123; console.log('Hello,', this.name);&#125;var person2 = &#123; name: 'Christina', sayHi: sayHi&#125;var person1 = &#123; name: 'YvetteLau', friend: person2&#125;person1.friend.sayHi(); 结果是：Hello, Christina. 因为只有最后一层会确定this指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的friend。 隐式绑定有一个大陷阱，绑定很容易丢失(或者说容易给我们造成误导，我们以为this指向的是什么，但是实际上并非如此).12345678910function sayHi()&#123; console.log('Hello,', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = person.sayHi;Hi(); 结果是: Hello,Wiliam. 这是为什么呢，Hi直接指向了sayHi的引用，在调用的时候，跟person没有半毛钱的关系，针对此类问题，我建议大家只需牢牢继续这个格式:XXX.fn();fn()前如果什么都没有，那么肯定不是隐式绑定。 除了上面这种丢失之外，隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子:123456789101112131415161718192021function sayHi()&#123; console.log('Hello,', this.name);&#125;var person1 = &#123; name: 'YvetteLau', sayHi: function()&#123; setTimeout(function()&#123; console.log('Hello,',this.name); &#125;) &#125;&#125;var person2 = &#123; name: 'Christina', sayHi: sayHi&#125;var name='Wiliam';person1.sayHi();setTimeout(person2.sayHi,100);setTimeout(function()&#123; person2.sayHi();&#125;,200); 结果为:123Hello, WiliamHello, WiliamHello, Christina 第一条输出很容易理解，setTimeout的回调函数中，this使用的是默认绑定，非严格模式下，执行的是全局对象 第二条输出是不是有点迷惑了？说好XXX.fun()的时候，fun中的this指向的是XXX呢，为什么这次却不是这样了！Why? 其实这里我们可以这样理解: setTimeout(fn,delay){ fn(); },相当于是将person2.sayHi赋值给了一个变量，最后执行了变量，这个时候，sayHi中的this显然和person2就没有关系了。 第三条虽然也是在setTimeout的回调中，但是我们可以看出，这是执行的是person2.sayHi()使用的是隐式绑定，因此这是this指向的是person2，跟当前的作用域没有任何关系。 显示绑定显式绑定比较好理解，就是通过call,apply,bind的方式，显式的指定this所指向的对象。(注意:《你不知道的Javascript》中将bind单独作为了硬绑定讲解了) all,apply和bind的第一个参数，就是对应函数的this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。12345678910function sayHi()&#123; console.log('Hello,', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = person.sayHi;Hi.call(person); //Hi.apply(person) 输出的结果为: Hello, YvetteLau. 因为使用硬绑定明确将this绑定在了person上。 那么，使用了硬绑定，是不是意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，继续往下看。123456789101112function sayHi()&#123; console.log('Hello,', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = function(fn) &#123; fn();&#125;Hi.call(person, person.sayHi) 输出的结果是 Hello, Wiliam. 原因很简单，Hi.call(person, person.sayHi)的确是将this绑定到Hi中的this了。但是在执行fn的时候，相当于直接调用了sayHi方法(记住: person.sayHi已经被赋值给fn了，隐式绑定也丢了)，没有指定this的值，对应的是默认绑定。 现在，我们希望绑定不会丢失，要怎么做？很简单，调用fn的时候，也给它硬绑定。123456789101112function sayHi()&#123; console.log('Hello,', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = function(fn) &#123; fn.call(this);&#125;Hi.call(person, person.sayHi); 此时，输出的结果为: Hello, YvetteLau，因为person被绑定到Hi函数中的this上，fn又将这个对象绑定给了sayHi的函数。这时，sayHi中的this指向的就是person对象。 new 绑定 javaScript和Ｃ＋＋不一样，并没有类，在javaScript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例化出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。 使用new来调用函数，会自动执行下面的操作： 创建一个新对象 将构造函数的作用域赋值给新对象，即this指向这个新对象 执行构造函数中的代码 返回对象 因此，我们使用new来调用函数的时候，就会新对象绑定到这个函数的this上。但是前提是构造函数中没有返回对象或者是function，否则this指向这个对象或者是function 123456function sayHi(name)&#123; this.name = name; &#125;var Hi = new sayHi('Yevtte');console.log('Hello,', Hi.name); 输出结果为 Hello, Yevtte, 原因是因为在var Hi = new sayHi(‘Yevtte’);这一步，会将sayHi中的this绑定到Hi对象上。 绑定优先级 我们知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？ 显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为: new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 这个规则时如何得到的，大家如果有兴趣，可以自己写个demo去测试，或者记住上面的结论即可。 绑定例外 凡事都有例外，this的规则也是这样。 如果我们将null或者是undefined作为this的绑定对象传入call、apply或者是bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。 12345678var foo = &#123; name: 'Selina'&#125;var name = 'Chirs';function bar() &#123; console.log(this.name);&#125;bar.call(null); //Chirs 输出的结果是 Chirs，因为这时实际应用的是默认绑定规则。 箭头函数 箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用时，需要注意以下几点: 函数体内的this对象，继承的是外层代码块的this。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向。 12345678910111213141516171819202122232425var obj = &#123; hi: function()&#123; console.log(this); return ()=&gt;&#123; console.log(this); &#125; &#125;, sayHi: function()&#123; return function() &#123; console.log(this); return ()=&gt;&#123; console.log(this); &#125; &#125; &#125;, say: ()=&gt;&#123; console.log(this); &#125;&#125;let hi = obj.hi(); //输出obj对象hi(); //输出obj对象let sayHi = obj.sayHi();let fun1 = sayHi(); //输出windowfun1(); //输出windowobj.say(); //输出window obj.hi(); 对应了this的隐式绑定规则，this绑定在obj上，所以输出obj，很好理解。 hi(); 这一步执行的就是箭头函数，箭头函数继承上一个代码库的this，刚刚我们得出上一层的this是obj，显然这里的this就是obj. 执行sayHi();这一步也很好理解，我们前面说过这种隐式绑定丢失的情况，这个时候this执行的是默认绑定，this指向的是全局对象window. fun1(); 这一步执行的是箭头函数，如果按照之前的理解，this指向的是箭头函数定义时所在的对象，那么这儿显然是说不通。OK，按照箭头函数的this是继承于外层代码库的this就很好理解了。外层代码库我们刚刚分析了，this指向的是window，因此这儿的输出结果是window. obj.say(); 执行的是箭头函数，当前的代码块obj中是不存在this的，只能往上找，就找到了全局的this，指向的是window. 箭头函数的this是静态的？12345678910111213141516171819202122232425var obj = &#123; hi: function()&#123; console.log(this); return ()=&gt;&#123; console.log(this); &#125; &#125;, sayHi: function()&#123; return function() &#123; console.log(this); return ()=&gt;&#123; console.log(this); &#125; &#125; &#125;, say: ()=&gt;&#123; console.log(this); &#125;&#125;let sayHi = obj.sayHi();let fun1 = sayHi(); //输出windowfun1(); //输出windowlet fun2 = sayHi.bind(obj)();//输出objfun2(); //输出obj 可以看出，fun1和fun2对应的是同样的箭头函数，但是this的输出结果是不一样的。 所以，请大家牢牢记住一点: 箭头函数没有自己的this，箭头函数中的this继承于外层代码库中的this. 1. 如何准确判断this指向的是什么？ 函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。 函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。 函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo() 如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。 如果把Null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 如果是箭头函数，箭头函数的this继承的是外层代码块的this。 2. 执行过程解析 123456789101112131415161718192021var number = 5;var obj = &#123; number: 3, fn: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125; &#125;)()&#125;var myFun = obj.fn;myFun.call(null);obj.fn();console.log(window.number); 在定义obj的时候，fn对应的闭包就执行了，返回其中的函数，执行闭包中代码时，显然应用不了new绑定(没有出现new 关键字)，硬绑定也没有(没有出现call,apply,bind关键字),隐式绑定有没有？很显然没有，如果没有XX.fn()，那么可以肯定没有应用隐式绑定，所以这里应用的就是默认绑定了，非严格模式下this绑定到了window上(浏览器执行环境)。【这里很容易被迷惑的就是以为this指向的是obj，一定要注意，除非是箭头函数，否则this跟词法作用域是两回事，一定要牢记在心】 12345window.number * = 2; //window.number的值是10(var number定义的全局变量是挂在window上的)number = number * 2; //number的值是NaN;注意我们这边定义了一个number，但是没有赋值，number的值是undefined;Number(undefined)-&gt;NaNnumber = 3; //number的值为3 myFun.call(null);我们前面说了，call的第一个参数传null，调用的是默认绑定;1234567fn: function()&#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number);&#125; 执行时:12345var num = this.number; //num=10; 此时this指向的是windowthis.number * = 2; //window.number = 20console.log(num); //输出结果为10number *= 3; //number=9; 这个number对应的闭包中的number;闭包中的number的是3console.log(number); //输出的结果是9 obj.fn();应用了隐式绑定，fn中的this对应的是obj12345var num = this.number;//num = 3;此时this指向的是objthis.number *= 2; //obj.number = 6;console.log(num); //输出结果为3;number *= 3; //number=27;这个number对应的闭包中的number;闭包中的number的此时是9console.log(number); //输出的结果是27 4.最后一步console.log(window.number);输出的结果是20 因此组中结果为:1234510932720]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css相关问题总结]]></title>
    <url>%2Fpost%2Fe7919f0c.html</url>
    <content type="text"><![CDATA[BFC一、什么是BFCFormatting context 是W3C css2.1规范中的一个概念。它是页面中的的一块渲染区域，并且有一套渲染规则，它决定了其子元素该如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context有 Block Formatting context（简称BFC）以及Inline Formatting context（简称IFC）。BFC直译“块级格式化上下文”，它是一个独立的渲染区域，只有block-level box参与，它规定了block-level box内部如何布局，并且与这个区域外部毫不相干。通俗的讲，BFC是一个容器，用于管理块级元素。 二、如何创建BFC float为 left|right overflow为 hidden|auto|scroll display: table-cell|table-caption|inline-block|inline-flex|flex position: absolute|fixed 跟元素 三、BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置（即块级元素独占一行）。 BFC的区域不会与float box重叠（利用这一点可以实现自适应两栏布局）。 内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（margin重叠的三个条件：同属于一个BFC；相邻；块级元素）。 计算BFC的高的时，浮动元素也参与计算。（清除浮动 haslayout）。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。 四、 BFC有哪些特性特性1：BFC会阻止垂直外边距折叠 按照BFC的定义，只有属于同一个BFC时，两个元素才有可能发生垂直margin的重叠，这个包括相邻元素或嵌套元素，只有他们之前没有阻挡（比如边框、非空内容、padding等）就会发生margin重叠。 ①相邻兄弟元素margin重叠问题1234567891011121314&lt;style&gt;p&#123; color: #fff; background: #888; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;ABC&lt;/p&gt; &lt;p&gt;abc&lt;/p&gt;&lt;/body&gt; 上面例中两个P元素之间距离本该为200px,然而实际上只有100px,发生了margin重叠。遇到这种情形，我们如何处理？ 只需要在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 12345678910111213141516171819&lt;style&gt;p&#123; color: #fff; background: #888; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;.wrap&#123; overflow:hidden;&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;ABC&lt;/p&gt; &lt;div class="wrap"&gt; &lt;p&gt;abc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; ②父子元素margin重叠问题 1234567891011121314151617181920&lt;style&gt;.box&#123;width:100px;height:100px;background:#ccc;&#125;.wrap &#123; background:yellow;&#125;.wrap h1&#123; background:pink; margin:40px;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="box"&gt;box&lt;/div&gt;&lt;div class="wrap"&gt; &lt;h1&gt;h1&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; 上图wrap元素与h1元素之间l理论上本该有个40px的上下margin值,然而实际上父子元素并没有存在margin值，与此同时，两个div元素的间距为40px。遇到这种情形，我们如何处理？ 处理方法其实有很多，在wrap元素中添加:overflow:hidden;或者overflow：auto；使其父元素形成一个BFC；也可以在wrap元素中添加border：1px solid；或是padding：1px；这些都可以有效解决父子元素margin重叠问题。 特性2：BFC不会重叠浮动元素 利用这个特性，我们可以创造自适应两栏布局。 上图中，文字围绕着浮动元素排列，不过在这里，这显然不是我们想要的。此时我们可以为.box2元素的样式加上overflow:hidden；使其建立一个BFC,让其内容消除对外界浮动元素的影响。 这个方法可以用来实现两列自适应布局，效果不错，此时左边的宽度固定，右边的内容自适应宽度。如果我们改变文字的大小或者左边浮动元素的大小，两栏布局的结构依然没有改变！ 特性3：BFC可以包含浮动—-清除浮动 我们都知道浮动会脱离文档流，接下来我们看看下面的例子：1234567891011121314151617181920212223&lt;style&gt;.box1&#123; width:100px; height:100px; float:left; border: 1px solid #000;&#125;.box2&#123; width:100px; height:100px; float:left; border: 1px solid #000;&#125;.box&#123; background:yellow&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt; 由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。 flex一、Flex概念flex Flexible Box “弹性布局”，设为Flex布局以后，子元素的float、clear和vertical-aline的属性将会失效。任何一个容器都可以指定为flex布局，采用flex布局的容器称为Flex容器（flex container），简称“容器”，它所有的子元素自动成为容器成员，成为flex项目，简称项目“项目”。 二、常用属性 以下6个属性设置在容器上12345flex-direction (决定主轴方向，即项目的排列方向)flex-warp（如果一条轴线排不下，如何换行）flex-flow（以上两种的简写形式，默认值row nowarp）justify-content（定义项目在主轴的对齐方式）align-content（定义多跟轴的对齐，如果项目只有一根轴线，该属性不起作用） （1）flex-direction属性 决定主轴的方向（即项目的排列方向） row（默认值）：主轴水平方向，起点在左端 row-reverse：主轴在水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse；主轴为垂直方向，起点在下沿123.box &#123; flex-direction: column-reverse | column | row | row-reverse&#125; (2) flex-wrap属性 默认情况下，项目都排在一条线（又称“轴线”）上，flex-wrap属性定义，如果一天轴线排不下，如何换行 nowrap: (默认值)，不换行 wrap: 换行，第一行在上方 warp-reverse: 换行，第一行在下方 123.box &#123; flex-wrap: nowrap | wrap | wrap-reverse&#125; (3) flex-flow 属性 flex-flow 是flex-direction 和 flex-wrap的缩写123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;&#125; (4) justify-content 属性定义了项目在主轴上的对齐方式 flex-start: (默认值) 左对齐 flex-end: 右对齐 center: 居中 space-between: 两端对齐，项目之前间隔相等 space-around: 每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍。 123.box &#123; jsutify-content: flex-start | flex-end | center | space-between | space-around&#125; (5) align-items 属性 align-items定义了项目在主轴如何对齐 flex-start: 交叉轴的起点对齐 flex-end: 交叉轴的终点对齐 center: 交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐 stretch: （默认值）如果项目为设置高度或者设置auto，将占满整个容器的高度 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch&#125; (6) align-content 属性 align-content属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用 flex-start: 交叉轴的起点对齐 flex-end: 交叉轴的终点对齐 center: 与交叉轴的中点对齐 space-between: 与交叉轴的两端对齐，轴线之间的间隔平均分布 space-around: 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch: (默认值) 轴线占满整个交叉轴。 123.box&#123; align-content: flex-start | flex-end | center | space-between | sapce-around | stretch&#125; 3.以下6个属性设置在项目上 123456order (定义项目的排列顺序，数值越小，排列越靠前，默认值为0)flex-grow (定义项目的放大比例,默认0)flex-shrink (定义项目的缩小比例，默认1，即如果项目空间不足，该项目将缩小，负值无效)flex-basis (定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。)flex (flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选)align-self (align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch) 水平居中1) 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中. 2) 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央.12345678.parent::after, .son&#123; display:inline-block; vertical-align:middle;&#125;.parent::after&#123; content:''; height:100%;&#125; 元素高度不定 3) 可用 vertical-align 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle; 优点 元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断. 缺点 IE6~7, 甚至IE8 beta中无效. 4) 可用 Flex 2012版, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《弹性盒模型Flex指南》1234.parent &#123; display: flex; align-items: center;&#125; 优点 内容块的宽高任意, 优雅的溢出. 可用于更复杂高级的布局技术中. 缺点 IE8/IE9不支持 需要浏览器厂商前缀 渲染上可能会有一些问题 5) 可用 transform , 设置父元素相对定位(position:relative), 子元素如下css样式:1234567.son&#123; position:absolute; top:50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; 优点 代码量少 缺点 IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象. 总结 水平居中较为简单, 共提供了8种方法, 一般情况下 text-align:center,marin:0 auto; 足矣 ① text-align:center; ② margin:0 auto; ③ width:fit-content; ④ flex ⑤ 盒模型 ⑥ transform ⑦ ⑧ 两种不同的绝对定位方法 垂直居中, 共提供了8种方法 ① 单行文本, line-height ② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现 ③ vertical-align ④ flex ⑤ 盒模型 ⑥ transform ⑦ ⑧ 两种不同的绝对定位方法 圣杯布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188一、table&lt;button class="button1"&gt;主体内容上添加内容&lt;/button&gt;&lt;div class="wrapper"&gt; &lt;div class="header"&gt;头部&lt;/div&gt; &lt;div class="main"&gt; &lt;div class="box sidebar"&gt;左侧栏&lt;/div&gt; &lt;div class="box content"&gt;主体内容&lt;/div&gt; &lt;div class="box sidebar"&gt;有侧栏&lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt;页脚底部&lt;/div&gt;&lt;/div&gt;body &#123; background: @beige; color: black;&#125;.wrapper &#123; height: 100%; display: table; width: 100%; text-align: center;&#125;.header &#123; display: table-row; height: 1px; background: @yellow;&#125;.main &#123; height: 100%; display: table; width: 100%;&#125;.box &#123; display: table-cell;&#125;.sidebar &#123; width: 100px; background: @orange;&#125;.footer &#123; display: table-row; height:1px; background: @green; color: @beige;&#125;/*====== Ignore section below ======*/@orange: #BD4932;@yellow: #FFD34E;@green: #105B63;@beige: #FFFAD5;二、felx&lt;div class='container'&gt; &lt;header&gt;头部&lt;/header&gt; &lt;section&gt; &lt;div class='left'&gt;左&lt;/div&gt; &lt;div class='center'&gt;中&lt;/div&gt; &lt;div class='right'&gt;右&lt;/div&gt; &lt;/section&gt; &lt;footer&gt;底部&lt;/footer&gt;&lt;/div&gt;&lt;style&gt; *&#123; margin:0;padding:0; &#125; .container&#123; display: flex; height: 100vh; flex-direction: column; &#125; header&#123; background: #000; &#125; section&#123; flex:1; background: pink; display: flex; &#125; footer&#123; background: #000; &#125; .left&#123; background: red; flex:0 0 100px; &#125; .center&#123; flex:1; background: blue; &#125; .right&#123; flex:0 0 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;三、float &lt;div class="main"&gt; &lt;div class="center"&gt;中间&lt;/div&gt; &lt;div class="left"&gt;左边&lt;/div&gt; &lt;div class="right"&gt;右边&lt;/div&gt; &lt;/div&gt;&lt;style type="text/css"&gt; *&#123; margin: 0; padding: 0; color: black; font-size: 45px &#125; .main&gt;div&#123; float: left; &#125; .main&#123; width: 100%; background: yellow &#125; .center&#123; background: red; margin-left: 200px; margin-right: -200px; width: 100% &#125; .left&#123; background: pink ; width: 200px; margin-left: -100% &#125; .right&#123; background: blue ; width: 200px; margin-right: -200px &#125; &lt;/style&gt;四、position&lt;style type="text/css"&gt; *&#123; margin: 0; padding: 0; color: black; font-size: 45px &#125; .main div&#123; box-sizing: border-box; &#125; .main&#123; width: 100%; background: red; position: relative; padding-left: 200px; padding-right: 200px; &#125; .center&#123; width: 100%; background: pink &#125; .left&#123; background: yellow ; width: 200px; position: absolute; left: 0; top: 0; &#125; .right&#123; background: blue ; width: 200px; position: absolute; top: 0; right:0 &#125;&lt;/style&gt;&lt;div class="main"&gt; &lt;div class="center"&gt;z中间&lt;/div&gt; &lt;div class="left"&gt;左&lt;/div&gt; &lt;div class="right"&gt;右&lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx基本知识]]></title>
    <url>%2Fpost%2Fb48e920a.html</url>
    <content type="text"><![CDATA[什么是nginxnginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写。 正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。 不管是正向代理还是反向代理，实现的都是上面的功能。 正向代理正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。### 基本配置配置结构下面是一个nginx配置文件的基本结构： 123456789101112131415161718192021222324events &#123; &#125;http &#123; server &#123; location path &#123; ... &#125; location path &#123; ... &#125; &#125; server &#123; ... &#125;&#125; main: nginx的全局配置，对全局生效。 events: 配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 内置变量 下面是nginx一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。 变量名 功能 $host 请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名 $request_method 客户端请求类型，如GET、POST $remote_addr 客户端的IP地址 $args 请求中的参数 $content_length 请求头中的Content-length字段 $http_user_agent 客户端agent信息 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如HTTP/1.0、·HTTP/1.1` $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 解决跨域 前端server的域名为：fe.server.com 后端服务的域名为：dev.server.com 现在我在fe.server.com对dev.server.com发起请求一定会出现跨域。 现在我们只需要启动一个nginx服务器，将server_name设置为fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置： 1234567891011server &#123; listen 80; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125; location /douban &#123; rewrite ^/douban/(.*)$ /$1 break; proxy_pass https://api.douban.com; &#125;&#125; 这样可以完美绕过浏览器的同源策略：fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。 ###f 请求过滤根据状态码过滤 12345error_page 500 501 502 503 504 506 /50x.html;location = /50x.html &#123; #将跟路径改编为存放html的路径。 root /root/static/html;&#125; 根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。 123location / &#123; rewrite ^.*$ /index.html redirect;&#125; 根据请求类型过滤。 123if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 403; &#125; 负载均衡什么是负载均衡 负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。 nginx如何实现负载均衡 Upstream指定后端服务器地址列表 12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。 1234567server &#123; server_name fe.server.com; listen 80; location /api &#123; proxy_pass http://balanceServer; &#125;&#125; 上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。 nginx实现负载均衡的策略 轮询策略 默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。 12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最小连接数策略 将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。 upstream balanceServer { least_conn; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;} 最快响应时间策略 依赖于NGINX Plus，优先分配给响应时间最短的服务器。 upstream balanceServer { fair; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;} 客户端ip绑定 来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题。123456upstream balanceServer &#123; ip_hash; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 静态资源服务器123456location ~* \.(png|gif|jpg|jpeg)$ &#123; root /root/static/; autoindex on; access_log off; expires 10h;# 设置过期时间为10小时 &#125; 匹配以png|gif|jpg|jpeg为结尾的请求，并将请求转发到本地路径，root中指定的路径即nginx本地路径。同时也可以进行一些缓存的设置。 控制浏览器的缓存 浏览器缓存简介 浏览器缓存遵循HTTP协议定义的缓存机制（如：Expires;Cache-control等）。 当浏览器请求响应流程 浏览器缓存效验机制 校验是否过期 Cache-Control(max-age) Expires 协议中Etag头信息校验 Etag Last-Modified头信息校验 Last-Modified Nginx控制浏览器缓存配置 Nginx通过添加Cache-Control(max-age)、Expires头信息的方式控制浏览器缓存。 “Expires”头信息中的过期时间为当前系统时间与您设定的 time 值时间的和。如果指定了 modified 参数，则过期时间为文件的最后修改时间与您设定的 time 值时间的和。“Cache-Control”头信息的内容取决于指定 time 的符号。可以在time值中使用正数或负数。当 time 为负数，“Cache-Control: no-cache”;当 time 为正数或0，“Cache-Control: max-age=time”，单位是秒。 epoch 参数用于指定“Expires”的值为 1 January, 1970, 00:00:01 GMT。max 参数用于指定“Expires”的值为 “Thu, 31 Dec 2037 23:55:55 GMT”，“Cache-Control” 的值为10 年。off 参数令对“Expires” 和 “Cache-Control”响应头信息的添加或修改失效。 应用实例 (编辑nginx的配置文件) 12345671. server &#123; location ~ .*\.(jpg|xml|html|png|css|js|jpg)$ &#123; # 设置过期时间为12小时 expires 12h; root /vagrant/doc; &#125;&#125; nginx -s reload 重新载入nginx配置文件 创建 /var/www/html/1.jpg 通过curl访问 192.168.233.130/1.jpg，查看http响应头信息 二、防盗链 目的：防止资源被盗用,静态资源在外部服务请求 基于http_refer防盗链配置模块 ngx_http_referer_module none：请求头中没有 Referer 字段blocked：请求头中虽然存在“Referer”字段，但是它的值已经被防火墙或代理服务器删除；这些值是不以“http://”或“https://”开头的字符串;server_names：“Referer”请求头字段包含该服务器名称任意字符串：定义一个服务器名称和一个可选的URI前缀。服务器名开始或结尾可以有 “*” 。检查时，“Referer”字段中的服务器端口会被忽略。正则表达式：字符串必须以 ~ 开头，值得注意的是，正则表达式匹配的是在“http://”或“https://”之后的内容。 应用实例 12345678910server &#123; location ~* \.(gif|jpg|png|bmp)$ &#123; valid_referers none blocked *.xxx.com server_names ~\.google\. ~\.baidu\.; if ($invalid_referer) &#123; return 403; #rewrite ^/ http://www.xxx.com/403.jpg; &#125; &#125;&#125; 配置说明：以上所有来至xxx.com和域名中包含google和baidu的站点都可以访问到当前站点的图片如果来源域名不在这个列表中，那么$invalid_referer等于1，在if语句中返回一个403给用户，这样用户便会看到一个403的页面；如果使用下面的rewrite，那么盗链的图片都会显示403.jpg；如果用户直接在浏览器输入你的图片地址,那么图片显示正常，因为它符合none这个规则. 第一行：表示对gif|jpg|png|bmp后缀的文件实行防盗链第二行：表示对.xxx.com和xxx.com这2个来路进行判断(代表任何，任何的二级域名)，可以添加更多if{}里面内容的意思是，如果来路不是指定来路就跳转到403错误页面，当然直接返回404也是可以的，也可以是图片。 第四行：rewrite ^/ http://www.xxx.com/404.jpg;这个图片是盗链返回的图片，也就是替换盗链网站所有盗链的图片。这个图片要放在没有设置防盗链的网站上，因为防盗链的作用，这个图片如果也放在防盗链网站上就会被当作防盗链显示不出来了，盗链者的网站所盗链图片会显示X符号。 nginx -s reload 重新载入nginx配置文件 测试 使用浏览器直接访问可以 通过别的服务器请求访问返回403 如果打开rewirte 会自动跳转到404.jpg 去掉 none blocked 则图片地址也不能使用浏览器直接访问 参考： 原文地址]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常用css效果]]></title>
    <url>%2Fpost%2F695bddcf.html</url>
    <content type="text"><![CDATA[Sticky Footer什么是 “Sticky Footer”所谓 “Sticky Footer”，它指的就是一种网页效果： 如果页面内容不足够长时，页脚固定在浏览器窗口的底部；如果内容足够长时，页脚固定在页面的最底部。但如果网页内容不够长，置底的页脚就会保持在浏览器窗口底部。 实现方法 将内容部分的底部外边距设为负数这是个比较主流的用法，把内容部分最小高度设为100%，再利用内容部分的负底部外边距值来达到当高度不满时，页脚保持在窗口底部，当高度超出则随之推出的效果。 这个方法需要容器里有额外的占位元素（如 .push） 需要注意的是 .wrapper的margin-bottom值需要和 .footer的负的height值保持一致，这一点不太友好。 将页脚的顶部外边距设为负数既然能在容器上使用负的margin bottom，那能否使用负margin top吗？当然可以。 给内容外增加父元素，并让内容部分的底部内边距与页脚高度的值相等。 不过这种方法和上一种一样，都需要额外添加不必要的html元素。 使用flexbox弹性盒布局 以上两种种方法的footer高度都是固定的，通常来说这不利于网页布局：内容会改变，它们都是弹性的，一旦内容超出固定高度就会破坏布局。所以给footer使用flexbox吧，让它的高度可以变大变小 你还可以在上面添加header或在下面添加更多元素。可从以下技巧选择其一： flex:1 使内容（如： .content）高度可以自由伸缩 margin-top:auto absolute 通过绝对定位处理应该是常见的方案，只要使得页脚一直定位在主容器预留占位位置 这个方案需指定 html、body 100% 的高度，且 content 的 padding-bottom 需要与 footer 的 height 一致。 calc通过计算函数 calc 计算（视窗高度 - 页脚高度）赋予内容区最小高度，不需要任何额外样式处理，代码量最少、最简单。 table通过 table 属性使得页面以表格的形态呈现。 需要注意的是，使用 table 方案存在一个比较常见的样式限制，通常 margin、padding、border 等属性会不符合预期。 笔者不建议使用这个方案。当然，问题也是可以解决的：别把其他样式写在 table 上。 使用Grid网格布局grid比flexbox还要新很多，并且更佳很简洁 遗憾的是，网格布局（Grid layout）目前仅支持Chrome Canary和Firefox Developer Edition版本。 移动端Html5页面中1px边框问题移动端1px变粗的原因 为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解:这2个’px’ 的含义是不一样的.css中设置的像素并不是跟设备的像素点一一对应，这就是说，我在css中写明1px，实际在手机上，看到的有可能并不是一个像素点占据的宽度.css的像素是一个抽象的相对的概念，在不同的设备和环境中，所表示的物理像素点是不一样的，在比较老的设备上，屏幕像素密度比较低，这样，确实一个1px的像素就是一个物理像素，但是技术飞速发展，现在的手机屏幕都是高分辨率，在尺寸未变化的情况下，一个屏幕上将充满着更多的像素点，这时一个css的像素(通常称为逻辑像素)将对应多个物理像素点。那到底一个css的像素宽度上对应多少个物理像素点呢？这就要提到devicePixelRatio（设备像素比）devicePixelRatio = 设备上物理像素/独立像素，可以通过window.devicePixelRatio获取，这个像素比恰好可以描述一个css的像素宽度上对应多少个物理像素点，其实就是对应devicePixelRatio个像素点。当viewport的属性initial-scale为1时，页面大小正常，但initial-scale为0.5时，页面被缩小了1倍，devicePixelRatio为2的设备本来1个CSS像素宽度占2个物理像素宽度，缩小后的1个CSS像素宽度就只占1个物理像素，即实现了真正的1物理像素。 解决方法一：伪类+transform把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。 1234&lt;ul class="hairlines"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526272829* &#123; margin: 0; padding: 0;&#125;ul, li&#123; list-style: none;&#125;.hairlines &#123; width: 300px; margin: 100px auto;&#125;.hairlines li&#123; position: relative; border:none; margin-top: 10px;&#125;.hairlines li:after&#123; content: ''; position: absolute; left: 0; bottom: 0; background: #cccccc; width: 100%; height: 1px; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125; 几个问题： 1.为什么是scaleY(0.5)？这个0.5是怎么得出的？是不是所有机型都是要scale缩小到一半，换句话说是不是通用？ 2.如果我要同时画一个容器的四个边框怎么办？ 3.支不支持圆角边框？ 后两个问题改造一下上面的代码，可以找到解决方法(为了方便查看效果，我把平时写法得出的效果和使用伪类得出的效果放一起，这样更容易看出差别)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, width=device-width"&gt; &lt;title&gt;移动端1px边框问题&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, li&#123; list-style: none; &#125; .lines &#123; width: 200px; margin: 0 auto; &#125; .lines li &#123; border: 1px solid #cccccc; height: 50px; line-height: 50px; text-align: center; border-radius: 13px; margin-top: 10px; &#125; .hairlines &#123; width: 200px; margin: 0 auto; border-radius: 3px; &#125; .hairlines li&#123; height: 50px; line-height: 50px; border:none; text-align: center; position: relative; margin-top: 10px; &#125; .hairlines li:after&#123; content: ''; position: absolute; left: 0; top: 0; border: 1px solid #cccccc; border-radius: 26px; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;粗线&lt;ul class="lines"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;细线&lt;ul class="hairlines"&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 那么“1.为什么是scaleY(0.5)？这个0.5是怎么得出的？是不是所有机型都是要scale缩小到一半，换句话说是不是通用？”这个问题该怎么回答呢？ 当viewport的属性initial-scale为1时，页面大小正常，但initial-scale为0.5时，页面被缩小了1倍，devicePixelRatio为2的设备本来1个CSS像素宽度占2个物理像素宽度，缩小后的1个CSS像素宽度就只占1个物理像素，即实现了真正的1物理像素。 解决方法二：rem + viewport 说到这里，解决方法就很明了了：我们可以在运行的时候拿到设备的devicePixelRatio，动态改变viewport的initial-scale为 1/devicePixelRatio，这样就能保证1px的宽度就是真正的1物理像素宽。其他适配使用rem（因为使用px的话都会被缩小） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!--&lt;meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, width=device-width"&gt;--&gt; &lt;title&gt;移动端1px边框问题&lt;/title&gt; &lt;script&gt; (function () &#123; var clientWidth = window.screen.width; var dpr = window.devicePixelRatio; var vp = document.createElement('meta'); document.documentElement.style.fontSize = clientWidth &gt; 414 ? '20px' : 20 * dpr * clientWidth / 360 + 'px'; vp.name = 'viewport'; vp.content = `initial-scale=$&#123;1.0 * 1 / dpr&#125;, maximum-scale=$&#123;1.0 * 1 / dpr&#125;, minimum-scale=$&#123;1.0 * 1 / dpr&#125;, user-scalable=no, width=device-width`; var m = document.getElementsByTagName('meta')[0]; m.parentNode.insertBefore(vp, m); &#125;)(); &lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, li&#123; list-style: none; &#125; .lines &#123; width: 10rem; margin: 0 auto; &#125; .lines li &#123; border: 1px solid #cccccc; height: 2.5rem; line-height: 2.5rem; text-align: center; border-radius: 0.6rem; margin-top: 0.5rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="lines"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 从上来看，回到之前的问题，”1.为什么是scaleY(0.5)？这个0.5是怎么得出的？是不是所有机型都是要scale缩小到一半，换句话说是不是通用？”其实并不一定是0.5,在dpr为3的设备上其实应该是0.3333……，也不通用，因为每个手机的dpr可能不一样。 解决方法三flexible.js 这是淘宝移动端采取的方案, github的地址:https://github.com/amfe/lib-flexible. 前面已经说过1px变粗的原因就在于一刀切的设置 viewport 宽度, 如果能把 viewport 宽度设置为实际的设备物理宽度, css 里的 1px 不就等于实际 1px 长了么. flexible.js 就是这样干的. 里面的 scale 值指的是对 ideal viewport 的缩放, flexible.js 检测到 IOS 机型, 会算出 scale = 1/devicePixelRatio, 然后设置viewport 123metaEl = doc.createElement('meta');metaEl.setAttribute('name', 'viewport');metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); devicePixelRatio=2时输出meta如下, 这样viewport与ideal viewport的比是0.5, 也就与设备物理像素一致1&lt;meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"&gt; 另外html元素上的font-size会被设置为屏幕宽的1/10, 这样css可以以rem为基础长度单位进行改写, 比如rem是28px, 原先的7px就是0.25rem. border的宽度能直接写1px. 123456789function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) &#123; //大于540px可以不认为是手机屏 width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125; px和rem相互转换的计算方法会暴露在window.lib.flexible中. 这样可以为less/sass编写宏方法.具体的css改写方法参照大漠的文章http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html项目中特别指出了为了防止字体模糊, 出现奇数字号的字体, 字体的实际单位还是要以px为单位.缺点: 不适用安卓, flexible内部做了检测 非iOS机型还是采用传统的scale=1.0, 原因在于安卓手机不一定有devicePixelRatio属性, 就算有也不一定能响应scale小于1的viewport缩放设置, 例如我的手机设置了scale=0.33333333, 显示的结果也与scale=1无异. 综合使用对于IOS, flexible.js处理的已经很好了, 对于Android,方法2,3,4结合起来大体可以满足要求. flexible.js虽然不适用于安卓, 但它里面的这一段代码可以用来做对安卓机的部署. 12345678910111213141516171819if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr;&#125; 这里对安卓做检测, 如果是安卓, js动态加载css12345var link = document.createElement('link');link.setAttribute("rel","stylesheet");link.setAttribute("type","text/css");link.setAttribute("href",".......Android.css");document.querySelector('head').appendChild(link); 禁止 iOS 自动识别电话和 Android 自动识别邮箱123&lt;meta name="format-detection" content="telephone=no"/&gt; &lt;meta name="format-detection" content=“email=no"/&gt; 禁止文本选择1-webkit-user-select:none 屏蔽输入框阴影，去掉按钮默认样式1-webkit-appearance:none css3 多行文本换行12345overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; //显示的行数 -webkit-box-orient: vertical; iOS 快速回弹在 iOS 上如果想让一个元素拥有像 Native 的滚动效果，可以这样写12overflow-y: scroll; -webkit-overflow-scrolling: touch; 禁止a标签点击高亮12345html,body&#123; -webkit-touch-callout: none; //禁止或显示系统默认菜单 -webkit-user-select: none; //禁止长按复制选择 -webkit-tap-highlight-color: rgba(0,0,0,0);//禁止触摸a标签高亮 这个特别实用 &#125; meta标签1234567891011121314151617181920212223242526272829303132&lt;!-- 设置缩放 --&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" /&gt; &lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; &lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt; &lt;meta name="format-detection"content="telephone=no, email=no" /&gt; 其他meta标签 &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name="HandheldFriendly" content="true"&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name="MobileOptimized" content="320"&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name="screen-orientation" content="portrait"&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name="x5-orientation" content="portrait"&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name="full-screen" content="yes"&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name="x5-fullscreen" content="true"&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name="browsermode" content="application"&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name="x5-page-mode" content="app"&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name="msapplication-tap-highlight" content="no"&gt; 常用12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;!-- ios7.0版本以后，safari上已看不到效果,可以删除--&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;viewport通用&lt;/title&gt; &lt;script type="text/javascript"&gt; var phoneWidth = parseInt(window.screen.width); var phoneScale = phoneWidth / 750; var ua = navigator.userAgent; if (/Android (\d+\.\d+)/.test(ua)) &#123; var version = parseFloat(RegExp.$1); if (version &gt; 2.3) &#123; document.write('&lt;meta name="viewport" id="vie" content="width=750, minimum-scale = ' + phoneScale + ', maximum-scale = ' + phoneScale + ', target-densitydpi=device-dpi"&gt;'); &#125; else &#123; document.write('&lt;meta name="viewport" id="vie" content="width=750, target-densitydpi=device-dpi"&gt;'); &#125; &#125; else &#123; document.write('&lt;meta id="vie" name="viewport" content="width=750, user-scalable=no, target-densitydpi=device-dpi, minimal-ui"&gt;'); &#125; &lt;/script&gt; &lt;link style="text/css" rel="stylesheet" href="home.css"&gt; &lt;script type="text/javascript" src="js/app.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--页面内容--&gt;&lt;/body&gt;&lt;/html&gt; device-width：设备宽度 width：设置viewport宽度，为一个正整数，或字符串‘device-width’ height：设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 initial-scale：默认缩放比例(初始缩放比例)，为一个数字，可以带小数 minimum-scale：允许用户最小缩放比例，为一个数字，可以带小数 maximum-scale：允许用户最大缩放比例，为一个数字，可以带小数 user-scalable：是否允许手动缩放 移动端click事件有300 ms的延迟响应问题2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： astclick可以解决在手机上点击事件的300ms延迟，地址：https://github.com/ftlabs/fastclick zepto的touch模块，tap事件也是为了解决在click的延迟问题 CSS美化Placeholder提示信息的样式兼容12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125; 手机对Placeholder提示信息都基本带有默认的样式，兼容各种浏览器的使用方式：1234.css::-webkit-input-placeholder &#123;color: #777;&#125; /* WebKit browsers */.css:-moz-placeholder &#123;color: #777;opacity: 1;&#125; /* Mozilla Firefox 4 to 18 */.css::-moz-placeholder &#123;color: #777;opacity: 1;&#125; /* Mozilla Firefox 19+ */.css:-ms-input-placeholder &#123;color: #777;&#125; /* Internet Explorer 10+ */ 移动端实现类似hover效果移动端实现类似hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活移动端css的active效果。 直接在body上添加ontouchstart，同样可激活移动端css的active效果，比较推荐这种方式，代码如下： html代码：123&lt;body ontouchstart&gt;&lt;/body&gt;.btn:active&#123;background-color: red;&#125; 开启硬件加速123456.css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; CSS动画的性能分析和浏览器GPU加速 android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125; 取消input在ios下，输入的时候英文首字母的默认大写1&lt;input autocapitalize="off" autocorrect="off" /&gt; CSS判断横屏竖屏123456789//竖屏时使用的样式@media screen and (orientation:portrait) &#123; .css&#123;&#125;&#125;//横屏时使用的样式@media screen and (orientation:landscape) &#123; .css&#123;&#125;&#125; 分开写在2个CSS中：12&lt;link rel="stylesheet" media="all and (orientation:portrait)" href="portrait.css"&gt;&lt;link rel="stylesheet" media="all and (orientation:landscape)" href="landscape.css"&gt; CSS3判断屏幕横屏123@media screen and (min-aspect-ratio: 13/8) &#123; &#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this、call、apply和bind]]></title>
    <url>%2Fpost%2F4b3c211f.html</url>
    <content type="text"><![CDATA[理解 JavaScript 中的 this、call、apply 和 bindJavaScript 中最容易被误解的一点就是 this 关键字。在这篇文章中，你将会了解四种规则，弄清楚 this 关键字指的是什么。隐式绑定、显式绑定、new 绑定和 window 绑定。在介绍这些技术时，你还将学习一些 JavaScript 其他令人困惑的部分，例如 .call、.apply、.bind和 new 关键字。 在深入了解 JavaScript 中的 this 关键字之前，有必要先退一步，看一下为什么 this 关键字很重要。this 允许复用函数时使用不同的上下文。换句话说，“this” 关键字允许在调用函数或方法时决定哪个对象应该是焦点。 之后讨论的所有东西都是基于这个理念。我们希望能够在不同的上下文或在不同的对象中复用函数或方法。 我们要关注的第一件事是如何判断 this 关键字的引用。当你试图回答这个问题时，你需要问自己的第一个也是最重要的问题是“这个函数在哪里被调用？”。判断 this 引用什么的 唯一 方法就是看使用 this 关键字的这个方法在哪里被调用的。 用一个你已经十分熟悉的例子来展示这一点，比如我们有一个 greet 方法，它接受一个名字参数并显示有欢迎消息的警告框。 123function greet(name) &#123; alert(`my name is $&#123;name&#125;`);&#125; 如果我问你 greet 会具体警告什么内容，你会怎样回答？只给出函数定义是不可能知道答案的。为了知道 name 是什么，你必须看看 greet 函数的调用过程。1greet('Tyler') 判断 this 关键字引用什么也是同样的道理，你甚至可以把 this 当成一个普通的函数参数对待 — 它会随着函数调用方式的变化而变化。 现在我们知道为了判断 this 的引用必须先看函数的定义，在实际地查看函数定义时，我们设立了四条规则来查找引用，它们是: 隐式绑定 显式绑定 new 绑定 window 绑定 隐式绑定请记住，这里的目标是查看使用 this 关键字的函数定义，并判断 this 的指向。执行绑定的第一个也是最常见的规则称为 隐式绑定。80% 的情况下它会告诉你 this 关键字引用的是什么。 假如我们有一个这样的对象1234567const user = &#123; name: 'Tyler', age: 27, greet() &#123; alert(`Hello, my name is $&#123;this.name&#125;`) &#125;&#125; 现在，如果你要调用 user 对象上的 greet 方法，你会用到点号。1user.greet() 这就把我们带到隐式绑定规则的主要关键点。为了判断 this 关键字的引用，函数被调用时先看一看点号左侧。如果有“点”就查看点左侧的对象，这个对象就是 this 的引用。 在上面的例子中，user 在“点号左侧”意味着 this 引用了 user 对象。所以就好像 在 greet 方法的内部 JavaScript 解释器把 this 变成了 user。1234greet() &#123; // alert(`Hello, my name is $&#123;this.name&#125;`) alert(`Hello, my name is $&#123;user.name&#125;`) // Tyler&#125; 我们来看一个类似但稍微高级点的例子。现在，我们的对象不仅要拥有 name、age 和 greet 属性，还要被添加一个 mother 属性，并且此属性也拥有 name 和 greet 属性。 12345678910111213const user = &#123; name: 'Tyler', age: 27, greet() &#123; alert(`Hello, my name is $&#123;this.name&#125;`) &#125;, mother: &#123; name: 'Stacey', greet() &#123; alert(`Hello, my name is $&#123;this.name&#125;`) &#125; &#125;&#125; 现在问题变成下面的每个函数调用会警告什么？ 12user.greet()user.mother.greet() 每当判断 this 的引用时，我们都需要查看调用过程，并确认“点的左侧”是什么。第一个调用，user 在点左侧意味着 this 将引用 user。第二次调用中，mother 在点的左侧意味着 this 引用 mother 12user.greet() // Tyleruser.mother.greet() // Stacey 如前所述，大约有 80% 的情况下在“点的左侧”都会有一个对象。这就是为什么在判断 this 指向时“查看点的左侧”是你要做的第一件事。但是，如果没有点呢？这就为我们引出了下一条规则 — 显式绑定如果 greet 函数不是 user 对象的函数，只是一个独立的函数。12345678function greet () &#123; alert(`Hello, my name is $&#123;this.name&#125;`)&#125;const user = &#123; name: 'Tyler', age: 27,&#125; 我们知道为了判断 this 的引用我们首先必须查看这个函数的调用位置。现在就引出了一个问题，我们怎样能让 greet 方法调用的时候将 this 指向 user 对象？。我们不能再像之前那样简单的使用 user.greet()，因为 user 并没有 greet 方法。在 JavaScript 中，每个函数都包含了一个能让你恰好解决这个问题的方法，这个方法的名字叫做 call。 1“call” 是每个函数都有的一个方法，它允许你在调用函数时为函数指定上下文。 考虑到这一点，用下面的代码可以在调用 greet 时用 user 做上下文。 1greet.call(user) 再强调一遍，call 是每个函数都有的一个属性，并且传递给它的第一个参数会作为函数被调用时的上下文。换句话说，this 将会指向传递给 call 的第一个参数。 这就是第 2 条规则的基础（显示绑定），因为我们明确地（使用 .call）指定了 this 的引用。 现在让我们对 greet 方法做一点小小的改动。假如我们想传一些参数呢？不仅提示他们的名字，还要提示他们知道的语言。就像下面这样 123function greet (lang1, lang2, lang3) &#123; alert(`Hello, my name is $&#123;this.name&#125; and I know $&#123;lang1&#125;, $&#123;lang2&#125;, and $&#123;lang3&#125;`)&#125; 现在为了将这些参数传递给使用 .call 调用的函数，你需要在指定上下文（第一个参数）后一个一个地传入。 12345678910function greet (lang1, lang2, lang3) &#123; alert(`Hello, my name is $&#123;this.name&#125; and I know $&#123;lang1&#125;, $&#123;lang2&#125;, and $&#123;lang3&#125;`)&#125;const user = &#123; name: 'Tyler', age: 27,&#125;const languages = ['JavaScript', 'Ruby', 'Python']greet.call(user, languages[0], languages[1], languages[2]) 方法奏效，它显示了如何将参数传递给使用 .call 调用的函数。不过你可能注意到，必须一个一个传递 languages 数组的元素，这样有些恼人。如果我们可以把整个数组作为第二个参数并让 JavaScript 为我们自动展开就好了。有个好消息，这就是 .apply 干的事情。.apply 和 .call 本质相同，但不是一个一个传递参数，你可以用数组传参而且 .apply 会在函数中为你自动展开。 那么现在用 .apply，我们的代码可以改为下面这个，其他一切都保持不变。 1234const languages = ['JavaScript', 'Ruby', 'Python']// greet.call(user, languages[0], languages[1], languages[2])greet.apply(user, languages) 到目前为止，我们学习了关于 .call 和 .apply 的“显式绑定”规则，用此规则调用的方法可以让你指定 this 在方法内的指向。关于这个规则的最后一个部分是 .bind。.bind 和 .call 完全相同，除了不会立刻调用函数，而是返回一个能以后调用的新函数。因此，如果我们看看之前所写的代码，换用 .bind，它看起来就像这样 12345678910111213function greet (lang1, lang2, lang3) &#123; alert(`Hello, my name is $&#123;this.name&#125; and I know $&#123;lang1&#125;, $&#123;lang2&#125;, and $&#123;lang3&#125;`)&#125;const user = &#123; name: 'Tyler', age: 27,&#125;const languages = ['JavaScript', 'Ruby', 'Python']const newFn = greet.bind(user, languages[0], languages[1], languages[2])newFn() // alerts "Hello, my name is Tyler and I know JavaScript, Ruby, and Python" new 绑定第三条判断 this 引用的规则是 new 绑定。若你不熟悉 JavaScript 中的 new 关键字，其实每当用 new 调用函数时，JavaScript 解释器都会在底层创建一个全新的对象并把这个对象当做 this。如果用 new 调用一个函数，this 会自然地引用解释器创建的新对象。 1234567891011function User (name, age) &#123; /* JavaScript 会在底层创建一个新对象 `this`，它会代理不在 User 原型链上的属性。 如果一个函数用 new 关键字调用，this 就会指向解释器创建的新对象。 */ this.name = name this.age = age&#125;const me = new User('Tyler', 27) window 绑定假如我们有下面这段代码 12345678function sayAge () &#123; console.log(`My age is $&#123;this.age&#125;`)&#125;const user = &#123; name: 'Tyler', age: 27&#125; 如前所述，如果你想用 user 做上下文调用 sayAge，你可以使用 .call、.apply 或 .bind。但如果我们没有用这些方法，而是直接和平时一样直接调用 sayAge 会发生什么呢？ 1sayAge() // My age is undefined 不出意外，你会得到 My name is undefined，因为 this.age 是 undefined。事情开始变得神奇了。实际上这是因为点的左侧没有任何东西，我们也没有用 .call、.apply、.bind 或者 new 关键字，JavaScript 会默认 this 指向 window 对象。这意味着如果我们向 window 对象添加 age 属性并再次调用 sayAge 方法，this.age 将不再是 undefined 并且变成 window 对象的 age 属性值。不相信？让我们运行这段代码 12345window.age = 27function sayAge () &#123; console.log(`My age is $&#123;this.age&#125;`)&#125; 非常神奇，不是吗？这就是第 4 条规则为什么是 window 绑定 的原因。如果其它规则都没满足，JavaScript就会默认 this 指向 window 对象。 1在 ES5 添加的 严格模式 中，JavaScript 不会默认 this 指向 window 对象，而会正确地把 this 保持为 undefined。 123456789'use strict'window.age = 27function sayAge () &#123; console.log(`My age is $&#123;this.age&#125;`)&#125;sayAge() // TypeError: Cannot read property 'age' of undefined 因此，将所有规则付诸实践，每当我在函数内部看到 this 关键字时，这些就是我为了判断它的引用而采取的步骤。 查看函数在哪被调用。 点左侧有没有对象？如果有，它就是 “this” 的引用。如果没有，继续第 3 步。 该函数是不是用 “call”、“apply” 或者 “bind” 调用的？如果是，它会显式地指明 “this” 的引用。如果不是，继续第 4 步。 该函数是不是用 “new” 调用的？如果是，“this” 指向的就是 JavaScript 解释器新创建的对象。如果不是，继续第 5 步。 是否在“严格模式”下？如果是，“this” 就是 undefined，如果不是，继续第 6 步。 JavaScript 很奇怪，“this” 会指向 “window” 对象。 箭头函数在以往的函数中，this 有各种各样的指向(隐式绑定，显示绑定，new 绑定, window 绑定……)，虽然灵活方便，但由于不能在定义函数时而直到实际调用时才能知道 this 指向，很容易给开发者带来诸多困扰。 假如我们有下面这段代码（本文代码都是在浏览器下运行）， 12345678910function User() &#123; this.name = 'John'; setTimeout(function greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is console.log(this); // window &#125;, 1000);&#125;const user = new User(); 没有显示绑定、隐式绑定或 new 绑定、所以直接得出结论 this 指向 window。如果我们想把 this 指向 user 对象！ 以前是怎么解决的呢？看下面的代码： 使用闭包1234567891011function User() &#123; const self = this; this.name = 'John'; setTimeout(function greet() &#123; console.log(`Hello, my name is $&#123;self.name&#125;`); // Hello, my name is John console.log(self); // User &#123;name: "John"&#125; &#125;, 1000);&#125;const user = new User(); 使用显示绑定 — bind12345678910function User() &#123; this.name = 'John'; setTimeout(function greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is John console.log(this); // User &#123;name: "John"&#125; &#125;.bind(this)(), 1000);&#125;const user = new User(); 利用 setTimeout 的可以传更多参数的特性其实第三种和第一种比较像，都用到了闭包。 12345678910function User() &#123; this.name = 'John'; setTimeout(function greet(self) &#123; console.log(`Hello, my name is $&#123;self.name&#125;`); // Hello, my name is John console.log(self); // User &#123;name: "John"&#125; &#125;, 1000, this);&#125;const user = new User(); 三种方法都可以解决问题，但是都要额外写冗余的代码来指定 this。 现在，箭头函数（Arrow Function）正是 ES6 引入来解决这个问题的，它可以轻松地让 greet 函数保持 this 指向 user 对象。 箭头函数如何解决下面是箭头函数版本： 12345678910function User() &#123; this.name = 'John'; setTimeout(() =&gt; &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is John console.log(this); // User &#123;name: "John"&#125; &#125;, 1000);&#125;const user = new User(); 完美，直接把普通函数改成箭头函数就能解决问题。 箭头函数在自己的作用域内不绑定 this，即没有自己的 this，如果要使用 this ，就会指向定义时所在的作用域的 this 值。在上面的代码中即指向 User 函数的 this，而 User 函数通过 new 绑定，所以 this 实际指向 user 对象。 如果上述代码在严格模式下运行会有影响吗？ 1234567891011function User() &#123; this.name = 'John'; setTimeout(() =&gt; &#123; 'use strict' console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is John console.log(this); // User &#123;name: "John"&#125; &#125;, 1000);&#125;const user = new User(); 答案是没有影响。因为箭头函数没有自己的 this，它的 this 来自于 User 的 this，只要 User 的 this 不变，箭头函数的 this 也保持不变。 那么使用 bind，call 或者 apply 呢？12345678910function User() &#123; this.name = 'John'; setTimeout((() =&gt; &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is John console.log(this); // User &#123;name: "John"&#125; &#125;).bind('no body'), 1000);&#125;const user = new User(); 答案还是没有影响。因为箭头函数没有自己的 this，使用 bind，call 或者 apply 时，箭头函数会自动忽略掉 bind 的第一个参数，即 thisArg。 箭头函数在自己的作用域内没有自己的 this，如果要使用 this ，就会指向定义时所在的作用域的 this 值。 原文：https://juejin.im/post/5b9f176b6fb9a05d3827d03f]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript内存管理以及内存泄漏]]></title>
    <url>%2Fpost%2F24cc7cf9.html</url>
    <content type="text"><![CDATA[概述语言，比如C，具有低层次的内存管理方法，比如malloc()以及free()。开发者利用这些方法精确地为操作系统分配以及释放内存。 同时，JavaScript会在创建一些变量（对象，字符串等等）的时候分配内存，并且会在这些不被使用之后“自动地”释放这些内存，这个过程被称为垃圾收集。这个看起来“自动化的”特性其实就是产生误解的原因，并且给JavaScript（以及其他高层次语言）开发者一个假象，他们不需要关心内存管理。大错特错。 即使是使用高层次语言，开发者应该对于内存管理有一定的理解（或者最基本的理解）。有时候自动的内存管理会存在一些问题（比如一些bug或者垃圾收集器的一些限制等等），对于这些开发者必须能够理解从而能够合适地处理（或者使用最小的代价以及代码债务去绕过这个问题）。 内存生命周期不管你在使用什么编程语言，内存的生命周期基本上都是一样的： 下面是对于周期中每一步所发生的情况的概述： 分配内存——操作系统为你的程序分配内存并且允许其使用。在低层次语言中（比如C），这正是开发者应该处理的操作。在高层次的语言，然而，就由语言帮你实现了。 使用内存——当你的程序确实在使用之前分配的内存的阶段。当你在使用你代码里面分配的变量的时候会发生读以及写操作。 释放内存——这个阶段就是释放你不再需要的内存，从而这些内存被释放并且能够再次被使用。和分配内存操作一样，这在低层次的语言也是开发者需要明确的操作。 什么是内存？在我们讲述JavaScript内存之前，我们将简要地讨论一下内存是什么以及它们是如何在 nutshell 中工作的。 在硬件层次上，计算机内存由大量的 寄存器 组成。每一个寄存器都包含一些晶体管并且能够存储一比特。单独的寄存器可以通过独特的标识符去访问，因此我们能够读取以及重写它们。因此，从概念上来说，我们可以认为我们的整个计算机内存就是一个我们能够读写的大型比特数组。 因为作为人类，我们不擅长直接基于比特进行思考以及算术，我们将它们组织成大规模群组，它们在一起可以代表一个数字。8个比特称为一个字节。除了字节，还有词（有时候是16比特，有时候是32比特）。 内存中存储了很多东西： 1.所有程序使用的变量和其他数据 2.程序的代码，包括操作系统的代码。 编译器和操作系统共同合作为你处理大部分的内存管理，但是我们建议你应该了解其内部的运行原理。 当你编译你的代码的时候，编译器将会检查原始数据类型并且提前计算好它们需要多少内存。需要的内存被分配给程序，这被称为栈空间。这些被分配给变量的空间被称为栈空间，因为一旦函数被调用，它们的内存就会增加到现有内存的上面。当它们终止的时候，它们就会以后进先出(LIFO)的顺序移除。比如，考虑下面的声明。 123int n; // 4 bytesint x[4]; // array of 4 elements, each 4 bytesdouble m; // 8 bytes 编译器能够立即计算出代码需要 4 + 4 × 4 + 8 = 28 字节 那就是它如何对于现有的整形以及双浮点型工作。大约20年前，整形典型都是2个字节，双浮点型是4个字节。你的代码不应该取决于当下基本数据类型的大小。 编译器将会插入能够与操作系统交互的代码，从而在栈上获取你需要存储变量需要的字节数。 在上述的例子中，编译器知道每一个变量的准确的内存地址。事实上，无论我们何时写变量 n ，这都会在内部转化为类似于“内存地址 4127963”的东西。 注意如果我们希望在这访问 x[4] 我们将会需要访问和 m 相关联的数据。这是因为我们在访问数组里面并不存在的元素——它比数组实际分配的最后一个元素 x[3] 要多4个字节，并且最后可能是阅读（或者重写）一些 m 的比特。这将很可能给程序的其他部分带来一些不良的后果。 当函数调用其它函数的时候，当它被调用的时候都会获取它自己的堆栈块。它在那保存了它所有的局部变量，但是还会有一个程序计数器记录它执行的位置。当这个函数执行完毕，它的内存块就可以再次用于其他目的。 动态分配不幸的是，当我们在编译的时候不知道变量需要多少内存的话事情可能就不那么简单。假设我们想做下面的事情： 12345int n = readInput(); // reads input from the user...// create an array with &quot;n&quot; elements 在此，在编译阶段中，编译器就没有办法知道数组需要多少内存，因为它取决于用户的输入。 因此，它就不能够为栈上的变量分配空间。相反，我们的程序需要明确地询问操作运行时需要的空间数量。这个内存是从堆空间中分配出来的。动态内存和静态内存分配的区别总结如下表格： 为了深入地理解动态内存分配是如何工作的，我们需要花费更多的时间在指针。 JavaScript中的分配现在我们将解释JavaScript中的第一步（分配内存）。 JavaScript 将开发者从内存分配的处理中解放出来——JavaScript自身可以利用声明变量来完成这些任务。 12345678910111213141516171819var n = 374; // allocates memory for a numbervar s = 'sessionstack'; // allocates memory for a string var o = &#123; a: 1, b: null&#125;; // allocates memory for an object and its contained valuesvar a = [1, null, 'str']; // (like object) allocates memory for the // array and its contained valuesfunction f(a) &#123; return a + 3;&#125; // allocates a function (which is a callable object)// function expressions also allocate an objectsomeElement.addEventListener('click', function() &#123; someElement.style.backgroundColor = 'blue';&#125;, false); 一些函数调用也会导致一些对象的分配： 123var d = new Date(); // allocates a Date objectvar e = document.createElement('div'); // allocates a DOM element 能够分配新的值或者对象的方法： 1234567891011var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 is a new string// Since strings are immutable, // JavaScript may decide to not allocate memory, // but just store the [0, 3] range.var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2); // new array with 4 elements being// the concatenation of a1 and a2 elements 在JavaScript中使用内存基本上在JavaScript中分配内存，就意味着在其中读写。 这可以通过对一个变量或者一个对象的属性甚至是向函数传递一个参数来完成。 当内存不再需要的时候释放它大多数的内存管理的问题就来自于这个阶段。 最困难的任务就是如何知道何时被分配的不再需要了。它经常需要开发者决定在程序的什么地方某段内存不再需要了并且对其进行释放。 高层次语言内嵌了一个称为垃圾收集器的软件，他的任务就是跟踪内存分配并且用于需找不再需要的分配过的内存，并且自动地对其进行释放。 不幸的是，这个过程是一个近似，因为知道是否某块内存是需要的问题是不可决定的（无法通过算法解决） 大多数的垃圾收集器通过收集再也无法访问的内存工作，比如：指向它的所有变量都超出了作用域。然而，这依然是对于可以收集的内存空间的预估，因为在任何位置仍可能一些变量在作用域内指向这个内存，然而它再也不能被访问了。 垃圾收集器由于找到一些是“不再需要的”是不可决定的事实，垃圾收集实现了对一般问题的解决方案的限制。这一节将会解释理解主要的垃圾收集算法以及它们的限制的需要注意的事项。 内存引用垃圾收集算法依赖的主要概念之一就是引用。 在内存管理的上下文中，一个对象被称为是对于另外一个对象的引用，如果前者可以访问后者（隐含或明确的）。例如，一个JavaScript对象都有一个指向其原型的引用（隐含的引用） 在这个上下文中，“对象”的概念扩展到比普通的JavaScript对象要广并且包括函数作用域（或者全局词法作用域）。 词法作用域定义了变量名称是如何在嵌套函数中解析的：内部函数包含了父函数的作用域即使父函数已经返回了。 基于引用计数的垃圾收集器这是最简单的垃圾收集器算法。如果没有引用指向这个对象的时候，这个对象就被认为是“可以作为垃圾收集”。 请看如下代码： 1234567891011121314151617181920212223242526272829var o1 = &#123; o2: &#123; x: 1 &#125;&#125;;// 2 objects are created. // 'o2' is referenced by 'o1' object as one of its properties.// None can be garbage-collectedvar o3 = o1; // the 'o3' variable is the second thing that // has a reference to the object pointed by 'o1'. o1 = 1; // now, the object that was originally in 'o1' has a // single reference, embodied by the 'o3' variablevar o4 = o3.o2; // reference to 'o2' property of the object. // This object has now 2 references: one as // a property. // The other as the 'o4' variableo3 = '374'; // The object that was originally in 'o1' has now zero // references to it. // It can be garbage-collected. // However, what was its 'o2' property is still // referenced by the 'o4' variable, so it cannot be // freed.o4 = null; // what was the 'o2' property of the object originally in // 'o1' has zero references to it. // It can be garbage collected. 循环在产生问题当遇到循环的时候就会有一个限制。在下面的实例之中，创建两个对象，并且互相引用，因此就会产生一个循环。当函数调用结束之后它们会走出作用域之外，因此它们就没什么用并且可以被释放。但是，基于引用计数的算法认为这两个对象都会被至少引用一次，所以它俩都不会被垃圾收集器收集。 12345678function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 references o2 o2.p = o1; // o2 references o1. This creates a cycle.&#125;f(); 标记-清除算法为了决定哪个对象是需要的，算法会决定是否这个对象是可访问的。 这个算法由以下步骤组成： 这个垃圾收集器构建一个“roots”列表。Root是全局变量，被代码中的引用所保存。在 JavaScript中，“window”就是这样的作为root的全局变量的例子。 所有的root都会被监测并且被标志成活跃的（比如不是垃圾）。所有的子代也会递归地被监测。所有能够由root访问的一切都不会被认为是垃圾。 所有不再被标志成活跃的内存块都被认为是垃圾。这个收集器现在就可以释放这些内存并将它们返还给操作系统。 这个算法要优于之前的因为“一个具有0引用的对象”可以让一个对象不能够再被访问。但是相反的却不一定成立，比如我们遇到循环的时候。 在2012年，所有的现代浏览器都使用标记-清除垃圾收集器。过去几年，JavaScript垃圾收集（代数/增量/并行/并行垃圾收集）领域的所有改进都是对该算法（标记和扫描）的实现进行了改进，但并没有对垃圾收集算法本身的改进， 其目标是确定一个对象是否可达。 在这篇文章中，你可以得到更多关于垃圾收集追踪并且也覆盖到了关于标记-清除算法的优化。 循环不再是一个问题在上述的第一个例子中，在函数调用返回之后，这两个对象不能够被全局对象所访问。因此，垃圾收集器就会发现它们不能够被访问了。 即使在这两个对象之间存在着引用，它们再也不能从root访问了。 列举垃圾收集器的直观行为虽然垃圾收集器很方便，但它们自己也有自己的代价。 其中一个是非确定论。 换句话说，GC是不可预测的。 你不能真正地告诉你什么时候会收集。 这意味着在某些情况下，程序会使用实际需要的更多内存。 在其他情况下，特别敏感的应用程序可能会引起短暂暂停。 虽然非确定性意味着在执行集合时无法确定，但大多数GC实现共享在分配期间执行收集遍历的常见模式。 如果没有执行分配，大多数GC保持空闲状态。 考虑以下情况： 执行相当大的一组分配。 这些元素中的大多数（或全部）被标记为不可访问（假设我们将指向我们不再需要的缓存的引用置空）。 不再执行分配。 在这种情况下，大多数GC不会再运行收集处理。换句话说，即使存在对于收集器来说不可访问的引用，它们也不会被收集器所认领。严格意义来说这并不是泄露，但是依然会导致比平常更多的内存使用。 什么是内存泄露？实质上，内存泄漏可以被定义为应用程序不再需要的内存，但是由于某些原因不会返回到操作系统或可用内存池。 编程语言有支持管理内存的不同方法。 然而，某块内存是否被使用实际上是一个不可判定的问题。 换句话说，只有开发人员可以清楚一个内存是否可以返回到操作系统。 某些编程语言提供了帮助开发者执行此操作的功能。其他的则期望开发人员能够完全明确何时使用一块内存。 维基百科有关于手动和自动内存管理的好文章。 四种常见的JavaScript泄露全局变量JavaScript 使用一种有趣的方式处理未声明的变量：一个未声明变量的引用会在全局对象内部产生一个新的变量。在浏览器的情况，这个全局变量就会是window。换句话说： 123function foo(arg) &#123; bar = "some text";&#125; 等同于：123function foo(arg) &#123; window.bar = "some text";&#125; 如果bar被期望仅仅在foo函数作用域内保持对变量的引用，并且你忘记使用var去声明它，一个意想不到的全局变量就产生了。 在这个例子中，泄露就仅仅是一个字符串并不会带来太多危害，但是它可能会变得更糟。 另外一种可能产生意外的全局变量的方式是： 1234567function foo() &#123; this.var1 = "potential accidental global";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); 为了阻止这些错误的发生，可以在js文件头部添加’use strict’。这将会使用严格模式来解析 JavaScript 从而阻止意外的全局变量。了解更多关于JavaScript执行的模式。 即使我们讨论了未预期的全局变量，但仍然有很多代码用显式的全局变量填充。 这些定义是不可收集的（除非分配为null或重新分配）。 特别是，用于临时存储和处理大量信息的全局变量值得关注。如果你必须使用全局变量来存储大量数据，请确保在完成之后将其分配为null或重新分配。 被遗忘的计时器和回调setInterval 在 JavaScript 中是经常被使用的。 大多数提供观察者和其他模式的回调函数库都会在调用自己的实例变得无法访问之后对其任何引用也设置为不可访问。 但是在setInterval的情况下，这样的代码很常见： 1234567var serverData = loadData();setInterval(function() &#123; var renderer = document.getElementById('renderer'); if(renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); //This will be executed every ~5 seconds. 这个例子说明了计时器可能发生的情况：计时器可能会产生再也不被需要的节点或者数据的引用。 renderer所代表的对象在未来可能被移除，让部分interval 处理器中代码变得不再被需要。然而，这个处理器不能够被收集因为interval依然活跃的（这个interval需要被停止从而表面这种情况）。如果这个interval处理器不能够被收集，那么它的依赖也不能够被收集。这意味这存储大量数据的severData也不能够被收集。 在这种观察者的情况下，做出准确的调用从而在不需要它们的时候立即将其移除是非常重要的（或者相关的对象被置为不可访问的）。 过去，以前特别重要的是某些浏览器（好的老IE 6）无法管理好循环引用（有关更多信息，请参见下文）。 如今，大多数浏览器一旦观察到的对象变得无法访问，就能收集观察者处理器，即使侦听器没有被明确删除。 但是，在处理对象之前，明确删除这些观察者仍然是一个很好的做法。 例如： 1234567891011121314151617var element = document.getElementById('launch-button');var counter = 0;function onClick(event) &#123; counter++; element.innerHtml = 'text ' + counter;&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers // that don't handle cycles well. 当今，现在浏览器（报错IE和Edge）都使用了现代的垃圾收集算法，其能够检测到这些循环并且进行适宜的处理。换句话说，再也不是严格需要在将节点置为不可访问之前调用removeEventListener 。 框架和库（如jQuery）在处理节点之前（在为其使用特定的API时）会删除侦听器。 这是由库内部处理的，这也确保没有泄漏，即使在有问题的浏览器下运行，如…是的，IE 6。 闭包JavaScript 开发的一个关键方面是闭包：一个可以访问外部（封闭）函数变量的内部函数。 由于JavaScript运行时的实现细节，可以通过以下方式泄漏内存： 1234567891011121314151617 var theThing = null; var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) // a reference to 'originalThing' console.log("hi"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log("message"); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 这个代码段会做一件事情：每次 replaceThing 被调用时，theThing 都会获取一个一个包含一个大数组的以及一个新的闭包（someMethod）。同时，unused 会保持一个指向originalThing引用的闭包（从上一个调用的theThing到replaceThing）。可能已经很迷惑了，是不是？重要的事情是一旦在相同的父级作用域为闭包产生作用域，这个作用域就会被共享。 在这种情况下，为someMethod闭包产生的作用域就会被unused 所共享。unused 具有对于originaThing的引用。即使 unused 不再被使用，someMethod依然可以通过replaceThing作用域之外的theThing来使用。并且由于somethod和unused 共享闭包作用域，unused指向originalThing的引用强迫其保持活跃（两个闭包之间的整个共享作用域）。这将会阻止垃圾手机。 当这个代码段重复运行时，可以观察到内存使用量的稳定增长。 当GC运行时，这不会变小。 实质上，创建了一个关闭的链接列表（其root以TheThing变量的形式），并且这些闭包的范围中的每一个都对大数组进行间接引用，导致相当大的泄漏。 DOM 之外的引用有时将DOM节点存储在数据结构中可能是有用的。 假设要快速更新表中的几行内容。 存储对字典或数组中每个DOM行的引用可能是有意义的。 当发生这种情况时，会保留对同一DOM元素的两个引用：一个在DOM树中，另一个在字典中。 如果将来某个时候您决定删除这些行，则需要使两个引用置为不可访问。 1234567891011121314151617var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image')&#125;;function doStuff() &#123; image.src = 'http://example.com/image_name.png';&#125;function removeImage() &#123; // The image is a direct child of the body element. document.body.removeChild(document.getElementById('image')); // At this point, we still have a reference to #button in the //global elements object. In other words, the button element is //still in memory and cannot be collected by the GC.&#125; 还有一个额外的考虑，当涉及对DOM树内部的内部或叶节点的引用时，必须考虑这一点。 假设你在JavaScript代码中保留对表格特定单元格（标记）的引用。 有一天，你决定从DOM中删除该表，但保留对该单元格的引用。 直观地，可以假设GC将收集除了该单元格之外的所有内容。 实际上，这不会发生：该单元格是该表的子节点，并且孩子们保持对父代的引用。 也就是说，从JavaScript代码引用表格单元会导致整个表保留在内存中。 保持对DOM元素的引用时需要仔细考虑。 原文：https://segmentfault.com/a/1190000011229300#articleHeader7]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程]]></title>
    <url>%2Fpost%2F8731ab21.html</url>
    <content type="text"><![CDATA[ES6 中的作业(Jobs)是什么？ES6 中介绍了一种叫 “作业队列（Job Queue）” 的新概念。它是事件循环队列之上的一层。你很有可能会在处理 Promises 的异步的时候遇到它(我们后面也会讨论到它们)。 我们现在只简单介绍一下这个概念，以便当我们讨论 Promises 的异步行为的时候，你能理解这些行为是如何被调度和处理的。 想象一下：作业队列是一个跟在事件队列的每个 tick 的末尾的一个队列。在事件循环队列的一个 tick 期间可能会发生某些异步操作，这不会导致把一整个新事件添加到事件循环队列中，而是会在当前 tick 的作业队列的末尾添加一项(也就是作业)。 这意味着你可以添加一个稍后执行的功能，并且你可以放心，它会在执行任何其他操作之前执行。 作业还能够使更多的作业被添加到同一个队列的末尾。从理论上说，一个作业的“循环”（一个不停的添加其他作业的作业，等等）可能会无限循环，从而使进入下一个事件循环 tick 的程序的必要资源被消耗殆尽。从概念上讲，这就和你写了一个长时间运行的代码或是死循环(就像是 while (true))一样。 作业有点像 setTimeout(callback, 0) 的“hack”，但是它们引入了一个更加明确、更有保证的执行顺序：稍后执行，但是会尽快执行。 回调众所周知，在 JavaScript 程序中，回调是表达和管理异步目前最常用的方式。确实，回调是 JavaScript 中最基础的异步模式。无数的 JS 程序，甚至是非常复杂的 JS 程序，都是使用回调作为异步的基础。 回调也不是没有缺点。许多开发者都尝试去找到更好的异步模式。但是，如果你不理解底层的实际情况，你是不可能有效的去使用任何抽象化的东西。 在下一章中，我们将深入挖掘这些抽象的概念来说明为什么更复杂的异步模式（将会在后续的帖子中讨论）是必须的甚至是被推荐的 嵌套回调123456789101112listen('click', function (e)&#123; setTimeout(function()&#123; ajax('https://api.example.com/endpoint', function (text)&#123; if (text == "hello") &#123; doSomething(); &#125; else if (text == "world") &#123; doSomethingElse(); &#125; &#125;); &#125;, 500);&#125;); 我们有一个三个函数嵌套在一起的函数链，每一步都代表异步序列中的一步。 这种代码我们把它叫做“回调地狱”。但是“回调地狱”显然和嵌套/缩进没有关系。这是个更深层次的问题了。 首先，我们在等待一个“click”事件，然后等待定时器触发，再然后等着 Ajax 的响应返回，在这点上可能会再次重复。 乍一看，这个代码似乎可以分解成连续的几个步骤： 123listen('click', function (e) &#123; // ..&#125;); 然后： 123setTimeout(function()&#123; // ..&#125;, 500); 再然后： 123ajax('https://api.example.com/endpoint', function (text)&#123; // ..&#125;); 最后： 123456if (text == "hello") &#123; doSomething();&#125;else if (text == "world") &#123; doSomethingElse();&#125; 所以，用这样一种顺序的方式来表达你的异步代码是不是看起来更自然一些了？一定会有方法做到这一点，不是吗？ Promises看看下面的代码：1234var x = 1;var y = 2;console.log(x + y);&#125; 这是段简单的代码：它对 x 和 y 求和，然后在控制台打印出来。但，假如 x 或是 y 的值是待确定的呢？比如说，我们需要在使用这两个值之前去服务器检索 x 和 y 的值。然后，有两个函数 loadX 和 loadY，分别从服务器获取 x 和 y 的值。最后，函数 sum 来将获取到的 x 和 y 的值加起来。 看起来就是这样的(相当丑，不是吗？): 12345678910111213141516171819202122232425262728function sum(getX, getY, callback) &#123; var x, y; getX(function(result) &#123; x = result; if (y !== undefined) &#123; callback(x + y); &#125; &#125;); getY(function(result) &#123; y = result; if (x !== undefined) &#123; callback(x + y); &#125; &#125;);&#125;// 一个同步或者异步的函数，获取 `x` 的值function fetchX() &#123; // ..&#125;// 一个同步或者异步的函数，获取 `y` 的值function fetchY() &#123; // ..&#125;sum(fetchX, fetchY, function(result) &#123; console.log(result);&#125;); 这里面的关键点在于 — 这段代码中，x 和 y 是 未来 的值，然后我们还写了一个 sum(…) 函数，并且从外面看它并不关心 x 或者 y 现在是不是可用的。 当然，这种基于回调的方式是粗糙的并且有很多不足。这只是初步理解 未来值 以及不需要去担心它们什么时候可用的第一步。 Promise 值让我们看一下这个简短的例子是如何用 Promises 来表达 x + y 的： 123456789101112131415161718192021222324252627function sum(xPromise, yPromise) &#123; // `Promise.all([ .. ])` 接受一个 promises 的数组， // 并且返回一个新的 promise 对象去等待它们 // 全部完成 return Promise.all([xPromise, yPromise]) // 当 promise 完成的时候，我们就能获取 // `X` and `Y` 的值，并且计算他们 .then(function(values)&#123; // `values` 是一个来自前面完成的 promise // 的消息数组 return values[0] + values[1]; &#125; );&#125;// `fetchX()` and `fetchY()` 返回 promises 的值，有他们各自的// 值，或许*现在* 已经准备好了// 也可能要 *等一会儿*。sum(fetchX(), fetchY())// 我们从返回的 promise 得到了这// 两个数字的和。// 现在我们连续的调用了 `then(...)` 去等待已经完成的// promise。.then(function(sum)&#123; console.log(sum);&#125;); 这段代码可以看到两层 Promises。 fetchX() 和 fetchY() 被直接调用，然后他们的返回值(promises!)被传给 sum(…)。这些 promises 代表的值可能在 现在 或是 将来 准备好，但每个 promise 的自身规范都是相同的。我们以一种与时间无关的方式来解释 x 和 y 的值。它们在一段时间内是 未来值。 第二层 promise 是 sum(…) 创建 (通过 Promise.all([ … ])) 并返回的，我们通过调用 then(…) 来等待返回。当 sum(…) 操作完成的时候，未来值 的总和也就准备就绪了，然后就可以把值打印出来了。我们隐藏了在 sum(…) 函数内部等待 x 和 y 的 未来值 的逻辑。 注意：在 sum(…) 函数中，Promise.all([ … ]) 创建了一个 promise (这个 promise 等待 promiseX and promiseY 的完成)。链式调用 .then(…) 来创建另一个 promise，返回的 values[0] + values[1] 会立即执行完成(还要加上加运算的结果)。因此，我们在 sum(…) 调用结束后加上的 then(…) — 在上面代码的末尾 — 实际上是在第二个 promise 返回后执行，而不是第一个 Promise.all([ … ]) 创建的 promise。还有，尽管我们没有在第二个 then(…) 后面再进行链式调用，但是它也创建了一个 promise，我们可以去观察或是使用它。关于 Promise 的链式调用会在后面详细地解释。 使用 Promises，这个 then(…) 的调用其实有两个方法，第一个方法被调用的时机是在已完成的时候 (就像我们前面使用的那样)，而另一个被调用的时机是已失败的时候： 1234567891011sum(fetchX(), fetchY()).then( // 完成时 function(sum) &#123; console.log( sum ); &#125;, // 失败时 function(err) &#123; console.error( err ); // bummer! &#125;); 如果在获取 x 或者 y 的时候出错了，又或许是在进行加运算的时候失败了，sum(…) 返回的 promise 将会是已失败的状态，并且会将 promise 已失败的值传给 then(…) 的第二个回调处理。 因为 Promises 封装了依赖时间的状态 — 等待内部的值已完成或是已失败 — 从外面看，Promise 是独立于时间的，因此 Promises 可以能通过一种可预测的方式组合起来，而不用去考虑底层的时间或者结果。 而且，一旦 Promise 的状态确定了，那么他就永远也不会改变状态了 — 在这时它会变成一个 不可改变的值 — 然后就可以在有需要的时候多次 观察 它。 实际上链式的 promises 是非常有用的： 12345678910111213141516171819function delay(time) &#123; return new Promise(function(resolve, reject)&#123; setTimeout(resolve, time); &#125;);&#125;delay(1000).then(function()&#123; console.log("after 1000ms"); return delay(2000);&#125;).then(function()&#123; console.log("after another 2000ms");&#125;).then(function()&#123; console.log("step 4 (next Job)"); return delay(5000);&#125;)// ... 调用 delay(2000) 会创建一个在 2000ms 完成的 promise，然后我们返回第一个 then(…) 的成功回调，这会导致第二个 then(…) 的 promise 要再等待 2000ms 执行。 注意：因为 Promise 一旦完成了就不能再改变状态了，所以可以安全的传递到任何地方，因为它不会再被意外或是恶意的修改。这对于在多个地方监听 Promise 的解决方案来说，尤其正确。一方不可能影响到另一方所监听到的结果。不可变听起来像是一个学术性的话题，但是它是 Promise 设计中最基础、最重要方面，不应该被忽略。 用不用 Promise？使用 Promises 最重要的一点在于能否确定一些值是否是真正的 Promise。换句话说，它的值像一个 Promise 吗？ 我们知道 Promises 是由 new Promise(…) 语句构造出来的，你可能会认为 p instanceof Promise 就能判断一个 Promise。其实，并不完全是。 主要是因为另一个浏览器窗口(比如 iframe)获取一个 Promise 的值，它拥有自己的 Promise 类，且不同于当前或其他窗口，所以使用 instance 来区分 Promise 是不准确的。 而且，一个框架或者库可以选择自己的 Promise，而不是使用 ES6 原生的 Promise 实现。事实上，你很可能会在不支持 Promise 的老式浏览器中使用第三方的 Promise 库。 吞噬异常如果在任何一个创建 Promise 或是对其结果观察的过程中，抛出了一个 JavaScript 异常错误，比如说 TypeError 或是 ReferenceError，那么这个异常会被捕获，然后它就会把 Promise 的状态变成已失败。 例如： 1234567891011121314var p = new Promise(function(resolve, reject)&#123; foo.bar(); // 对不起，`foo` 没有定义 resolve(374); // 不会执行 :(&#125;);p.then( function fulfilled()&#123; // 不会执行 :( &#125;, function rejected(err)&#123; // `err` 是 `foo.bar()` 那一行 // 抛出的 `TypeError` 异常对象。 &#125;); 如果一个 Promise 已经结束了，但是在监听结果(在 then(…) 里的回调函数)的时候发生了 JS 异常会怎么样呢？即使这个错误没有丢失，你可能也会对它的处理方式有点惊讶。除非你深入的挖掘一下：123456789101112var p = new Promise( function(resolve,reject)&#123; resolve(374);&#125;);p.then(function fulfilled(message)&#123; foo.bar(); console.log(message); // 不会执行&#125;, function rejected(err)&#123; // 不会执行 &#125;); 这看起来就像 foo.bar() 的异常真的被吞了。当然了，异常并不是被吞了。这是更深层次的问题出现了，我们没有监听到异常。p.then(…) 调用它自己会返回另一个 promise，而这个 promise 会因为 TypeError 的异常变为已失败状态。 处理未捕获的异常还有一些 更好的 办法解决这个问题。 最常见的就是给 Promise 加一个 done(…)，用来标志 Promise 链的结束。done(…) 不会创建或返回一个 Promise，所以传给 done(..) 的回调显然不会将问题报告给一个不存在的 Promise。 在未捕获异常的情况下，这可能才是你期望的：在 done(..) 已失败的处理函数里的任何异常都会抛出一个全局的未捕获异常（通常是在开发者的控制台）。 12345678910var p = Promise.resolve(374);p.then(function fulfilled(msg)&#123; // 数字不会拥有字符串的方法， // 所以会抛出一个错误 console.log(msg.toLowerCase());&#125;).done(null, function() &#123; // 如果有异常发生，它就会被全局抛出 &#125;); ES8 发生了什么？ Async/awaitJavaScript ES8 介绍了 async/await，使得我们能更简单的使用 Promises。我们将简单的介绍 async/await 会带给我们什么以及如何利用它们写出异步的代码。 所以，来让我们看看 async/await 是如何工作的。 使用 async 函数声明来定义一个异步函数。这样的函数返回一个 AsyncFunction 对象。AsyncFunction 对象表示执行包含在这个函数中的代码的异步函数。 当一个 async 函数被调用，它返回一个 Promise。当 async 函数返回一个值，它不是一个 Promise，Promise 将会被自动创建，然后它使用函数的返回值来决定状态。当 async 抛出一个异常，Promise 使用抛出的值进入已失败状态。 一个 async 函数可以包含一个 await 表达式，它会暂停执行这个函数然后等待传给它的 Promise 完成，然后恢复 async 函数的执行，并返回已成功的值。 你可以把 JavaScript 的 Promise 看作是 Java 的 Future 或是 C# 的 Task。 async/await 的目的是简化使用 promises 的写法。 让我们来看看下面的例子： 12345678// 一个标准的 JavaScript 函数function getNumber1() &#123; return Promise.resolve('374');&#125;// 这个 function 做了和 getNumber1 同样的事async function getNumber2() &#123; return 374;&#125; 同样，抛出异常的函数等于返回已失败的 promises： 123456function f1() &#123; return Promise.reject('Some error');&#125;async function f2() &#123; throw 'Some error';&#125; 关键字 await 只能使用在 async 的函数中，并允许你同步等待一个 Promise。如果我们在 async 函数之外使用 promise，我们仍然要用 then 回调函数： 1234567891011121314async function loadData() &#123; // `rp` 是一个请求异步函数 var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // 现在，两个请求都被触发, // 我们就等待它们完成。 var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;&#125;// 但，如果我们没有在 `async function` 里// 我们就必须使用 `then`。loadData().then(() =&gt; console.log('Done')); 你还可以使用 async 函数表达式的方法创建一个 async 函数。async 函数表达式的写法和 async 函数声明差不多。函数表达式和函数声明最主要的区别就是函数名，它可以在 async 函数表达式中省略来创建一个匿名函数。一个 async 函数表达式可以作为一个 IIFE（立即执行函数） 来使用，当它被定义好的时候就会执行。 它看起来是这样的： 1234567891011var loadData = async function() &#123; // `rp` 是一个请求异步函数 var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // 现在，两个请求都被触发, // 我们就等待它们完成。 var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;&#125; 最后，最重要的是不要盲目的选择“最新”的方法去写异步代码。更重要的是理解异步 JavaScript 内部的原理，知道为什么它为什么如此重要以及去理解你选择的方法的内部原理。在程序中每种方法都是有利有弊的。 5 个编写可维护的、健壮的异步代码的技巧1.干净的代码: 使用 async/await 能够让你少写代码。每一次你使用 async/await 你都能跳过一些不必要的步骤：写一个 .then，创建一个匿名函数来处理响应，在回调中命名响应，比如： 1234// `rp` 是一个请求异步函数rp(‘https://api.example.com/endpoint1').then(function(data) &#123; // …&#125;); 对比: 12// `rp` 是一个请求异步函数var response = await rp(‘https://api.example.com/endpoint1'); 错误处理: Async/await 使得我们可以使用相同的代码结构处理同步或者异步的错误 —— 著名的 try/catch 语句。让我们看看用 Async/await 是怎么实现的： 12345678async function loadData() &#123; try &#123; var data = JSON.parse(await getJSON()); console.log(data); &#125; catch(e) &#123; console.log(e); &#125;&#125; 3.条件语句: 使用 async/await 来写条件语句要简单得多： 123456789101112131415function loadData() &#123; return getJSON() .then(function(response) &#123; if (response.needsAnotherRequest) &#123; return makeAnotherRequest(response) .then(function(anotherResponse) &#123; console.log(anotherResponse) return anotherResponse &#125;) &#125; else &#123; console.log(response) return response &#125; &#125;)&#125; 对比： 1234567891011async function loadData() &#123; var response = await getJSON(); if (response.needsAnotherRequest) &#123; var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse &#125; else &#123; console.log(response); return response; &#125;&#125; 4.栈帧: 和 async/await 不同的是，根据promise链返回的错误堆栈信息，并不能发现哪出错了。来看看下面的代码： 1234567891011121314function loadData() &#123; return callAPromise() .then(callback1) .then(callback2) .then(callback3) .then(() =&gt; &#123; throw new Error("boom"); &#125;)&#125;loadData() .catch(function(e) &#123; console.log(err);// Error: boom at callAPromise.then.then.then.then (index.js:8:13)&#125;); 对比： 1234567891011121314async function loadData() &#123; await callAPromise1() await callAPromise2() await callAPromise3() await callAPromise4() await callAPromise5() throw new Error("boom");&#125;loadData() .catch(function(e) &#123; console.log(err); // 输出 // Error: boom at loadData (index.js:7:9)&#125;); 5.调试: 如果你使用了 promises，你就会知道调试它们将会是一场噩梦。比如，你在 .then 里面打了一个断点，并且使用类似 “stop-over” 这样的 debug 快捷方式，调试器不会移动到下一个 .then，因为它只会对同步代码生效。而通过 async/await 你就可以逐步的调试 await 调用了，它就像是一个同步函数一样。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 执行机制]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的。 javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，通常采用异步加载，就是异步任务。关于这部分有严格的文字定义，在这里用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册回调函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 代码演示123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log('发送成功!'); &#125;&#125;)console.log('代码执行结束'); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(‘代码执行结束’)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 通过上面的文字和代码，已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 setTimeoutsetTimeout的作用可以延时执行代码，我们经常这么实现延时3秒执行： 123setTimeout(() =&gt; &#123; console.log('延时3秒')&#125;, 3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，跟所设定的时间不一样？先看一个例子: 1234setTimeout(() =&gt; &#123; task();&#125;,3000)console.log('执行console'); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码 12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明:12345//代码1console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,0); 12345//代码2console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,3000); 代码1的输出结果是:12//先执行这里//执行啦 代码2的输出结果是：123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 setInterval循环的执行代码。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行第一次宏任务中所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束 事件循环，宏任务，微任务的关系如图所示: 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3 宏任务Event Queue 微任务Event Queue process3 process3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 写在最后js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 最后 javascript是一门单线程语言 Event Loop是javascript的执行机制]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript调用堆栈]]></title>
    <url>%2Fpost%2Fc0155143.html</url>
    <content type="text"><![CDATA[JavaScript 引擎JavaScript 引擎说起来最流行的当然是谷歌的 V8 引擎了， V8 引擎使用在 Chrome 以及 Node 中，下面有个简单的图能说明他们的关系： 这个引擎主要由两部分组成: 内存堆：这是内存分配发生的地方 调用栈：这是你的代码执行时的地方 运行时有些浏览器的 API 经常被使用到(比如说：setTimeout)，但是，这些 API 却不是引擎提供的。那么，他们是从哪儿来的呢？事实上这里面实际情况有点复杂。 所以说我们还有很多引擎之外的 API，我们把这些称为浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout等等。 然后我们还拥有如此流行的事件循环和回调队列。 调用栈JavaScript 是一门单线程的语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。 调用栈是一种数据结构，它记录了我们在程序中的位置。如果我们运行到一个函数，它就会将其放置到栈顶。当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情。 让我们来看一看下面的例子： 12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 当程序开始执行的时候，调用栈是空的，然后，步骤如下： 每一个进入调用栈的都称为调用帧。这能清楚的知道当异常发生的时候堆栈追踪是怎么被构造的，堆栈的状态是如何的。让我们看一下下面的代码： 12345678910function foo() &#123; throw new Error('SessionStack will help you resolve crashes :)');&#125;function bar() &#123; foo();&#125;function start() &#123; bar();&#125;start(); 如果这发生在 Chrome 里(假设这段代码实在一个名为 foo.js 的文件中)，那么将会生成以下的堆栈追踪： “堆栈溢出”，当你达到调用栈最大的大小的时候就会发生这种情况，而且这相当容易发生，特别是在你写递归的时候却没有全方位的测试它。我们来看看下面的代码： 1234function foo() &#123; foo();&#125;foo(); 当我们的引擎开始执行这段代码的时候，它从 foo 函数开始。然后这是个递归的函数，并且在没有任何的终止条件的情况下开始调用自己。因此，每执行一步，就会把这个相同的函数一次又一次地添加到调用堆栈中。然后它看起来就像是这样的： 然后，在某一时刻，调用栈中的函数调用的数量超过了调用栈的实际大小，浏览器决定干掉它，抛出一个错误，它看起来就像是这样: 在单个线程上运行代码很容易，因为你不必处理在多线程环境中出现的复杂场景——例如死锁。但是在一个线程上运行也非常有限制。由于 JavaScript 只有一个调用堆栈，当某段代码运行变慢时会发生什么? 并发与事件循环调用栈中的函数调用需要大量的时间来处理，那么这会发生什么情况呢?例如，假设你想在浏览器中使用 JavaScript 进行一些复杂的图片转码。 你可能会问？这算什么问题？事实上，问题是当调用栈有函数要执行，浏览器就不能做任何事，它会被堵塞住。这意味着浏览器不能渲染，不能运行其他的代码，它被卡住了。如果你想在应用里让 UI 很流畅的话，这就会产生问题。 而且这不是唯一的问题，一旦你的浏览器开始处理调用栈中的众多任务，它可能会停止响应相当长一段时间。大多数浏览器都会这么做，报一个错误，询问你是否想终止 web 页面。 这样看来，这并不是最好的用户体验，不是吗？那么，如何在不阻塞 UI 的情况下执行复杂的代码，让浏览器不会不响应?解决方案就是异步回调。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
