<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript内存管理以及内存泄漏]]></title>
    <url>%2Fpost%2F24cc7cf9.html</url>
    <content type="text"><![CDATA[概述语言，比如C，具有低层次的内存管理方法，比如malloc()以及free()。开发者利用这些方法精确地为操作系统分配以及释放内存。 同时，JavaScript会在创建一些变量（对象，字符串等等）的时候分配内存，并且会在这些不被使用之后“自动地”释放这些内存，这个过程被称为垃圾收集。这个看起来“自动化的”特性其实就是产生误解的原因，并且给JavaScript（以及其他高层次语言）开发者一个假象，他们不需要关心内存管理。大错特错。 即使是使用高层次语言，开发者应该对于内存管理有一定的理解（或者最基本的理解）。有时候自动的内存管理会存在一些问题（比如一些bug或者垃圾收集器的一些限制等等），对于这些开发者必须能够理解从而能够合适地处理（或者使用最小的代价以及代码债务去绕过这个问题）。 内存生命周期不管你在使用什么编程语言，内存的生命周期基本上都是一样的： 下面是对于周期中每一步所发生的情况的概述： 分配内存——操作系统为你的程序分配内存并且允许其使用。在低层次语言中（比如C），这正是开发者应该处理的操作。在高层次的语言，然而，就由语言帮你实现了。 使用内存——当你的程序确实在使用之前分配的内存的阶段。当你在使用你代码里面分配的变量的时候会发生读以及写操作。 释放内存——这个阶段就是释放你不再需要的内存，从而这些内存被释放并且能够再次被使用。和分配内存操作一样，这在低层次的语言也是开发者需要明确的操作。 什么是内存？在我们讲述JavaScript内存之前，我们将简要地讨论一下内存是什么以及它们是如何在 nutshell 中工作的。 在硬件层次上，计算机内存由大量的 寄存器 组成。每一个寄存器都包含一些晶体管并且能够存储一比特。单独的寄存器可以通过独特的标识符去访问，因此我们能够读取以及重写它们。因此，从概念上来说，我们可以认为我们的整个计算机内存就是一个我们能够读写的大型比特数组。 因为作为人类，我们不擅长直接基于比特进行思考以及算术，我们将它们组织成大规模群组，它们在一起可以代表一个数字。8个比特称为一个字节。除了字节，还有词（有时候是16比特，有时候是32比特）。 内存中存储了很多东西： 1.所有程序使用的变量和其他数据 2.程序的代码，包括操作系统的代码。 编译器和操作系统共同合作为你处理大部分的内存管理，但是我们建议你应该了解其内部的运行原理。 当你编译你的代码的时候，编译器将会检查原始数据类型并且提前计算好它们需要多少内存。需要的内存被分配给程序，这被称为栈空间。这些被分配给变量的空间被称为栈空间，因为一旦函数被调用，它们的内存就会增加到现有内存的上面。当它们终止的时候，它们就会以后进先出(LIFO)的顺序移除。比如，考虑下面的声明。 123int n; // 4 bytesint x[4]; // array of 4 elements, each 4 bytesdouble m; // 8 bytes 编译器能够立即计算出代码需要 4 + 4 × 4 + 8 = 28 字节 那就是它如何对于现有的整形以及双浮点型工作。大约20年前，整形典型都是2个字节，双浮点型是4个字节。你的代码不应该取决于当下基本数据类型的大小。 编译器将会插入能够与操作系统交互的代码，从而在栈上获取你需要存储变量需要的字节数。 在上述的例子中，编译器知道每一个变量的准确的内存地址。事实上，无论我们何时写变量 n ，这都会在内部转化为类似于“内存地址 4127963”的东西。 注意如果我们希望在这访问 x[4] 我们将会需要访问和 m 相关联的数据。这是因为我们在访问数组里面并不存在的元素——它比数组实际分配的最后一个元素 x[3] 要多4个字节，并且最后可能是阅读（或者重写）一些 m 的比特。这将很可能给程序的其他部分带来一些不良的后果。 当函数调用其它函数的时候，当它被调用的时候都会获取它自己的堆栈块。它在那保存了它所有的局部变量，但是还会有一个程序计数器记录它执行的位置。当这个函数执行完毕，它的内存块就可以再次用于其他目的。 动态分配不幸的是，当我们在编译的时候不知道变量需要多少内存的话事情可能就不那么简单。假设我们想做下面的事情： 12345int n = readInput(); // reads input from the user...// create an array with &quot;n&quot; elements 在此，在编译阶段中，编译器就没有办法知道数组需要多少内存，因为它取决于用户的输入。 因此，它就不能够为栈上的变量分配空间。相反，我们的程序需要明确地询问操作运行时需要的空间数量。这个内存是从堆空间中分配出来的。动态内存和静态内存分配的区别总结如下表格： 为了深入地理解动态内存分配是如何工作的，我们需要花费更多的时间在指针。 JavaScript中的分配现在我们将解释JavaScript中的第一步（分配内存）。 JavaScript 将开发者从内存分配的处理中解放出来——JavaScript自身可以利用声明变量来完成这些任务。 12345678910111213141516171819var n = 374; // allocates memory for a numbervar s = 'sessionstack'; // allocates memory for a string var o = &#123; a: 1, b: null&#125;; // allocates memory for an object and its contained valuesvar a = [1, null, 'str']; // (like object) allocates memory for the // array and its contained valuesfunction f(a) &#123; return a + 3;&#125; // allocates a function (which is a callable object)// function expressions also allocate an objectsomeElement.addEventListener('click', function() &#123; someElement.style.backgroundColor = 'blue';&#125;, false); 一些函数调用也会导致一些对象的分配： 123var d = new Date(); // allocates a Date objectvar e = document.createElement('div'); // allocates a DOM element 能够分配新的值或者对象的方法： 1234567891011var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 is a new string// Since strings are immutable, // JavaScript may decide to not allocate memory, // but just store the [0, 3] range.var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2); // new array with 4 elements being// the concatenation of a1 and a2 elements 在JavaScript中使用内存基本上在JavaScript中分配内存，就意味着在其中读写。 这可以通过对一个变量或者一个对象的属性甚至是向函数传递一个参数来完成。 当内存不再需要的时候释放它大多数的内存管理的问题就来自于这个阶段。 最困难的任务就是如何知道何时被分配的不再需要了。它经常需要开发者决定在程序的什么地方某段内存不再需要了并且对其进行释放。 高层次语言内嵌了一个称为垃圾收集器的软件，他的任务就是跟踪内存分配并且用于需找不再需要的分配过的内存，并且自动地对其进行释放。 不幸的是，这个过程是一个近似，因为知道是否某块内存是需要的问题是不可决定的（无法通过算法解决） 大多数的垃圾收集器通过收集再也无法访问的内存工作，比如：指向它的所有变量都超出了作用域。然而，这依然是对于可以收集的内存空间的预估，因为在任何位置仍可能一些变量在作用域内指向这个内存，然而它再也不能被访问了。 垃圾收集器由于找到一些是“不再需要的”是不可决定的事实，垃圾收集实现了对一般问题的解决方案的限制。这一节将会解释理解主要的垃圾收集算法以及它们的限制的需要注意的事项。 内存引用垃圾收集算法依赖的主要概念之一就是引用。 在内存管理的上下文中，一个对象被称为是对于另外一个对象的引用，如果前者可以访问后者（隐含或明确的）。例如，一个JavaScript对象都有一个指向其原型的引用（隐含的引用） 在这个上下文中，“对象”的概念扩展到比普通的JavaScript对象要广并且包括函数作用域（或者全局词法作用域）。 词法作用域定义了变量名称是如何在嵌套函数中解析的：内部函数包含了父函数的作用域即使父函数已经返回了。 基于引用计数的垃圾收集器这是最简单的垃圾收集器算法。如果没有引用指向这个对象的时候，这个对象就被认为是“可以作为垃圾收集”。 请看如下代码： 1234567891011121314151617181920212223242526272829var o1 = &#123; o2: &#123; x: 1 &#125;&#125;;// 2 objects are created. // 'o2' is referenced by 'o1' object as one of its properties.// None can be garbage-collectedvar o3 = o1; // the 'o3' variable is the second thing that // has a reference to the object pointed by 'o1'. o1 = 1; // now, the object that was originally in 'o1' has a // single reference, embodied by the 'o3' variablevar o4 = o3.o2; // reference to 'o2' property of the object. // This object has now 2 references: one as // a property. // The other as the 'o4' variableo3 = '374'; // The object that was originally in 'o1' has now zero // references to it. // It can be garbage-collected. // However, what was its 'o2' property is still // referenced by the 'o4' variable, so it cannot be // freed.o4 = null; // what was the 'o2' property of the object originally in // 'o1' has zero references to it. // It can be garbage collected. 循环在产生问题当遇到循环的时候就会有一个限制。在下面的实例之中，创建两个对象，并且互相引用，因此就会产生一个循环。当函数调用结束之后它们会走出作用域之外，因此它们就没什么用并且可以被释放。但是，基于引用计数的算法认为这两个对象都会被至少引用一次，所以它俩都不会被垃圾收集器收集。 12345678function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 references o2 o2.p = o1; // o2 references o1. This creates a cycle.&#125;f(); 标记-清除算法为了决定哪个对象是需要的，算法会决定是否这个对象是可访问的。 这个算法由以下步骤组成： 这个垃圾收集器构建一个“roots”列表。Root是全局变量，被代码中的引用所保存。在 JavaScript中，“window”就是这样的作为root的全局变量的例子。 所有的root都会被监测并且被标志成活跃的（比如不是垃圾）。所有的子代也会递归地被监测。所有能够由root访问的一切都不会被认为是垃圾。 所有不再被标志成活跃的内存块都被认为是垃圾。这个收集器现在就可以释放这些内存并将它们返还给操作系统。 这个算法要优于之前的因为“一个具有0引用的对象”可以让一个对象不能够再被访问。但是相反的却不一定成立，比如我们遇到循环的时候。 在2012年，所有的现代浏览器都使用标记-清除垃圾收集器。过去几年，JavaScript垃圾收集（代数/增量/并行/并行垃圾收集）领域的所有改进都是对该算法（标记和扫描）的实现进行了改进，但并没有对垃圾收集算法本身的改进， 其目标是确定一个对象是否可达。 在这篇文章中，你可以得到更多关于垃圾收集追踪并且也覆盖到了关于标记-清除算法的优化。 循环不再是一个问题在上述的第一个例子中，在函数调用返回之后，这两个对象不能够被全局对象所访问。因此，垃圾收集器就会发现它们不能够被访问了。 即使在这两个对象之间存在着引用，它们再也不能从root访问了。 列举垃圾收集器的直观行为虽然垃圾收集器很方便，但它们自己也有自己的代价。 其中一个是非确定论。 换句话说，GC是不可预测的。 你不能真正地告诉你什么时候会收集。 这意味着在某些情况下，程序会使用实际需要的更多内存。 在其他情况下，特别敏感的应用程序可能会引起短暂暂停。 虽然非确定性意味着在执行集合时无法确定，但大多数GC实现共享在分配期间执行收集遍历的常见模式。 如果没有执行分配，大多数GC保持空闲状态。 考虑以下情况： 执行相当大的一组分配。 这些元素中的大多数（或全部）被标记为不可访问（假设我们将指向我们不再需要的缓存的引用置空）。 不再执行分配。 在这种情况下，大多数GC不会再运行收集处理。换句话说，即使存在对于收集器来说不可访问的引用，它们也不会被收集器所认领。严格意义来说这并不是泄露，但是依然会导致比平常更多的内存使用。 什么是内存泄露？实质上，内存泄漏可以被定义为应用程序不再需要的内存，但是由于某些原因不会返回到操作系统或可用内存池。 编程语言有支持管理内存的不同方法。 然而，某块内存是否被使用实际上是一个不可判定的问题。 换句话说，只有开发人员可以清楚一个内存是否可以返回到操作系统。 某些编程语言提供了帮助开发者执行此操作的功能。其他的则期望开发人员能够完全明确何时使用一块内存。 维基百科有关于手动和自动内存管理的好文章。 四种常见的JavaScript泄露全局变量JavaScript 使用一种有趣的方式处理未声明的变量：一个未声明变量的引用会在全局对象内部产生一个新的变量。在浏览器的情况，这个全局变量就会是window。换句话说： 123function foo(arg) &#123; bar = "some text";&#125; 等同于：123function foo(arg) &#123; window.bar = "some text";&#125; 如果bar被期望仅仅在foo函数作用域内保持对变量的引用，并且你忘记使用var去声明它，一个意想不到的全局变量就产生了。 在这个例子中，泄露就仅仅是一个字符串并不会带来太多危害，但是它可能会变得更糟。 另外一种可能产生意外的全局变量的方式是： 1234567function foo() &#123; this.var1 = "potential accidental global";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); 为了阻止这些错误的发生，可以在js文件头部添加’use strict’。这将会使用严格模式来解析 JavaScript 从而阻止意外的全局变量。了解更多关于JavaScript执行的模式。 即使我们讨论了未预期的全局变量，但仍然有很多代码用显式的全局变量填充。 这些定义是不可收集的（除非分配为null或重新分配）。 特别是，用于临时存储和处理大量信息的全局变量值得关注。如果你必须使用全局变量来存储大量数据，请确保在完成之后将其分配为null或重新分配。 被遗忘的计时器和回调setInterval 在 JavaScript 中是经常被使用的。 大多数提供观察者和其他模式的回调函数库都会在调用自己的实例变得无法访问之后对其任何引用也设置为不可访问。 但是在setInterval的情况下，这样的代码很常见： 1234567var serverData = loadData();setInterval(function() &#123; var renderer = document.getElementById('renderer'); if(renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); //This will be executed every ~5 seconds. 这个例子说明了计时器可能发生的情况：计时器可能会产生再也不被需要的节点或者数据的引用。 renderer所代表的对象在未来可能被移除，让部分interval 处理器中代码变得不再被需要。然而，这个处理器不能够被收集因为interval依然活跃的（这个interval需要被停止从而表面这种情况）。如果这个interval处理器不能够被收集，那么它的依赖也不能够被收集。这意味这存储大量数据的severData也不能够被收集。 在这种观察者的情况下，做出准确的调用从而在不需要它们的时候立即将其移除是非常重要的（或者相关的对象被置为不可访问的）。 过去，以前特别重要的是某些浏览器（好的老IE 6）无法管理好循环引用（有关更多信息，请参见下文）。 如今，大多数浏览器一旦观察到的对象变得无法访问，就能收集观察者处理器，即使侦听器没有被明确删除。 但是，在处理对象之前，明确删除这些观察者仍然是一个很好的做法。 例如： 1234567891011121314151617var element = document.getElementById('launch-button');var counter = 0;function onClick(event) &#123; counter++; element.innerHtml = 'text ' + counter;&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers // that don't handle cycles well. 当今，现在浏览器（报错IE和Edge）都使用了现代的垃圾收集算法，其能够检测到这些循环并且进行适宜的处理。换句话说，再也不是严格需要在将节点置为不可访问之前调用removeEventListener 。 框架和库（如jQuery）在处理节点之前（在为其使用特定的API时）会删除侦听器。 这是由库内部处理的，这也确保没有泄漏，即使在有问题的浏览器下运行，如…是的，IE 6。 闭包JavaScript 开发的一个关键方面是闭包：一个可以访问外部（封闭）函数变量的内部函数。 由于JavaScript运行时的实现细节，可以通过以下方式泄漏内存： 1234567891011121314151617 var theThing = null; var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) // a reference to 'originalThing' console.log("hi"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log("message"); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 这个代码段会做一件事情：每次 replaceThing 被调用时，theThing 都会获取一个一个包含一个大数组的以及一个新的闭包（someMethod）。同时，unused 会保持一个指向originalThing引用的闭包（从上一个调用的theThing到replaceThing）。可能已经很迷惑了，是不是？重要的事情是一旦在相同的父级作用域为闭包产生作用域，这个作用域就会被共享。 在这种情况下，为someMethod闭包产生的作用域就会被unused 所共享。unused 具有对于originaThing的引用。即使 unused 不再被使用，someMethod依然可以通过replaceThing作用域之外的theThing来使用。并且由于somethod和unused 共享闭包作用域，unused指向originalThing的引用强迫其保持活跃（两个闭包之间的整个共享作用域）。这将会阻止垃圾手机。 当这个代码段重复运行时，可以观察到内存使用量的稳定增长。 当GC运行时，这不会变小。 实质上，创建了一个关闭的链接列表（其root以TheThing变量的形式），并且这些闭包的范围中的每一个都对大数组进行间接引用，导致相当大的泄漏。 DOM 之外的引用有时将DOM节点存储在数据结构中可能是有用的。 假设要快速更新表中的几行内容。 存储对字典或数组中每个DOM行的引用可能是有意义的。 当发生这种情况时，会保留对同一DOM元素的两个引用：一个在DOM树中，另一个在字典中。 如果将来某个时候您决定删除这些行，则需要使两个引用置为不可访问。 1234567891011121314151617var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image')&#125;;function doStuff() &#123; image.src = 'http://example.com/image_name.png';&#125;function removeImage() &#123; // The image is a direct child of the body element. document.body.removeChild(document.getElementById('image')); // At this point, we still have a reference to #button in the //global elements object. In other words, the button element is //still in memory and cannot be collected by the GC.&#125; 还有一个额外的考虑，当涉及对DOM树内部的内部或叶节点的引用时，必须考虑这一点。 假设你在JavaScript代码中保留对表格特定单元格（标记）的引用。 有一天，你决定从DOM中删除该表，但保留对该单元格的引用。 直观地，可以假设GC将收集除了该单元格之外的所有内容。 实际上，这不会发生：该单元格是该表的子节点，并且孩子们保持对父代的引用。 也就是说，从JavaScript代码引用表格单元会导致整个表保留在内存中。 保持对DOM元素的引用时需要仔细考虑。 原文：https://segmentfault.com/a/1190000011229300#articleHeader7]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程]]></title>
    <url>%2Fpost%2F8731ab21.html</url>
    <content type="text"><![CDATA[ES6 中的作业(Jobs)是什么？ES6 中介绍了一种叫 “作业队列（Job Queue）” 的新概念。它是事件循环队列之上的一层。你很有可能会在处理 Promises 的异步的时候遇到它(我们后面也会讨论到它们)。 我们现在只简单介绍一下这个概念，以便当我们讨论 Promises 的异步行为的时候，你能理解这些行为是如何被调度和处理的。 想象一下：作业队列是一个跟在事件队列的每个 tick 的末尾的一个队列。在事件循环队列的一个 tick 期间可能会发生某些异步操作，这不会导致把一整个新事件添加到事件循环队列中，而是会在当前 tick 的作业队列的末尾添加一项(也就是作业)。 这意味着你可以添加一个稍后执行的功能，并且你可以放心，它会在执行任何其他操作之前执行。 作业还能够使更多的作业被添加到同一个队列的末尾。从理论上说，一个作业的“循环”（一个不停的添加其他作业的作业，等等）可能会无限循环，从而使进入下一个事件循环 tick 的程序的必要资源被消耗殆尽。从概念上讲，这就和你写了一个长时间运行的代码或是死循环(就像是 while (true))一样。 作业有点像 setTimeout(callback, 0) 的“hack”，但是它们引入了一个更加明确、更有保证的执行顺序：稍后执行，但是会尽快执行。 回调众所周知，在 JavaScript 程序中，回调是表达和管理异步目前最常用的方式。确实，回调是 JavaScript 中最基础的异步模式。无数的 JS 程序，甚至是非常复杂的 JS 程序，都是使用回调作为异步的基础。 回调也不是没有缺点。许多开发者都尝试去找到更好的异步模式。但是，如果你不理解底层的实际情况，你是不可能有效的去使用任何抽象化的东西。 在下一章中，我们将深入挖掘这些抽象的概念来说明为什么更复杂的异步模式（将会在后续的帖子中讨论）是必须的甚至是被推荐的 嵌套回调123456789101112listen('click', function (e)&#123; setTimeout(function()&#123; ajax('https://api.example.com/endpoint', function (text)&#123; if (text == "hello") &#123; doSomething(); &#125; else if (text == "world") &#123; doSomethingElse(); &#125; &#125;); &#125;, 500);&#125;); 我们有一个三个函数嵌套在一起的函数链，每一步都代表异步序列中的一步。 这种代码我们把它叫做“回调地狱”。但是“回调地狱”显然和嵌套/缩进没有关系。这是个更深层次的问题了。 首先，我们在等待一个“click”事件，然后等待定时器触发，再然后等着 Ajax 的响应返回，在这点上可能会再次重复。 乍一看，这个代码似乎可以分解成连续的几个步骤： 123listen('click', function (e) &#123; // ..&#125;); 然后： 123setTimeout(function()&#123; // ..&#125;, 500); 再然后： 123ajax('https://api.example.com/endpoint', function (text)&#123; // ..&#125;); 最后： 123456if (text == "hello") &#123; doSomething();&#125;else if (text == "world") &#123; doSomethingElse();&#125; 所以，用这样一种顺序的方式来表达你的异步代码是不是看起来更自然一些了？一定会有方法做到这一点，不是吗？ Promises看看下面的代码：1234var x = 1;var y = 2;console.log(x + y);&#125; 这是段简单的代码：它对 x 和 y 求和，然后在控制台打印出来。但，假如 x 或是 y 的值是待确定的呢？比如说，我们需要在使用这两个值之前去服务器检索 x 和 y 的值。然后，有两个函数 loadX 和 loadY，分别从服务器获取 x 和 y 的值。最后，函数 sum 来将获取到的 x 和 y 的值加起来。 看起来就是这样的(相当丑，不是吗？): 12345678910111213141516171819202122232425262728function sum(getX, getY, callback) &#123; var x, y; getX(function(result) &#123; x = result; if (y !== undefined) &#123; callback(x + y); &#125; &#125;); getY(function(result) &#123; y = result; if (x !== undefined) &#123; callback(x + y); &#125; &#125;);&#125;// 一个同步或者异步的函数，获取 `x` 的值function fetchX() &#123; // ..&#125;// 一个同步或者异步的函数，获取 `y` 的值function fetchY() &#123; // ..&#125;sum(fetchX, fetchY, function(result) &#123; console.log(result);&#125;); 这里面的关键点在于 — 这段代码中，x 和 y 是 未来 的值，然后我们还写了一个 sum(…) 函数，并且从外面看它并不关心 x 或者 y 现在是不是可用的。 当然，这种基于回调的方式是粗糙的并且有很多不足。这只是初步理解 未来值 以及不需要去担心它们什么时候可用的第一步。 Promise 值让我们看一下这个简短的例子是如何用 Promises 来表达 x + y 的： 123456789101112131415161718192021222324252627function sum(xPromise, yPromise) &#123; // `Promise.all([ .. ])` 接受一个 promises 的数组， // 并且返回一个新的 promise 对象去等待它们 // 全部完成 return Promise.all([xPromise, yPromise]) // 当 promise 完成的时候，我们就能获取 // `X` and `Y` 的值，并且计算他们 .then(function(values)&#123; // `values` 是一个来自前面完成的 promise // 的消息数组 return values[0] + values[1]; &#125; );&#125;// `fetchX()` and `fetchY()` 返回 promises 的值，有他们各自的// 值，或许*现在* 已经准备好了// 也可能要 *等一会儿*。sum(fetchX(), fetchY())// 我们从返回的 promise 得到了这// 两个数字的和。// 现在我们连续的调用了 `then(...)` 去等待已经完成的// promise。.then(function(sum)&#123; console.log(sum);&#125;); 这段代码可以看到两层 Promises。 fetchX() 和 fetchY() 被直接调用，然后他们的返回值(promises!)被传给 sum(…)。这些 promises 代表的值可能在 现在 或是 将来 准备好，但每个 promise 的自身规范都是相同的。我们以一种与时间无关的方式来解释 x 和 y 的值。它们在一段时间内是 未来值。 第二层 promise 是 sum(…) 创建 (通过 Promise.all([ … ])) 并返回的，我们通过调用 then(…) 来等待返回。当 sum(…) 操作完成的时候，未来值 的总和也就准备就绪了，然后就可以把值打印出来了。我们隐藏了在 sum(…) 函数内部等待 x 和 y 的 未来值 的逻辑。 注意：在 sum(…) 函数中，Promise.all([ … ]) 创建了一个 promise (这个 promise 等待 promiseX and promiseY 的完成)。链式调用 .then(…) 来创建另一个 promise，返回的 values[0] + values[1] 会立即执行完成(还要加上加运算的结果)。因此，我们在 sum(…) 调用结束后加上的 then(…) — 在上面代码的末尾 — 实际上是在第二个 promise 返回后执行，而不是第一个 Promise.all([ … ]) 创建的 promise。还有，尽管我们没有在第二个 then(…) 后面再进行链式调用，但是它也创建了一个 promise，我们可以去观察或是使用它。关于 Promise 的链式调用会在后面详细地解释。 使用 Promises，这个 then(…) 的调用其实有两个方法，第一个方法被调用的时机是在已完成的时候 (就像我们前面使用的那样)，而另一个被调用的时机是已失败的时候： 1234567891011sum(fetchX(), fetchY()).then( // 完成时 function(sum) &#123; console.log( sum ); &#125;, // 失败时 function(err) &#123; console.error( err ); // bummer! &#125;); 如果在获取 x 或者 y 的时候出错了，又或许是在进行加运算的时候失败了，sum(…) 返回的 promise 将会是已失败的状态，并且会将 promise 已失败的值传给 then(…) 的第二个回调处理。 因为 Promises 封装了依赖时间的状态 — 等待内部的值已完成或是已失败 — 从外面看，Promise 是独立于时间的，因此 Promises 可以能通过一种可预测的方式组合起来，而不用去考虑底层的时间或者结果。 而且，一旦 Promise 的状态确定了，那么他就永远也不会改变状态了 — 在这时它会变成一个 不可改变的值 — 然后就可以在有需要的时候多次 观察 它。 实际上链式的 promises 是非常有用的： 12345678910111213141516171819function delay(time) &#123; return new Promise(function(resolve, reject)&#123; setTimeout(resolve, time); &#125;);&#125;delay(1000).then(function()&#123; console.log("after 1000ms"); return delay(2000);&#125;).then(function()&#123; console.log("after another 2000ms");&#125;).then(function()&#123; console.log("step 4 (next Job)"); return delay(5000);&#125;)// ... 调用 delay(2000) 会创建一个在 2000ms 完成的 promise，然后我们返回第一个 then(…) 的成功回调，这会导致第二个 then(…) 的 promise 要再等待 2000ms 执行。 注意：因为 Promise 一旦完成了就不能再改变状态了，所以可以安全的传递到任何地方，因为它不会再被意外或是恶意的修改。这对于在多个地方监听 Promise 的解决方案来说，尤其正确。一方不可能影响到另一方所监听到的结果。不可变听起来像是一个学术性的话题，但是它是 Promise 设计中最基础、最重要方面，不应该被忽略。 用不用 Promise？使用 Promises 最重要的一点在于能否确定一些值是否是真正的 Promise。换句话说，它的值像一个 Promise 吗？ 我们知道 Promises 是由 new Promise(…) 语句构造出来的，你可能会认为 p instanceof Promise 就能判断一个 Promise。其实，并不完全是。 主要是因为另一个浏览器窗口(比如 iframe)获取一个 Promise 的值，它拥有自己的 Promise 类，且不同于当前或其他窗口，所以使用 instance 来区分 Promise 是不准确的。 而且，一个框架或者库可以选择自己的 Promise，而不是使用 ES6 原生的 Promise 实现。事实上，你很可能会在不支持 Promise 的老式浏览器中使用第三方的 Promise 库。 吞噬异常如果在任何一个创建 Promise 或是对其结果观察的过程中，抛出了一个 JavaScript 异常错误，比如说 TypeError 或是 ReferenceError，那么这个异常会被捕获，然后它就会把 Promise 的状态变成已失败。 例如： 1234567891011121314var p = new Promise(function(resolve, reject)&#123; foo.bar(); // 对不起，`foo` 没有定义 resolve(374); // 不会执行 :(&#125;);p.then( function fulfilled()&#123; // 不会执行 :( &#125;, function rejected(err)&#123; // `err` 是 `foo.bar()` 那一行 // 抛出的 `TypeError` 异常对象。 &#125;); 如果一个 Promise 已经结束了，但是在监听结果(在 then(…) 里的回调函数)的时候发生了 JS 异常会怎么样呢？即使这个错误没有丢失，你可能也会对它的处理方式有点惊讶。除非你深入的挖掘一下：123456789101112var p = new Promise( function(resolve,reject)&#123; resolve(374);&#125;);p.then(function fulfilled(message)&#123; foo.bar(); console.log(message); // 不会执行&#125;, function rejected(err)&#123; // 不会执行 &#125;); 这看起来就像 foo.bar() 的异常真的被吞了。当然了，异常并不是被吞了。这是更深层次的问题出现了，我们没有监听到异常。p.then(…) 调用它自己会返回另一个 promise，而这个 promise 会因为 TypeError 的异常变为已失败状态。 处理未捕获的异常还有一些 更好的 办法解决这个问题。 最常见的就是给 Promise 加一个 done(…)，用来标志 Promise 链的结束。done(…) 不会创建或返回一个 Promise，所以传给 done(..) 的回调显然不会将问题报告给一个不存在的 Promise。 在未捕获异常的情况下，这可能才是你期望的：在 done(..) 已失败的处理函数里的任何异常都会抛出一个全局的未捕获异常（通常是在开发者的控制台）。 12345678910var p = Promise.resolve(374);p.then(function fulfilled(msg)&#123; // 数字不会拥有字符串的方法， // 所以会抛出一个错误 console.log(msg.toLowerCase());&#125;).done(null, function() &#123; // 如果有异常发生，它就会被全局抛出 &#125;); ES8 发生了什么？ Async/awaitJavaScript ES8 介绍了 async/await，使得我们能更简单的使用 Promises。我们将简单的介绍 async/await 会带给我们什么以及如何利用它们写出异步的代码。 所以，来让我们看看 async/await 是如何工作的。 使用 async 函数声明来定义一个异步函数。这样的函数返回一个 AsyncFunction 对象。AsyncFunction 对象表示执行包含在这个函数中的代码的异步函数。 当一个 async 函数被调用，它返回一个 Promise。当 async 函数返回一个值，它不是一个 Promise，Promise 将会被自动创建，然后它使用函数的返回值来决定状态。当 async 抛出一个异常，Promise 使用抛出的值进入已失败状态。 一个 async 函数可以包含一个 await 表达式，它会暂停执行这个函数然后等待传给它的 Promise 完成，然后恢复 async 函数的执行，并返回已成功的值。 你可以把 JavaScript 的 Promise 看作是 Java 的 Future 或是 C# 的 Task。 async/await 的目的是简化使用 promises 的写法。 让我们来看看下面的例子： 12345678// 一个标准的 JavaScript 函数function getNumber1() &#123; return Promise.resolve('374');&#125;// 这个 function 做了和 getNumber1 同样的事async function getNumber2() &#123; return 374;&#125; 同样，抛出异常的函数等于返回已失败的 promises： 123456function f1() &#123; return Promise.reject('Some error');&#125;async function f2() &#123; throw 'Some error';&#125; 关键字 await 只能使用在 async 的函数中，并允许你同步等待一个 Promise。如果我们在 async 函数之外使用 promise，我们仍然要用 then 回调函数： 1234567891011121314async function loadData() &#123; // `rp` 是一个请求异步函数 var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // 现在，两个请求都被触发, // 我们就等待它们完成。 var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;&#125;// 但，如果我们没有在 `async function` 里// 我们就必须使用 `then`。loadData().then(() =&gt; console.log('Done')); 你还可以使用 async 函数表达式的方法创建一个 async 函数。async 函数表达式的写法和 async 函数声明差不多。函数表达式和函数声明最主要的区别就是函数名，它可以在 async 函数表达式中省略来创建一个匿名函数。一个 async 函数表达式可以作为一个 IIFE（立即执行函数） 来使用，当它被定义好的时候就会执行。 它看起来是这样的： 1234567891011var loadData = async function() &#123; // `rp` 是一个请求异步函数 var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // 现在，两个请求都被触发, // 我们就等待它们完成。 var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;&#125; 最后，最重要的是不要盲目的选择“最新”的方法去写异步代码。更重要的是理解异步 JavaScript 内部的原理，知道为什么它为什么如此重要以及去理解你选择的方法的内部原理。在程序中每种方法都是有利有弊的。 5 个编写可维护的、健壮的异步代码的技巧1.干净的代码: 使用 async/await 能够让你少写代码。每一次你使用 async/await 你都能跳过一些不必要的步骤：写一个 .then，创建一个匿名函数来处理响应，在回调中命名响应，比如： 1234// `rp` 是一个请求异步函数rp(‘https://api.example.com/endpoint1').then(function(data) &#123; // …&#125;); 对比: 12// `rp` 是一个请求异步函数var response = await rp(‘https://api.example.com/endpoint1'); 错误处理: Async/await 使得我们可以使用相同的代码结构处理同步或者异步的错误 —— 著名的 try/catch 语句。让我们看看用 Async/await 是怎么实现的： 12345678async function loadData() &#123; try &#123; var data = JSON.parse(await getJSON()); console.log(data); &#125; catch(e) &#123; console.log(e); &#125;&#125; 3.条件语句: 使用 async/await 来写条件语句要简单得多： 123456789101112131415function loadData() &#123; return getJSON() .then(function(response) &#123; if (response.needsAnotherRequest) &#123; return makeAnotherRequest(response) .then(function(anotherResponse) &#123; console.log(anotherResponse) return anotherResponse &#125;) &#125; else &#123; console.log(response) return response &#125; &#125;)&#125; 对比： 1234567891011async function loadData() &#123; var response = await getJSON(); if (response.needsAnotherRequest) &#123; var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse &#125; else &#123; console.log(response); return response; &#125;&#125; 4.栈帧: 和 async/await 不同的是，根据promise链返回的错误堆栈信息，并不能发现哪出错了。来看看下面的代码： 1234567891011121314function loadData() &#123; return callAPromise() .then(callback1) .then(callback2) .then(callback3) .then(() =&gt; &#123; throw new Error("boom"); &#125;)&#125;loadData() .catch(function(e) &#123; console.log(err);// Error: boom at callAPromise.then.then.then.then (index.js:8:13)&#125;); 对比： 1234567891011121314async function loadData() &#123; await callAPromise1() await callAPromise2() await callAPromise3() await callAPromise4() await callAPromise5() throw new Error("boom");&#125;loadData() .catch(function(e) &#123; console.log(err); // 输出 // Error: boom at loadData (index.js:7:9)&#125;); 5.调试: 如果你使用了 promises，你就会知道调试它们将会是一场噩梦。比如，你在 .then 里面打了一个断点，并且使用类似 “stop-over” 这样的 debug 快捷方式，调试器不会移动到下一个 .then，因为它只会对同步代码生效。而通过 async/await 你就可以逐步的调试 await 调用了，它就像是一个同步函数一样。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript调用堆栈]]></title>
    <url>%2Fpost%2Fc0155143.html</url>
    <content type="text"><![CDATA[JavaScript 引擎JavaScript 引擎说起来最流行的当然是谷歌的 V8 引擎了， V8 引擎使用在 Chrome 以及 Node 中，下面有个简单的图能说明他们的关系： 这个引擎主要由两部分组成: 内存堆：这是内存分配发生的地方 调用栈：这是你的代码执行时的地方 运行时有些浏览器的 API 经常被使用到(比如说：setTimeout)，但是，这些 API 却不是引擎提供的。那么，他们是从哪儿来的呢？事实上这里面实际情况有点复杂。 所以说我们还有很多引擎之外的 API，我们把这些称为浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout等等。 然后我们还拥有如此流行的事件循环和回调队列。 调用栈JavaScript 是一门单线程的语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。 调用栈是一种数据结构，它记录了我们在程序中的位置。如果我们运行到一个函数，它就会将其放置到栈顶。当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情。 让我们来看一看下面的例子： 12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 当程序开始执行的时候，调用栈是空的，然后，步骤如下： 每一个进入调用栈的都称为调用帧。这能清楚的知道当异常发生的时候堆栈追踪是怎么被构造的，堆栈的状态是如何的。让我们看一下下面的代码： 12345678910function foo() &#123; throw new Error('SessionStack will help you resolve crashes :)');&#125;function bar() &#123; foo();&#125;function start() &#123; bar();&#125;start(); 如果这发生在 Chrome 里(假设这段代码实在一个名为 foo.js 的文件中)，那么将会生成以下的堆栈追踪： “堆栈溢出”，当你达到调用栈最大的大小的时候就会发生这种情况，而且这相当容易发生，特别是在你写递归的时候却没有全方位的测试它。我们来看看下面的代码： 1234function foo() &#123; foo();&#125;foo(); 当我们的引擎开始执行这段代码的时候，它从 foo 函数开始。然后这是个递归的函数，并且在没有任何的终止条件的情况下开始调用自己。因此，每执行一步，就会把这个相同的函数一次又一次地添加到调用堆栈中。然后它看起来就像是这样的： 然后，在某一时刻，调用栈中的函数调用的数量超过了调用栈的实际大小，浏览器决定干掉它，抛出一个错误，它看起来就像是这样: 在单个线程上运行代码很容易，因为你不必处理在多线程环境中出现的复杂场景——例如死锁。但是在一个线程上运行也非常有限制。由于 JavaScript 只有一个调用堆栈，当某段代码运行变慢时会发生什么? 并发与事件循环调用栈中的函数调用需要大量的时间来处理，那么这会发生什么情况呢?例如，假设你想在浏览器中使用 JavaScript 进行一些复杂的图片转码。 你可能会问？这算什么问题？事实上，问题是当调用栈有函数要执行，浏览器就不能做任何事，它会被堵塞住。这意味着浏览器不能渲染，不能运行其他的代码，它被卡住了。如果你想在应用里让 UI 很流畅的话，这就会产生问题。 而且这不是唯一的问题，一旦你的浏览器开始处理调用栈中的众多任务，它可能会停止响应相当长一段时间。大多数浏览器都会这么做，报一个错误，询问你是否想终止 web 页面。 这样看来，这并不是最好的用户体验，不是吗？那么，如何在不阻塞 UI 的情况下执行复杂的代码，让浏览器不会不响应?解决方案就是异步回调。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 执行机制]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的。 javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，通常采用异步加载，就是异步任务。关于这部分有严格的文字定义，在这里用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册回调函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 代码演示123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log('发送成功!'); &#125;&#125;)console.log('代码执行结束'); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(‘代码执行结束’)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 通过上面的文字和代码，已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 setTimeoutsetTimeout的作用可以延时执行代码，我们经常这么实现延时3秒执行： 123setTimeout(() =&gt; &#123; console.log('延时3秒')&#125;, 3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，跟所设定的时间不一样？先看一个例子: 1234setTimeout(() =&gt; &#123; task();&#125;,3000)console.log('执行console'); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码 12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明:12345//代码1console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,0); 12345//代码2console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,3000); 代码1的输出结果是:12//先执行这里//执行啦 代码2的输出结果是：123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 setInterval循环的执行代码。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行第一次宏任务中所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束 事件循环，宏任务，微任务的关系如图所示: 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3 宏任务Event Queue 微任务Event Queue process3 process3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 写在最后js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 最后 javascript是一门单线程语言 Event Loop是javascript的执行机制]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
