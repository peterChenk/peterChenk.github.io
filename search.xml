<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原生javascript相关问题总结]]></title>
    <url>%2Fpost%2Ff76aca3e.html</url>
    <content type="text"><![CDATA[new 的过程和实现12345678function myNew (Parent, ...rest) &#123; // 1. 以构造函数的prototype属性为原型，创建新对象 let child = Object.create(Parent.prototype) // 将新对象的__proto__指向Parent.prototype obj.__proto__ = Parent.prototype // 2. 执行构造函数，并将this执行新对象(将this和调用参数传给构造器执行) let result = Parent.apply(child, rest) // 3. 如果构造器没有手动返回对象，则返回第一步的对象 return typeof result === 'object' ? result : child;&#125; 优先级问题优先级由高到低：小括号(xxx) &gt; 属性访问. &gt; new foo() &gt; foo()12345678910111213141516171819202122232425function getName () &#123; console.log(1)&#125;function Foo () &#123; this.getName = function () &#123; console.log(2) &#125; console.log('123', this) return this&#125;Foo.getName = function () &#123; console.log(3)&#125;//先从.属性访问符号开始往前面找一个最近的对象，同时注意new Foo()优先于Foo();var a = new Foo.getName();//3;// 属性.的优先级高于new foo()，所以===new (Foo.getName)();返回Foo.getName类型的实例var b = new Foo().getName() // 2 new foo()的优先级高于foo()，所以就相当于new foo()的属性，===(new Foo()).getName()；返回Foo.getName类型的实例var c = new new Foo().getName() //2// new foo()优先级低于属性.，所以其实相当于就是new一个new foo()的getName属性函数，===new (new Foo().getName)();返回undefinednew Date().getTime();//===((new Date()).getTime)()(new Date).getTime();//===((new Date()).getTime)()new Date.getTime();//Uncaught TypeError: Date(...).getTime is not a function；===new (Date.getTime)() JavaScript中call、apply、bindJavaScript中this关键字的理解this的基本概念： this指的是函数运行时所在的环境，当前执行函数的上下文，具体值和函数的调用方式有关。this绑定的规则 默认绑定 隐式绑定 硬绑定 new绑定 默认绑定默认绑定是在不能应用其他绑定规则时使用的默认规则，通常是独立函数调用。12345function sayHi () &#123; console.log('Hello', this.name)&#125;var name = 'abc'sayHi(); 在调用Hi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。 上面的代码，如果在浏览器环境中运行，那么结果就是 Hello,abc 但是如果在node环境中运行，结果就是 Hello,undefined.这是因为node中name并不是挂在全局对象上的。 隐式绑定函数调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为XXX.fun()123456789function sayHi () &#123; console.log('Heollo', this.name)&#125;var person = &#123; name: 'abc', sayHi: sayHi&#125;var name = 'bcd'person.sayHi() 打印的结果是 Hello,abc. sayHi函数声明在外部，严格来说并不属于person，但是在调用sayHi时,调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this(即此例sayHi函数中的this)绑定到这个上下文对象（即此例中的person） 需要注意的是：对象属性链中只有最后一层会影响到调用位置。123456789101112function sayHi()&#123; console.log('Hello,', this.name);&#125;var person2 = &#123; name: 'Christina', sayHi: sayHi&#125;var person1 = &#123; name: 'YvetteLau', friend: person2&#125;person1.friend.sayHi(); 结果是：Hello, Christina. 因为只有最后一层会确定this指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的friend。 隐式绑定有一个大陷阱，绑定很容易丢失(或者说容易给我们造成误导，我们以为this指向的是什么，但是实际上并非如此).12345678910function sayHi()&#123; console.log('Hello,', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = person.sayHi;Hi(); 结果是: Hello,Wiliam. 这是为什么呢，Hi直接指向了sayHi的引用，在调用的时候，跟person没有半毛钱的关系，针对此类问题，我建议大家只需牢牢继续这个格式:XXX.fn();fn()前如果什么都没有，那么肯定不是隐式绑定。 除了上面这种丢失之外，隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子:123456789101112131415161718192021function sayHi()&#123; console.log('Hello,', this.name);&#125;var person1 = &#123; name: 'YvetteLau', sayHi: function()&#123; setTimeout(function()&#123; console.log('Hello,',this.name); &#125;) &#125;&#125;var person2 = &#123; name: 'Christina', sayHi: sayHi&#125;var name='Wiliam';person1.sayHi();setTimeout(person2.sayHi,100);setTimeout(function()&#123; person2.sayHi();&#125;,200); 结果为:123Hello, WiliamHello, WiliamHello, Christina 第一条输出很容易理解，setTimeout的回调函数中，this使用的是默认绑定，非严格模式下，执行的是全局对象 第二条输出是不是有点迷惑了？说好XXX.fun()的时候，fun中的this指向的是XXX呢，为什么这次却不是这样了！Why? 其实这里我们可以这样理解: setTimeout(fn,delay){ fn(); },相当于是将person2.sayHi赋值给了一个变量，最后执行了变量，这个时候，sayHi中的this显然和person2就没有关系了。 第三条虽然也是在setTimeout的回调中，但是我们可以看出，这是执行的是person2.sayHi()使用的是隐式绑定，因此这是this指向的是person2，跟当前的作用域没有任何关系。 显示绑定显式绑定比较好理解，就是通过call,apply,bind的方式，显式的指定this所指向的对象。(注意:《你不知道的Javascript》中将bind单独作为了硬绑定讲解了) all,apply和bind的第一个参数，就是对应函数的this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。12345678910function sayHi()&#123; console.log('Hello,', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = person.sayHi;Hi.call(person); //Hi.apply(person) 输出的结果为: Hello, YvetteLau. 因为使用硬绑定明确将this绑定在了person上。 那么，使用了硬绑定，是不是意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，继续往下看。123456789101112function sayHi()&#123; console.log('Hello,', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = function(fn) &#123; fn();&#125;Hi.call(person, person.sayHi) 输出的结果是 Hello, Wiliam. 原因很简单，Hi.call(person, person.sayHi)的确是将this绑定到Hi中的this了。但是在执行fn的时候，相当于直接调用了sayHi方法(记住: person.sayHi已经被赋值给fn了，隐式绑定也丢了)，没有指定this的值，对应的是默认绑定。 现在，我们希望绑定不会丢失，要怎么做？很简单，调用fn的时候，也给它硬绑定。123456789101112function sayHi()&#123; console.log('Hello,', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = function(fn) &#123; fn.call(this);&#125;Hi.call(person, person.sayHi); 此时，输出的结果为: Hello, YvetteLau，因为person被绑定到Hi函数中的this上，fn又将这个对象绑定给了sayHi的函数。这时，sayHi中的this指向的就是person对象。 new 绑定 javaScript和Ｃ＋＋不一样，并没有类，在javaScript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例化出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。 使用new来调用函数，会自动执行下面的操作： 创建一个新对象 将构造函数的作用域赋值给新对象，即this指向这个新对象 执行构造函数中的代码 返回对象 因此，我们使用new来调用函数的时候，就会新对象绑定到这个函数的this上。但是前提是构造函数中没有返回对象或者是function，否则this指向这个对象或者是function 123456function sayHi(name)&#123; this.name = name; &#125;var Hi = new sayHi('Yevtte');console.log('Hello,', Hi.name); 输出结果为 Hello, Yevtte, 原因是因为在var Hi = new sayHi(‘Yevtte’);这一步，会将sayHi中的this绑定到Hi对象上。 绑定优先级 我们知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？ 显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为: new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 这个规则时如何得到的，大家如果有兴趣，可以自己写个demo去测试，或者记住上面的结论即可。 绑定例外 凡事都有例外，this的规则也是这样。 如果我们将null或者是undefined作为this的绑定对象传入call、apply或者是bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。 12345678var foo = &#123; name: 'Selina'&#125;var name = 'Chirs';function bar() &#123; console.log(this.name);&#125;bar.call(null); //Chirs 输出的结果是 Chirs，因为这时实际应用的是默认绑定规则。 箭头函数 箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用时，需要注意以下几点: 函数体内的this对象，继承的是外层代码块的this。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向。 12345678910111213141516171819202122232425var obj = &#123; hi: function()&#123; console.log(this); return ()=&gt;&#123; console.log(this); &#125; &#125;, sayHi: function()&#123; return function() &#123; console.log(this); return ()=&gt;&#123; console.log(this); &#125; &#125; &#125;, say: ()=&gt;&#123; console.log(this); &#125;&#125;let hi = obj.hi(); //输出obj对象hi(); //输出obj对象let sayHi = obj.sayHi();let fun1 = sayHi(); //输出windowfun1(); //输出windowobj.say(); //输出window obj.hi(); 对应了this的隐式绑定规则，this绑定在obj上，所以输出obj，很好理解。 hi(); 这一步执行的就是箭头函数，箭头函数继承上一个代码库的this，刚刚我们得出上一层的this是obj，显然这里的this就是obj. 执行sayHi();这一步也很好理解，我们前面说过这种隐式绑定丢失的情况，这个时候this执行的是默认绑定，this指向的是全局对象window. fun1(); 这一步执行的是箭头函数，如果按照之前的理解，this指向的是箭头函数定义时所在的对象，那么这儿显然是说不通。OK，按照箭头函数的this是继承于外层代码库的this就很好理解了。外层代码库我们刚刚分析了，this指向的是window，因此这儿的输出结果是window. obj.say(); 执行的是箭头函数，当前的代码块obj中是不存在this的，只能往上找，就找到了全局的this，指向的是window. 箭头函数的this是静态的？12345678910111213141516171819202122232425var obj = &#123; hi: function()&#123; console.log(this); return ()=&gt;&#123; console.log(this); &#125; &#125;, sayHi: function()&#123; return function() &#123; console.log(this); return ()=&gt;&#123; console.log(this); &#125; &#125; &#125;, say: ()=&gt;&#123; console.log(this); &#125;&#125;let sayHi = obj.sayHi();let fun1 = sayHi(); //输出windowfun1(); //输出windowlet fun2 = sayHi.bind(obj)();//输出objfun2(); //输出obj 可以看出，fun1和fun2对应的是同样的箭头函数，但是this的输出结果是不一样的。 所以，请大家牢牢记住一点: 箭头函数没有自己的this，箭头函数中的this继承于外层代码库中的this. 1. 如何准确判断this指向的是什么？ 函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。 函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。 函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo() 如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。 如果把Null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 如果是箭头函数，箭头函数的this继承的是外层代码块的this。 2. 执行过程解析 123456789101112131415161718192021var number = 5;var obj = &#123; number: 3, fn: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125; &#125;)()&#125;var myFun = obj.fn;myFun.call(null);obj.fn();console.log(window.number); 在定义obj的时候，fn对应的闭包就执行了，返回其中的函数，执行闭包中代码时，显然应用不了new绑定(没有出现new 关键字)，硬绑定也没有(没有出现call,apply,bind关键字),隐式绑定有没有？很显然没有，如果没有XX.fn()，那么可以肯定没有应用隐式绑定，所以这里应用的就是默认绑定了，非严格模式下this绑定到了window上(浏览器执行环境)。【这里很容易被迷惑的就是以为this指向的是obj，一定要注意，除非是箭头函数，否则this跟词法作用域是两回事，一定要牢记在心】 12345window.number * = 2; //window.number的值是10(var number定义的全局变量是挂在window上的)number = number * 2; //number的值是NaN;注意我们这边定义了一个number，但是没有赋值，number的值是undefined;Number(undefined)-&gt;NaNnumber = 3; //number的值为3 myFun.call(null);我们前面说了，call的第一个参数传null，调用的是默认绑定;1234567fn: function()&#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number);&#125; 执行时:12345var num = this.number; //num=10; 此时this指向的是windowthis.number * = 2; //window.number = 20console.log(num); //输出结果为10number *= 3; //number=9; 这个number对应的闭包中的number;闭包中的number的是3console.log(number); //输出的结果是9 obj.fn();应用了隐式绑定，fn中的this对应的是obj12345var num = this.number;//num = 3;此时this指向的是objthis.number *= 2; //obj.number = 6;console.log(num); //输出结果为3;number *= 3; //number=27;这个number对应的闭包中的number;闭包中的number的此时是9console.log(number); //输出的结果是27 4.最后一步console.log(window.number);输出的结果是20 因此组中结果为:1234510932720]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css相关问题总结]]></title>
    <url>%2Fpost%2Fe7919f0c.html</url>
    <content type="text"><![CDATA[BFC一、什么是BFCFormatting context 是W3C css2.1规范中的一个概念。它是页面中的的一块渲染区域，并且有一套渲染规则，它决定了其子元素该如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context有 Block Formatting context（简称BFC）以及Inline Formatting context（简称IFC）。BFC直译“块级格式化上下文”，它是一个独立的渲染区域，只有block-level box参与，它规定了block-level box内部如何布局，并且与这个区域外部毫不相干。通俗的讲，BFC是一个容器，用于管理块级元素。 二、如何创建BFC float为 left|right overflow为 hidden|auto|scroll display: table-cell|table-caption|inline-block|inline-flex|flex position: absolute|fixed 跟元素 三、BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置（即块级元素独占一行）。 BFC的区域不会与float box重叠（利用这一点可以实现自适应两栏布局）。 内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（margin重叠的三个条件：同属于一个BFC；相邻；块级元素）。 计算BFC的高的时，浮动元素也参与计算。（清除浮动 haslayout）。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。 四、 BFC有哪些特性特性1：BFC会阻止垂直外边距折叠 按照BFC的定义，只有属于同一个BFC时，两个元素才有可能发生垂直margin的重叠，这个包括相邻元素或嵌套元素，只有他们之前没有阻挡（比如边框、非空内容、padding等）就会发生margin重叠。 ①相邻兄弟元素margin重叠问题1234567891011121314&lt;style&gt;p&#123; color: #fff; background: #888; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;ABC&lt;/p&gt; &lt;p&gt;abc&lt;/p&gt;&lt;/body&gt; 上面例中两个P元素之间距离本该为200px,然而实际上只有100px,发生了margin重叠。遇到这种情形，我们如何处理？ 只需要在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 12345678910111213141516171819&lt;style&gt;p&#123; color: #fff; background: #888; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;.wrap&#123; overflow:hidden;&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;ABC&lt;/p&gt; &lt;div class="wrap"&gt; &lt;p&gt;abc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; ②父子元素margin重叠问题 1234567891011121314151617181920&lt;style&gt;.box&#123;width:100px;height:100px;background:#ccc;&#125;.wrap &#123; background:yellow;&#125;.wrap h1&#123; background:pink; margin:40px;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="box"&gt;box&lt;/div&gt;&lt;div class="wrap"&gt; &lt;h1&gt;h1&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; 上图wrap元素与h1元素之间l理论上本该有个40px的上下margin值,然而实际上父子元素并没有存在margin值，与此同时，两个div元素的间距为40px。遇到这种情形，我们如何处理？ 处理方法其实有很多，在wrap元素中添加:overflow:hidden;或者overflow：auto；使其父元素形成一个BFC；也可以在wrap元素中添加border：1px solid；或是padding：1px；这些都可以有效解决父子元素margin重叠问题。 特性2：BFC不会重叠浮动元素 利用这个特性，我们可以创造自适应两栏布局。 上图中，文字围绕着浮动元素排列，不过在这里，这显然不是我们想要的。此时我们可以为.box2元素的样式加上overflow:hidden；使其建立一个BFC,让其内容消除对外界浮动元素的影响。 这个方法可以用来实现两列自适应布局，效果不错，此时左边的宽度固定，右边的内容自适应宽度。如果我们改变文字的大小或者左边浮动元素的大小，两栏布局的结构依然没有改变！ 特性3：BFC可以包含浮动—-清除浮动 我们都知道浮动会脱离文档流，接下来我们看看下面的例子：1234567891011121314151617181920212223&lt;style&gt;.box1&#123; width:100px; height:100px; float:left; border: 1px solid #000;&#125;.box2&#123; width:100px; height:100px; float:left; border: 1px solid #000;&#125;.box&#123; background:yellow&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt; 由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。 flex一、Flex概念flex Flexible Box “弹性布局”，设为Flex布局以后，子元素的float、clear和vertical-aline的属性将会失效。任何一个容器都可以指定为flex布局，采用flex布局的容器称为Flex容器（flex container），简称“容器”，它所有的子元素自动成为容器成员，成为flex项目，简称项目“项目”。 二、常用属性 以下6个属性设置在容器上12345flex-direction (决定主轴方向，即项目的排列方向)flex-warp（如果一条轴线排不下，如何换行）flex-flow（以上两种的简写形式，默认值row nowarp）justify-content（定义项目在主轴的对齐方式）align-content（定义多跟轴的对齐，如果项目只有一根轴线，该属性不起作用） （1）flex-direction属性 决定主轴的方向（即项目的排列方向） row（默认值）：主轴水平方向，起点在左端 row-reverse：主轴在水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse；主轴为垂直方向，起点在下沿123.box &#123; flex-direction: column-reverse | column | row | row-reverse&#125; (2) flex-wrap属性 默认情况下，项目都排在一条线（又称“轴线”）上，flex-wrap属性定义，如果一天轴线排不下，如何换行 nowrap: (默认值)，不换行 wrap: 换行，第一行在上方 warp-reverse: 换行，第一行在下方 123.box &#123; flex-wrap: nowrap | wrap | wrap-reverse&#125; (3) flex-flow 属性 flex-flow 是flex-direction 和 flex-wrap的缩写123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;&#125; (4) justify-content 属性定义了项目在主轴上的对齐方式 flex-start: (默认值) 左对齐 flex-end: 右对齐 center: 居中 space-between: 两端对齐，项目之前间隔相等 space-around: 每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍。 123.box &#123; jsutify-content: flex-start | flex-end | center | space-between | space-around&#125; (5) align-items 属性 align-items定义了项目在主轴如何对齐 flex-start: 交叉轴的起点对齐 flex-end: 交叉轴的终点对齐 center: 交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐 stretch: （默认值）如果项目为设置高度或者设置auto，将占满整个容器的高度 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch&#125; (6) align-content 属性 align-content属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用 flex-start: 交叉轴的起点对齐 flex-end: 交叉轴的终点对齐 center: 与交叉轴的中点对齐 space-between: 与交叉轴的两端对齐，轴线之间的间隔平均分布 space-around: 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch: (默认值) 轴线占满整个交叉轴。 123.box&#123; align-content: flex-start | flex-end | center | space-between | sapce-around | stretch&#125; 3.以下6个属性设置在项目上 123456order (定义项目的排列顺序，数值越小，排列越靠前，默认值为0)flex-grow (定义项目的放大比例,默认0)flex-shrink (定义项目的缩小比例，默认1，即如果项目空间不足，该项目将缩小，负值无效)flex-basis (定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。)flex (flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选)align-self (align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch) 水平居中1) 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中. 2) 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央.12345678.parent::after, .son&#123; display:inline-block; vertical-align:middle;&#125;.parent::after&#123; content:''; height:100%;&#125; 元素高度不定 3) 可用 vertical-align 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle; 优点 元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断. 缺点 IE6~7, 甚至IE8 beta中无效. 4) 可用 Flex 2012版, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《弹性盒模型Flex指南》1234.parent &#123; display: flex; align-items: center;&#125; 优点 内容块的宽高任意, 优雅的溢出. 可用于更复杂高级的布局技术中. 缺点 IE8/IE9不支持 需要浏览器厂商前缀 渲染上可能会有一些问题 5) 可用 transform , 设置父元素相对定位(position:relative), 子元素如下css样式:1234567.son&#123; position:absolute; top:50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; 优点 代码量少 缺点 IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象. 总结 水平居中较为简单, 共提供了8种方法, 一般情况下 text-align:center,marin:0 auto; 足矣 ① text-align:center; ② margin:0 auto; ③ width:fit-content; ④ flex ⑤ 盒模型 ⑥ transform ⑦ ⑧ 两种不同的绝对定位方法 垂直居中, 共提供了8种方法 ① 单行文本, line-height ② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现 ③ vertical-align ④ flex ⑤ 盒模型 ⑥ transform ⑦ ⑧ 两种不同的绝对定位方法 圣杯布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188一、table&lt;button class="button1"&gt;主体内容上添加内容&lt;/button&gt;&lt;div class="wrapper"&gt; &lt;div class="header"&gt;头部&lt;/div&gt; &lt;div class="main"&gt; &lt;div class="box sidebar"&gt;左侧栏&lt;/div&gt; &lt;div class="box content"&gt;主体内容&lt;/div&gt; &lt;div class="box sidebar"&gt;有侧栏&lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt;页脚底部&lt;/div&gt;&lt;/div&gt;body &#123; background: @beige; color: black;&#125;.wrapper &#123; height: 100%; display: table; width: 100%; text-align: center;&#125;.header &#123; display: table-row; height: 1px; background: @yellow;&#125;.main &#123; height: 100%; display: table; width: 100%;&#125;.box &#123; display: table-cell;&#125;.sidebar &#123; width: 100px; background: @orange;&#125;.footer &#123; display: table-row; height:1px; background: @green; color: @beige;&#125;/*====== Ignore section below ======*/@orange: #BD4932;@yellow: #FFD34E;@green: #105B63;@beige: #FFFAD5;二、felx&lt;div class='container'&gt; &lt;header&gt;头部&lt;/header&gt; &lt;section&gt; &lt;div class='left'&gt;左&lt;/div&gt; &lt;div class='center'&gt;中&lt;/div&gt; &lt;div class='right'&gt;右&lt;/div&gt; &lt;/section&gt; &lt;footer&gt;底部&lt;/footer&gt;&lt;/div&gt;&lt;style&gt; *&#123; margin:0;padding:0; &#125; .container&#123; display: flex; height: 100vh; flex-direction: column; &#125; header&#123; background: #000; &#125; section&#123; flex:1; background: pink; display: flex; &#125; footer&#123; background: #000; &#125; .left&#123; background: red; flex:0 0 100px; &#125; .center&#123; flex:1; background: blue; &#125; .right&#123; flex:0 0 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;三、float &lt;div class="main"&gt; &lt;div class="center"&gt;中间&lt;/div&gt; &lt;div class="left"&gt;左边&lt;/div&gt; &lt;div class="right"&gt;右边&lt;/div&gt; &lt;/div&gt;&lt;style type="text/css"&gt; *&#123; margin: 0; padding: 0; color: black; font-size: 45px &#125; .main&gt;div&#123; float: left; &#125; .main&#123; width: 100%; background: yellow &#125; .center&#123; background: red; margin-left: 200px; margin-right: -200px; width: 100% &#125; .left&#123; background: pink ; width: 200px; margin-left: -100% &#125; .right&#123; background: blue ; width: 200px; margin-right: -200px &#125; &lt;/style&gt;四、position&lt;style type="text/css"&gt; *&#123; margin: 0; padding: 0; color: black; font-size: 45px &#125; .main div&#123; box-sizing: border-box; &#125; .main&#123; width: 100%; background: red; position: relative; padding-left: 200px; padding-right: 200px; &#125; .center&#123; width: 100%; background: pink &#125; .left&#123; background: yellow ; width: 200px; position: absolute; left: 0; top: 0; &#125; .right&#123; background: blue ; width: 200px; position: absolute; top: 0; right:0 &#125;&lt;/style&gt;&lt;div class="main"&gt; &lt;div class="center"&gt;z中间&lt;/div&gt; &lt;div class="left"&gt;左&lt;/div&gt; &lt;div class="right"&gt;右&lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx基本知识]]></title>
    <url>%2Fpost%2Fb48e920a.html</url>
    <content type="text"><![CDATA[什么是nginxnginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写。 正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。 不管是正向代理还是反向代理，实现的都是上面的功能。 正向代理正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。### 基本配置配置结构下面是一个nginx配置文件的基本结构： 123456789101112131415161718192021222324events &#123; &#125;http &#123; server &#123; location path &#123; ... &#125; location path &#123; ... &#125; &#125; server &#123; ... &#125;&#125; main: nginx的全局配置，对全局生效。 events: 配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 内置变量 下面是nginx一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。 变量名 功能 $host 请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名 $request_method 客户端请求类型，如GET、POST $remote_addr 客户端的IP地址 $args 请求中的参数 $content_length 请求头中的Content-length字段 $http_user_agent 客户端agent信息 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如HTTP/1.0、·HTTP/1.1` $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 解决跨域 前端server的域名为：fe.server.com 后端服务的域名为：dev.server.com 现在我在fe.server.com对dev.server.com发起请求一定会出现跨域。 现在我们只需要启动一个nginx服务器，将server_name设置为fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置： 1234567891011server &#123; listen 80; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125; location /douban &#123; rewrite ^/douban/(.*)$ /$1 break; proxy_pass https://api.douban.com; &#125;&#125; 这样可以完美绕过浏览器的同源策略：fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。 ###f 请求过滤根据状态码过滤 12345error_page 500 501 502 503 504 506 /50x.html;location = /50x.html &#123; #将跟路径改编为存放html的路径。 root /root/static/html;&#125; 根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。 123location / &#123; rewrite ^.*$ /index.html redirect;&#125; 根据请求类型过滤。 123if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 403; &#125; 负载均衡什么是负载均衡 负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。 nginx如何实现负载均衡 Upstream指定后端服务器地址列表 12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。 1234567server &#123; server_name fe.server.com; listen 80; location /api &#123; proxy_pass http://balanceServer; &#125;&#125; 上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。 nginx实现负载均衡的策略 轮询策略 默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。 12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最小连接数策略 将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。 upstream balanceServer { least_conn; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;} 最快响应时间策略 依赖于NGINX Plus，优先分配给响应时间最短的服务器。 upstream balanceServer { fair; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;} 客户端ip绑定 来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题。123456upstream balanceServer &#123; ip_hash; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 静态资源服务器123456location ~* \.(png|gif|jpg|jpeg)$ &#123; root /root/static/; autoindex on; access_log off; expires 10h;# 设置过期时间为10小时 &#125; 匹配以png|gif|jpg|jpeg为结尾的请求，并将请求转发到本地路径，root中指定的路径即nginx本地路径。同时也可以进行一些缓存的设置。 控制浏览器的缓存 浏览器缓存简介 浏览器缓存遵循HTTP协议定义的缓存机制（如：Expires;Cache-control等）。 当浏览器请求响应流程 浏览器缓存效验机制 校验是否过期 Cache-Control(max-age) Expires 协议中Etag头信息校验 Etag Last-Modified头信息校验 Last-Modified Nginx控制浏览器缓存配置 Nginx通过添加Cache-Control(max-age)、Expires头信息的方式控制浏览器缓存。 “Expires”头信息中的过期时间为当前系统时间与您设定的 time 值时间的和。如果指定了 modified 参数，则过期时间为文件的最后修改时间与您设定的 time 值时间的和。“Cache-Control”头信息的内容取决于指定 time 的符号。可以在time值中使用正数或负数。当 time 为负数，“Cache-Control: no-cache”;当 time 为正数或0，“Cache-Control: max-age=time”，单位是秒。 epoch 参数用于指定“Expires”的值为 1 January, 1970, 00:00:01 GMT。max 参数用于指定“Expires”的值为 “Thu, 31 Dec 2037 23:55:55 GMT”，“Cache-Control” 的值为10 年。off 参数令对“Expires” 和 “Cache-Control”响应头信息的添加或修改失效。 应用实例 (编辑nginx的配置文件) 12345671. server &#123; location ~ .*\.(jpg|xml|html|png|css|js|jpg)$ &#123; # 设置过期时间为12小时 expires 12h; root /vagrant/doc; &#125;&#125; nginx -s reload 重新载入nginx配置文件 创建 /var/www/html/1.jpg 通过curl访问 192.168.233.130/1.jpg，查看http响应头信息 二、防盗链 目的：防止资源被盗用,静态资源在外部服务请求 基于http_refer防盗链配置模块 ngx_http_referer_module none：请求头中没有 Referer 字段blocked：请求头中虽然存在“Referer”字段，但是它的值已经被防火墙或代理服务器删除；这些值是不以“http://”或“https://”开头的字符串;server_names：“Referer”请求头字段包含该服务器名称任意字符串：定义一个服务器名称和一个可选的URI前缀。服务器名开始或结尾可以有 “*” 。检查时，“Referer”字段中的服务器端口会被忽略。正则表达式：字符串必须以 ~ 开头，值得注意的是，正则表达式匹配的是在“http://”或“https://”之后的内容。 应用实例 12345678910server &#123; location ~* \.(gif|jpg|png|bmp)$ &#123; valid_referers none blocked *.xxx.com server_names ~\.google\. ~\.baidu\.; if ($invalid_referer) &#123; return 403; #rewrite ^/ http://www.xxx.com/403.jpg; &#125; &#125;&#125; 配置说明：以上所有来至xxx.com和域名中包含google和baidu的站点都可以访问到当前站点的图片如果来源域名不在这个列表中，那么$invalid_referer等于1，在if语句中返回一个403给用户，这样用户便会看到一个403的页面；如果使用下面的rewrite，那么盗链的图片都会显示403.jpg；如果用户直接在浏览器输入你的图片地址,那么图片显示正常，因为它符合none这个规则. 第一行：表示对gif|jpg|png|bmp后缀的文件实行防盗链第二行：表示对.xxx.com和xxx.com这2个来路进行判断(代表任何，任何的二级域名)，可以添加更多if{}里面内容的意思是，如果来路不是指定来路就跳转到403错误页面，当然直接返回404也是可以的，也可以是图片。 第四行：rewrite ^/ http://www.xxx.com/404.jpg;这个图片是盗链返回的图片，也就是替换盗链网站所有盗链的图片。这个图片要放在没有设置防盗链的网站上，因为防盗链的作用，这个图片如果也放在防盗链网站上就会被当作防盗链显示不出来了，盗链者的网站所盗链图片会显示X符号。 nginx -s reload 重新载入nginx配置文件 测试 使用浏览器直接访问可以 通过别的服务器请求访问返回403 如果打开rewirte 会自动跳转到404.jpg 去掉 none blocked 则图片地址也不能使用浏览器直接访问 参考： 原文地址]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常用css效果]]></title>
    <url>%2Fpost%2F695bddcf.html</url>
    <content type="text"><![CDATA[Sticky Footer什么是 “Sticky Footer”所谓 “Sticky Footer”，它指的就是一种网页效果： 如果页面内容不足够长时，页脚固定在浏览器窗口的底部；如果内容足够长时，页脚固定在页面的最底部。但如果网页内容不够长，置底的页脚就会保持在浏览器窗口底部。 实现方法 将内容部分的底部外边距设为负数这是个比较主流的用法，把内容部分最小高度设为100%，再利用内容部分的负底部外边距值来达到当高度不满时，页脚保持在窗口底部，当高度超出则随之推出的效果。 这个方法需要容器里有额外的占位元素（如 .push） 需要注意的是 .wrapper的margin-bottom值需要和 .footer的负的height值保持一致，这一点不太友好。 将页脚的顶部外边距设为负数既然能在容器上使用负的margin bottom，那能否使用负margin top吗？当然可以。 给内容外增加父元素，并让内容部分的底部内边距与页脚高度的值相等。 不过这种方法和上一种一样，都需要额外添加不必要的html元素。 使用flexbox弹性盒布局 以上两种种方法的footer高度都是固定的，通常来说这不利于网页布局：内容会改变，它们都是弹性的，一旦内容超出固定高度就会破坏布局。所以给footer使用flexbox吧，让它的高度可以变大变小 你还可以在上面添加header或在下面添加更多元素。可从以下技巧选择其一： flex:1 使内容（如： .content）高度可以自由伸缩 margin-top:auto absolute 通过绝对定位处理应该是常见的方案，只要使得页脚一直定位在主容器预留占位位置 这个方案需指定 html、body 100% 的高度，且 content 的 padding-bottom 需要与 footer 的 height 一致。 calc通过计算函数 calc 计算（视窗高度 - 页脚高度）赋予内容区最小高度，不需要任何额外样式处理，代码量最少、最简单。 table通过 table 属性使得页面以表格的形态呈现。 需要注意的是，使用 table 方案存在一个比较常见的样式限制，通常 margin、padding、border 等属性会不符合预期。 笔者不建议使用这个方案。当然，问题也是可以解决的：别把其他样式写在 table 上。 使用Grid网格布局grid比flexbox还要新很多，并且更佳很简洁 遗憾的是，网格布局（Grid layout）目前仅支持Chrome Canary和Firefox Developer Edition版本。 移动端Html5页面中1px边框问题移动端1px变粗的原因 为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解:这2个’px’ 的含义是不一样的.css中设置的像素并不是跟设备的像素点一一对应，这就是说，我在css中写明1px，实际在手机上，看到的有可能并不是一个像素点占据的宽度.css的像素是一个抽象的相对的概念，在不同的设备和环境中，所表示的物理像素点是不一样的，在比较老的设备上，屏幕像素密度比较低，这样，确实一个1px的像素就是一个物理像素，但是技术飞速发展，现在的手机屏幕都是高分辨率，在尺寸未变化的情况下，一个屏幕上将充满着更多的像素点，这时一个css的像素(通常称为逻辑像素)将对应多个物理像素点。那到底一个css的像素宽度上对应多少个物理像素点呢？这就要提到devicePixelRatio（设备像素比）devicePixelRatio = 设备上物理像素/独立像素，可以通过window.devicePixelRatio获取，这个像素比恰好可以描述一个css的像素宽度上对应多少个物理像素点，其实就是对应devicePixelRatio个像素点。当viewport的属性initial-scale为1时，页面大小正常，但initial-scale为0.5时，页面被缩小了1倍，devicePixelRatio为2的设备本来1个CSS像素宽度占2个物理像素宽度，缩小后的1个CSS像素宽度就只占1个物理像素，即实现了真正的1物理像素。 解决方法一：伪类+transform把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。 1234&lt;ul class="hairlines"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526272829* &#123; margin: 0; padding: 0;&#125;ul, li&#123; list-style: none;&#125;.hairlines &#123; width: 300px; margin: 100px auto;&#125;.hairlines li&#123; position: relative; border:none; margin-top: 10px;&#125;.hairlines li:after&#123; content: ''; position: absolute; left: 0; bottom: 0; background: #cccccc; width: 100%; height: 1px; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125; 几个问题： 1.为什么是scaleY(0.5)？这个0.5是怎么得出的？是不是所有机型都是要scale缩小到一半，换句话说是不是通用？ 2.如果我要同时画一个容器的四个边框怎么办？ 3.支不支持圆角边框？ 后两个问题改造一下上面的代码，可以找到解决方法(为了方便查看效果，我把平时写法得出的效果和使用伪类得出的效果放一起，这样更容易看出差别)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, width=device-width"&gt; &lt;title&gt;移动端1px边框问题&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, li&#123; list-style: none; &#125; .lines &#123; width: 200px; margin: 0 auto; &#125; .lines li &#123; border: 1px solid #cccccc; height: 50px; line-height: 50px; text-align: center; border-radius: 13px; margin-top: 10px; &#125; .hairlines &#123; width: 200px; margin: 0 auto; border-radius: 3px; &#125; .hairlines li&#123; height: 50px; line-height: 50px; border:none; text-align: center; position: relative; margin-top: 10px; &#125; .hairlines li:after&#123; content: ''; position: absolute; left: 0; top: 0; border: 1px solid #cccccc; border-radius: 26px; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;粗线&lt;ul class="lines"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;细线&lt;ul class="hairlines"&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 那么“1.为什么是scaleY(0.5)？这个0.5是怎么得出的？是不是所有机型都是要scale缩小到一半，换句话说是不是通用？”这个问题该怎么回答呢？ 当viewport的属性initial-scale为1时，页面大小正常，但initial-scale为0.5时，页面被缩小了1倍，devicePixelRatio为2的设备本来1个CSS像素宽度占2个物理像素宽度，缩小后的1个CSS像素宽度就只占1个物理像素，即实现了真正的1物理像素。 解决方法二：rem + viewport 说到这里，解决方法就很明了了：我们可以在运行的时候拿到设备的devicePixelRatio，动态改变viewport的initial-scale为 1/devicePixelRatio，这样就能保证1px的宽度就是真正的1物理像素宽。其他适配使用rem（因为使用px的话都会被缩小） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!--&lt;meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, width=device-width"&gt;--&gt; &lt;title&gt;移动端1px边框问题&lt;/title&gt; &lt;script&gt; (function () &#123; var clientWidth = window.screen.width; var dpr = window.devicePixelRatio; var vp = document.createElement('meta'); document.documentElement.style.fontSize = clientWidth &gt; 414 ? '20px' : 20 * dpr * clientWidth / 360 + 'px'; vp.name = 'viewport'; vp.content = `initial-scale=$&#123;1.0 * 1 / dpr&#125;, maximum-scale=$&#123;1.0 * 1 / dpr&#125;, minimum-scale=$&#123;1.0 * 1 / dpr&#125;, user-scalable=no, width=device-width`; var m = document.getElementsByTagName('meta')[0]; m.parentNode.insertBefore(vp, m); &#125;)(); &lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, li&#123; list-style: none; &#125; .lines &#123; width: 10rem; margin: 0 auto; &#125; .lines li &#123; border: 1px solid #cccccc; height: 2.5rem; line-height: 2.5rem; text-align: center; border-radius: 0.6rem; margin-top: 0.5rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class="lines"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 从上来看，回到之前的问题，”1.为什么是scaleY(0.5)？这个0.5是怎么得出的？是不是所有机型都是要scale缩小到一半，换句话说是不是通用？”其实并不一定是0.5,在dpr为3的设备上其实应该是0.3333……，也不通用，因为每个手机的dpr可能不一样。 解决方法三flexible.js 这是淘宝移动端采取的方案, github的地址:https://github.com/amfe/lib-flexible. 前面已经说过1px变粗的原因就在于一刀切的设置 viewport 宽度, 如果能把 viewport 宽度设置为实际的设备物理宽度, css 里的 1px 不就等于实际 1px 长了么. flexible.js 就是这样干的. 里面的 scale 值指的是对 ideal viewport 的缩放, flexible.js 检测到 IOS 机型, 会算出 scale = 1/devicePixelRatio, 然后设置viewport 123metaEl = doc.createElement('meta');metaEl.setAttribute('name', 'viewport');metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); devicePixelRatio=2时输出meta如下, 这样viewport与ideal viewport的比是0.5, 也就与设备物理像素一致1&lt;meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"&gt; 另外html元素上的font-size会被设置为屏幕宽的1/10, 这样css可以以rem为基础长度单位进行改写, 比如rem是28px, 原先的7px就是0.25rem. border的宽度能直接写1px. 123456789function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) &#123; //大于540px可以不认为是手机屏 width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125; px和rem相互转换的计算方法会暴露在window.lib.flexible中. 这样可以为less/sass编写宏方法.具体的css改写方法参照大漠的文章http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html项目中特别指出了为了防止字体模糊, 出现奇数字号的字体, 字体的实际单位还是要以px为单位.缺点: 不适用安卓, flexible内部做了检测 非iOS机型还是采用传统的scale=1.0, 原因在于安卓手机不一定有devicePixelRatio属性, 就算有也不一定能响应scale小于1的viewport缩放设置, 例如我的手机设置了scale=0.33333333, 显示的结果也与scale=1无异. 综合使用对于IOS, flexible.js处理的已经很好了, 对于Android,方法2,3,4结合起来大体可以满足要求. flexible.js虽然不适用于安卓, 但它里面的这一段代码可以用来做对安卓机的部署. 12345678910111213141516171819if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr;&#125; 这里对安卓做检测, 如果是安卓, js动态加载css12345var link = document.createElement('link');link.setAttribute("rel","stylesheet");link.setAttribute("type","text/css");link.setAttribute("href",".......Android.css");document.querySelector('head').appendChild(link); 禁止 iOS 自动识别电话和 Android 自动识别邮箱123&lt;meta name="format-detection" content="telephone=no"/&gt; &lt;meta name="format-detection" content=“email=no"/&gt; 禁止文本选择1-webkit-user-select:none 屏蔽输入框阴影，去掉按钮默认样式1-webkit-appearance:none css3 多行文本换行12345overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; //显示的行数 -webkit-box-orient: vertical; iOS 快速回弹在 iOS 上如果想让一个元素拥有像 Native 的滚动效果，可以这样写12overflow-y: scroll; -webkit-overflow-scrolling: touch; 禁止a标签点击高亮12345html,body&#123; -webkit-touch-callout: none; //禁止或显示系统默认菜单 -webkit-user-select: none; //禁止长按复制选择 -webkit-tap-highlight-color: rgba(0,0,0,0);//禁止触摸a标签高亮 这个特别实用 &#125; meta标签1234567891011121314151617181920212223242526272829303132&lt;!-- 设置缩放 --&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" /&gt; &lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; &lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt; &lt;meta name="format-detection"content="telephone=no, email=no" /&gt; 其他meta标签 &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name="HandheldFriendly" content="true"&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name="MobileOptimized" content="320"&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name="screen-orientation" content="portrait"&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name="x5-orientation" content="portrait"&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name="full-screen" content="yes"&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name="x5-fullscreen" content="true"&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name="browsermode" content="application"&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name="x5-page-mode" content="app"&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name="msapplication-tap-highlight" content="no"&gt; 常用12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;!-- ios7.0版本以后，safari上已看不到效果,可以删除--&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;viewport通用&lt;/title&gt; &lt;script type="text/javascript"&gt; var phoneWidth = parseInt(window.screen.width); var phoneScale = phoneWidth / 750; var ua = navigator.userAgent; if (/Android (\d+\.\d+)/.test(ua)) &#123; var version = parseFloat(RegExp.$1); if (version &gt; 2.3) &#123; document.write('&lt;meta name="viewport" id="vie" content="width=750, minimum-scale = ' + phoneScale + ', maximum-scale = ' + phoneScale + ', target-densitydpi=device-dpi"&gt;'); &#125; else &#123; document.write('&lt;meta name="viewport" id="vie" content="width=750, target-densitydpi=device-dpi"&gt;'); &#125; &#125; else &#123; document.write('&lt;meta id="vie" name="viewport" content="width=750, user-scalable=no, target-densitydpi=device-dpi, minimal-ui"&gt;'); &#125; &lt;/script&gt; &lt;link style="text/css" rel="stylesheet" href="home.css"&gt; &lt;script type="text/javascript" src="js/app.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--页面内容--&gt;&lt;/body&gt;&lt;/html&gt; device-width：设备宽度 width：设置viewport宽度，为一个正整数，或字符串‘device-width’ height：设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 initial-scale：默认缩放比例(初始缩放比例)，为一个数字，可以带小数 minimum-scale：允许用户最小缩放比例，为一个数字，可以带小数 maximum-scale：允许用户最大缩放比例，为一个数字，可以带小数 user-scalable：是否允许手动缩放 移动端click事件有300 ms的延迟响应问题2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： astclick可以解决在手机上点击事件的300ms延迟，地址：https://github.com/ftlabs/fastclick zepto的touch模块，tap事件也是为了解决在click的延迟问题 CSS美化Placeholder提示信息的样式兼容12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125; 手机对Placeholder提示信息都基本带有默认的样式，兼容各种浏览器的使用方式：1234.css::-webkit-input-placeholder &#123;color: #777;&#125; /* WebKit browsers */.css:-moz-placeholder &#123;color: #777;opacity: 1;&#125; /* Mozilla Firefox 4 to 18 */.css::-moz-placeholder &#123;color: #777;opacity: 1;&#125; /* Mozilla Firefox 19+ */.css:-ms-input-placeholder &#123;color: #777;&#125; /* Internet Explorer 10+ */ 移动端实现类似hover效果移动端实现类似hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活移动端css的active效果。 直接在body上添加ontouchstart，同样可激活移动端css的active效果，比较推荐这种方式，代码如下： html代码：123&lt;body ontouchstart&gt;&lt;/body&gt;.btn:active&#123;background-color: red;&#125; 开启硬件加速123456.css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; CSS动画的性能分析和浏览器GPU加速 android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125; 取消input在ios下，输入的时候英文首字母的默认大写1&lt;input autocapitalize="off" autocorrect="off" /&gt; CSS判断横屏竖屏123456789//竖屏时使用的样式@media screen and (orientation:portrait) &#123; .css&#123;&#125;&#125;//横屏时使用的样式@media screen and (orientation:landscape) &#123; .css&#123;&#125;&#125; 分开写在2个CSS中：12&lt;link rel="stylesheet" media="all and (orientation:portrait)" href="portrait.css"&gt;&lt;link rel="stylesheet" media="all and (orientation:landscape)" href="landscape.css"&gt; CSS3判断屏幕横屏123@media screen and (min-aspect-ratio: 13/8) &#123; &#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this、call、apply和bind]]></title>
    <url>%2Fpost%2F4b3c211f.html</url>
    <content type="text"><![CDATA[理解 JavaScript 中的 this、call、apply 和 bindJavaScript 中最容易被误解的一点就是 this 关键字。在这篇文章中，你将会了解四种规则，弄清楚 this 关键字指的是什么。隐式绑定、显式绑定、new 绑定和 window 绑定。在介绍这些技术时，你还将学习一些 JavaScript 其他令人困惑的部分，例如 .call、.apply、.bind和 new 关键字。 在深入了解 JavaScript 中的 this 关键字之前，有必要先退一步，看一下为什么 this 关键字很重要。this 允许复用函数时使用不同的上下文。换句话说，“this” 关键字允许在调用函数或方法时决定哪个对象应该是焦点。 之后讨论的所有东西都是基于这个理念。我们希望能够在不同的上下文或在不同的对象中复用函数或方法。 我们要关注的第一件事是如何判断 this 关键字的引用。当你试图回答这个问题时，你需要问自己的第一个也是最重要的问题是“这个函数在哪里被调用？”。判断 this 引用什么的 唯一 方法就是看使用 this 关键字的这个方法在哪里被调用的。 用一个你已经十分熟悉的例子来展示这一点，比如我们有一个 greet 方法，它接受一个名字参数并显示有欢迎消息的警告框。 123function greet(name) &#123; alert(`my name is $&#123;name&#125;`);&#125; 如果我问你 greet 会具体警告什么内容，你会怎样回答？只给出函数定义是不可能知道答案的。为了知道 name 是什么，你必须看看 greet 函数的调用过程。1greet('Tyler') 判断 this 关键字引用什么也是同样的道理，你甚至可以把 this 当成一个普通的函数参数对待 — 它会随着函数调用方式的变化而变化。 现在我们知道为了判断 this 的引用必须先看函数的定义，在实际地查看函数定义时，我们设立了四条规则来查找引用，它们是: 隐式绑定 显式绑定 new 绑定 window 绑定 隐式绑定请记住，这里的目标是查看使用 this 关键字的函数定义，并判断 this 的指向。执行绑定的第一个也是最常见的规则称为 隐式绑定。80% 的情况下它会告诉你 this 关键字引用的是什么。 假如我们有一个这样的对象1234567const user = &#123; name: 'Tyler', age: 27, greet() &#123; alert(`Hello, my name is $&#123;this.name&#125;`) &#125;&#125; 现在，如果你要调用 user 对象上的 greet 方法，你会用到点号。1user.greet() 这就把我们带到隐式绑定规则的主要关键点。为了判断 this 关键字的引用，函数被调用时先看一看点号左侧。如果有“点”就查看点左侧的对象，这个对象就是 this 的引用。 在上面的例子中，user 在“点号左侧”意味着 this 引用了 user 对象。所以就好像 在 greet 方法的内部 JavaScript 解释器把 this 变成了 user。1234greet() &#123; // alert(`Hello, my name is $&#123;this.name&#125;`) alert(`Hello, my name is $&#123;user.name&#125;`) // Tyler&#125; 我们来看一个类似但稍微高级点的例子。现在，我们的对象不仅要拥有 name、age 和 greet 属性，还要被添加一个 mother 属性，并且此属性也拥有 name 和 greet 属性。 12345678910111213const user = &#123; name: 'Tyler', age: 27, greet() &#123; alert(`Hello, my name is $&#123;this.name&#125;`) &#125;, mother: &#123; name: 'Stacey', greet() &#123; alert(`Hello, my name is $&#123;this.name&#125;`) &#125; &#125;&#125; 现在问题变成下面的每个函数调用会警告什么？ 12user.greet()user.mother.greet() 每当判断 this 的引用时，我们都需要查看调用过程，并确认“点的左侧”是什么。第一个调用，user 在点左侧意味着 this 将引用 user。第二次调用中，mother 在点的左侧意味着 this 引用 mother 12user.greet() // Tyleruser.mother.greet() // Stacey 如前所述，大约有 80% 的情况下在“点的左侧”都会有一个对象。这就是为什么在判断 this 指向时“查看点的左侧”是你要做的第一件事。但是，如果没有点呢？这就为我们引出了下一条规则 — 显式绑定如果 greet 函数不是 user 对象的函数，只是一个独立的函数。12345678function greet () &#123; alert(`Hello, my name is $&#123;this.name&#125;`)&#125;const user = &#123; name: 'Tyler', age: 27,&#125; 我们知道为了判断 this 的引用我们首先必须查看这个函数的调用位置。现在就引出了一个问题，我们怎样能让 greet 方法调用的时候将 this 指向 user 对象？。我们不能再像之前那样简单的使用 user.greet()，因为 user 并没有 greet 方法。在 JavaScript 中，每个函数都包含了一个能让你恰好解决这个问题的方法，这个方法的名字叫做 call。 1“call” 是每个函数都有的一个方法，它允许你在调用函数时为函数指定上下文。 考虑到这一点，用下面的代码可以在调用 greet 时用 user 做上下文。 1greet.call(user) 再强调一遍，call 是每个函数都有的一个属性，并且传递给它的第一个参数会作为函数被调用时的上下文。换句话说，this 将会指向传递给 call 的第一个参数。 这就是第 2 条规则的基础（显示绑定），因为我们明确地（使用 .call）指定了 this 的引用。 现在让我们对 greet 方法做一点小小的改动。假如我们想传一些参数呢？不仅提示他们的名字，还要提示他们知道的语言。就像下面这样 123function greet (lang1, lang2, lang3) &#123; alert(`Hello, my name is $&#123;this.name&#125; and I know $&#123;lang1&#125;, $&#123;lang2&#125;, and $&#123;lang3&#125;`)&#125; 现在为了将这些参数传递给使用 .call 调用的函数，你需要在指定上下文（第一个参数）后一个一个地传入。 12345678910function greet (lang1, lang2, lang3) &#123; alert(`Hello, my name is $&#123;this.name&#125; and I know $&#123;lang1&#125;, $&#123;lang2&#125;, and $&#123;lang3&#125;`)&#125;const user = &#123; name: 'Tyler', age: 27,&#125;const languages = ['JavaScript', 'Ruby', 'Python']greet.call(user, languages[0], languages[1], languages[2]) 方法奏效，它显示了如何将参数传递给使用 .call 调用的函数。不过你可能注意到，必须一个一个传递 languages 数组的元素，这样有些恼人。如果我们可以把整个数组作为第二个参数并让 JavaScript 为我们自动展开就好了。有个好消息，这就是 .apply 干的事情。.apply 和 .call 本质相同，但不是一个一个传递参数，你可以用数组传参而且 .apply 会在函数中为你自动展开。 那么现在用 .apply，我们的代码可以改为下面这个，其他一切都保持不变。 1234const languages = ['JavaScript', 'Ruby', 'Python']// greet.call(user, languages[0], languages[1], languages[2])greet.apply(user, languages) 到目前为止，我们学习了关于 .call 和 .apply 的“显式绑定”规则，用此规则调用的方法可以让你指定 this 在方法内的指向。关于这个规则的最后一个部分是 .bind。.bind 和 .call 完全相同，除了不会立刻调用函数，而是返回一个能以后调用的新函数。因此，如果我们看看之前所写的代码，换用 .bind，它看起来就像这样 12345678910111213function greet (lang1, lang2, lang3) &#123; alert(`Hello, my name is $&#123;this.name&#125; and I know $&#123;lang1&#125;, $&#123;lang2&#125;, and $&#123;lang3&#125;`)&#125;const user = &#123; name: 'Tyler', age: 27,&#125;const languages = ['JavaScript', 'Ruby', 'Python']const newFn = greet.bind(user, languages[0], languages[1], languages[2])newFn() // alerts "Hello, my name is Tyler and I know JavaScript, Ruby, and Python" new 绑定第三条判断 this 引用的规则是 new 绑定。若你不熟悉 JavaScript 中的 new 关键字，其实每当用 new 调用函数时，JavaScript 解释器都会在底层创建一个全新的对象并把这个对象当做 this。如果用 new 调用一个函数，this 会自然地引用解释器创建的新对象。 1234567891011function User (name, age) &#123; /* JavaScript 会在底层创建一个新对象 `this`，它会代理不在 User 原型链上的属性。 如果一个函数用 new 关键字调用，this 就会指向解释器创建的新对象。 */ this.name = name this.age = age&#125;const me = new User('Tyler', 27) window 绑定假如我们有下面这段代码 12345678function sayAge () &#123; console.log(`My age is $&#123;this.age&#125;`)&#125;const user = &#123; name: 'Tyler', age: 27&#125; 如前所述，如果你想用 user 做上下文调用 sayAge，你可以使用 .call、.apply 或 .bind。但如果我们没有用这些方法，而是直接和平时一样直接调用 sayAge 会发生什么呢？ 1sayAge() // My age is undefined 不出意外，你会得到 My name is undefined，因为 this.age 是 undefined。事情开始变得神奇了。实际上这是因为点的左侧没有任何东西，我们也没有用 .call、.apply、.bind 或者 new 关键字，JavaScript 会默认 this 指向 window 对象。这意味着如果我们向 window 对象添加 age 属性并再次调用 sayAge 方法，this.age 将不再是 undefined 并且变成 window 对象的 age 属性值。不相信？让我们运行这段代码 12345window.age = 27function sayAge () &#123; console.log(`My age is $&#123;this.age&#125;`)&#125; 非常神奇，不是吗？这就是第 4 条规则为什么是 window 绑定 的原因。如果其它规则都没满足，JavaScript就会默认 this 指向 window 对象。 1在 ES5 添加的 严格模式 中，JavaScript 不会默认 this 指向 window 对象，而会正确地把 this 保持为 undefined。 123456789'use strict'window.age = 27function sayAge () &#123; console.log(`My age is $&#123;this.age&#125;`)&#125;sayAge() // TypeError: Cannot read property 'age' of undefined 因此，将所有规则付诸实践，每当我在函数内部看到 this 关键字时，这些就是我为了判断它的引用而采取的步骤。 查看函数在哪被调用。 点左侧有没有对象？如果有，它就是 “this” 的引用。如果没有，继续第 3 步。 该函数是不是用 “call”、“apply” 或者 “bind” 调用的？如果是，它会显式地指明 “this” 的引用。如果不是，继续第 4 步。 该函数是不是用 “new” 调用的？如果是，“this” 指向的就是 JavaScript 解释器新创建的对象。如果不是，继续第 5 步。 是否在“严格模式”下？如果是，“this” 就是 undefined，如果不是，继续第 6 步。 JavaScript 很奇怪，“this” 会指向 “window” 对象。 箭头函数在以往的函数中，this 有各种各样的指向(隐式绑定，显示绑定，new 绑定, window 绑定……)，虽然灵活方便，但由于不能在定义函数时而直到实际调用时才能知道 this 指向，很容易给开发者带来诸多困扰。 假如我们有下面这段代码（本文代码都是在浏览器下运行）， 12345678910function User() &#123; this.name = 'John'; setTimeout(function greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is console.log(this); // window &#125;, 1000);&#125;const user = new User(); 没有显示绑定、隐式绑定或 new 绑定、所以直接得出结论 this 指向 window。如果我们想把 this 指向 user 对象！ 以前是怎么解决的呢？看下面的代码： 使用闭包1234567891011function User() &#123; const self = this; this.name = 'John'; setTimeout(function greet() &#123; console.log(`Hello, my name is $&#123;self.name&#125;`); // Hello, my name is John console.log(self); // User &#123;name: "John"&#125; &#125;, 1000);&#125;const user = new User(); 使用显示绑定 — bind12345678910function User() &#123; this.name = 'John'; setTimeout(function greet() &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is John console.log(this); // User &#123;name: "John"&#125; &#125;.bind(this)(), 1000);&#125;const user = new User(); 利用 setTimeout 的可以传更多参数的特性其实第三种和第一种比较像，都用到了闭包。 12345678910function User() &#123; this.name = 'John'; setTimeout(function greet(self) &#123; console.log(`Hello, my name is $&#123;self.name&#125;`); // Hello, my name is John console.log(self); // User &#123;name: "John"&#125; &#125;, 1000, this);&#125;const user = new User(); 三种方法都可以解决问题，但是都要额外写冗余的代码来指定 this。 现在，箭头函数（Arrow Function）正是 ES6 引入来解决这个问题的，它可以轻松地让 greet 函数保持 this 指向 user 对象。 箭头函数如何解决下面是箭头函数版本： 12345678910function User() &#123; this.name = 'John'; setTimeout(() =&gt; &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is John console.log(this); // User &#123;name: "John"&#125; &#125;, 1000);&#125;const user = new User(); 完美，直接把普通函数改成箭头函数就能解决问题。 箭头函数在自己的作用域内不绑定 this，即没有自己的 this，如果要使用 this ，就会指向定义时所在的作用域的 this 值。在上面的代码中即指向 User 函数的 this，而 User 函数通过 new 绑定，所以 this 实际指向 user 对象。 如果上述代码在严格模式下运行会有影响吗？ 1234567891011function User() &#123; this.name = 'John'; setTimeout(() =&gt; &#123; 'use strict' console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is John console.log(this); // User &#123;name: "John"&#125; &#125;, 1000);&#125;const user = new User(); 答案是没有影响。因为箭头函数没有自己的 this，它的 this 来自于 User 的 this，只要 User 的 this 不变，箭头函数的 this 也保持不变。 那么使用 bind，call 或者 apply 呢？12345678910function User() &#123; this.name = 'John'; setTimeout((() =&gt; &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); // Hello, my name is John console.log(this); // User &#123;name: "John"&#125; &#125;).bind('no body'), 1000);&#125;const user = new User(); 答案还是没有影响。因为箭头函数没有自己的 this，使用 bind，call 或者 apply 时，箭头函数会自动忽略掉 bind 的第一个参数，即 thisArg。 箭头函数在自己的作用域内没有自己的 this，如果要使用 this ，就会指向定义时所在的作用域的 this 值。 原文：https://juejin.im/post/5b9f176b6fb9a05d3827d03f]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript内存管理以及内存泄漏]]></title>
    <url>%2Fpost%2F24cc7cf9.html</url>
    <content type="text"><![CDATA[概述语言，比如C，具有低层次的内存管理方法，比如malloc()以及free()。开发者利用这些方法精确地为操作系统分配以及释放内存。 同时，JavaScript会在创建一些变量（对象，字符串等等）的时候分配内存，并且会在这些不被使用之后“自动地”释放这些内存，这个过程被称为垃圾收集。这个看起来“自动化的”特性其实就是产生误解的原因，并且给JavaScript（以及其他高层次语言）开发者一个假象，他们不需要关心内存管理。大错特错。 即使是使用高层次语言，开发者应该对于内存管理有一定的理解（或者最基本的理解）。有时候自动的内存管理会存在一些问题（比如一些bug或者垃圾收集器的一些限制等等），对于这些开发者必须能够理解从而能够合适地处理（或者使用最小的代价以及代码债务去绕过这个问题）。 内存生命周期不管你在使用什么编程语言，内存的生命周期基本上都是一样的： 下面是对于周期中每一步所发生的情况的概述： 分配内存——操作系统为你的程序分配内存并且允许其使用。在低层次语言中（比如C），这正是开发者应该处理的操作。在高层次的语言，然而，就由语言帮你实现了。 使用内存——当你的程序确实在使用之前分配的内存的阶段。当你在使用你代码里面分配的变量的时候会发生读以及写操作。 释放内存——这个阶段就是释放你不再需要的内存，从而这些内存被释放并且能够再次被使用。和分配内存操作一样，这在低层次的语言也是开发者需要明确的操作。 什么是内存？在我们讲述JavaScript内存之前，我们将简要地讨论一下内存是什么以及它们是如何在 nutshell 中工作的。 在硬件层次上，计算机内存由大量的 寄存器 组成。每一个寄存器都包含一些晶体管并且能够存储一比特。单独的寄存器可以通过独特的标识符去访问，因此我们能够读取以及重写它们。因此，从概念上来说，我们可以认为我们的整个计算机内存就是一个我们能够读写的大型比特数组。 因为作为人类，我们不擅长直接基于比特进行思考以及算术，我们将它们组织成大规模群组，它们在一起可以代表一个数字。8个比特称为一个字节。除了字节，还有词（有时候是16比特，有时候是32比特）。 内存中存储了很多东西： 1.所有程序使用的变量和其他数据 2.程序的代码，包括操作系统的代码。 编译器和操作系统共同合作为你处理大部分的内存管理，但是我们建议你应该了解其内部的运行原理。 当你编译你的代码的时候，编译器将会检查原始数据类型并且提前计算好它们需要多少内存。需要的内存被分配给程序，这被称为栈空间。这些被分配给变量的空间被称为栈空间，因为一旦函数被调用，它们的内存就会增加到现有内存的上面。当它们终止的时候，它们就会以后进先出(LIFO)的顺序移除。比如，考虑下面的声明。 123int n; // 4 bytesint x[4]; // array of 4 elements, each 4 bytesdouble m; // 8 bytes 编译器能够立即计算出代码需要 4 + 4 × 4 + 8 = 28 字节 那就是它如何对于现有的整形以及双浮点型工作。大约20年前，整形典型都是2个字节，双浮点型是4个字节。你的代码不应该取决于当下基本数据类型的大小。 编译器将会插入能够与操作系统交互的代码，从而在栈上获取你需要存储变量需要的字节数。 在上述的例子中，编译器知道每一个变量的准确的内存地址。事实上，无论我们何时写变量 n ，这都会在内部转化为类似于“内存地址 4127963”的东西。 注意如果我们希望在这访问 x[4] 我们将会需要访问和 m 相关联的数据。这是因为我们在访问数组里面并不存在的元素——它比数组实际分配的最后一个元素 x[3] 要多4个字节，并且最后可能是阅读（或者重写）一些 m 的比特。这将很可能给程序的其他部分带来一些不良的后果。 当函数调用其它函数的时候，当它被调用的时候都会获取它自己的堆栈块。它在那保存了它所有的局部变量，但是还会有一个程序计数器记录它执行的位置。当这个函数执行完毕，它的内存块就可以再次用于其他目的。 动态分配不幸的是，当我们在编译的时候不知道变量需要多少内存的话事情可能就不那么简单。假设我们想做下面的事情： 12345int n = readInput(); // reads input from the user...// create an array with &quot;n&quot; elements 在此，在编译阶段中，编译器就没有办法知道数组需要多少内存，因为它取决于用户的输入。 因此，它就不能够为栈上的变量分配空间。相反，我们的程序需要明确地询问操作运行时需要的空间数量。这个内存是从堆空间中分配出来的。动态内存和静态内存分配的区别总结如下表格： 为了深入地理解动态内存分配是如何工作的，我们需要花费更多的时间在指针。 JavaScript中的分配现在我们将解释JavaScript中的第一步（分配内存）。 JavaScript 将开发者从内存分配的处理中解放出来——JavaScript自身可以利用声明变量来完成这些任务。 12345678910111213141516171819var n = 374; // allocates memory for a numbervar s = 'sessionstack'; // allocates memory for a string var o = &#123; a: 1, b: null&#125;; // allocates memory for an object and its contained valuesvar a = [1, null, 'str']; // (like object) allocates memory for the // array and its contained valuesfunction f(a) &#123; return a + 3;&#125; // allocates a function (which is a callable object)// function expressions also allocate an objectsomeElement.addEventListener('click', function() &#123; someElement.style.backgroundColor = 'blue';&#125;, false); 一些函数调用也会导致一些对象的分配： 123var d = new Date(); // allocates a Date objectvar e = document.createElement('div'); // allocates a DOM element 能够分配新的值或者对象的方法： 1234567891011var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 is a new string// Since strings are immutable, // JavaScript may decide to not allocate memory, // but just store the [0, 3] range.var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2); // new array with 4 elements being// the concatenation of a1 and a2 elements 在JavaScript中使用内存基本上在JavaScript中分配内存，就意味着在其中读写。 这可以通过对一个变量或者一个对象的属性甚至是向函数传递一个参数来完成。 当内存不再需要的时候释放它大多数的内存管理的问题就来自于这个阶段。 最困难的任务就是如何知道何时被分配的不再需要了。它经常需要开发者决定在程序的什么地方某段内存不再需要了并且对其进行释放。 高层次语言内嵌了一个称为垃圾收集器的软件，他的任务就是跟踪内存分配并且用于需找不再需要的分配过的内存，并且自动地对其进行释放。 不幸的是，这个过程是一个近似，因为知道是否某块内存是需要的问题是不可决定的（无法通过算法解决） 大多数的垃圾收集器通过收集再也无法访问的内存工作，比如：指向它的所有变量都超出了作用域。然而，这依然是对于可以收集的内存空间的预估，因为在任何位置仍可能一些变量在作用域内指向这个内存，然而它再也不能被访问了。 垃圾收集器由于找到一些是“不再需要的”是不可决定的事实，垃圾收集实现了对一般问题的解决方案的限制。这一节将会解释理解主要的垃圾收集算法以及它们的限制的需要注意的事项。 内存引用垃圾收集算法依赖的主要概念之一就是引用。 在内存管理的上下文中，一个对象被称为是对于另外一个对象的引用，如果前者可以访问后者（隐含或明确的）。例如，一个JavaScript对象都有一个指向其原型的引用（隐含的引用） 在这个上下文中，“对象”的概念扩展到比普通的JavaScript对象要广并且包括函数作用域（或者全局词法作用域）。 词法作用域定义了变量名称是如何在嵌套函数中解析的：内部函数包含了父函数的作用域即使父函数已经返回了。 基于引用计数的垃圾收集器这是最简单的垃圾收集器算法。如果没有引用指向这个对象的时候，这个对象就被认为是“可以作为垃圾收集”。 请看如下代码： 1234567891011121314151617181920212223242526272829var o1 = &#123; o2: &#123; x: 1 &#125;&#125;;// 2 objects are created. // 'o2' is referenced by 'o1' object as one of its properties.// None can be garbage-collectedvar o3 = o1; // the 'o3' variable is the second thing that // has a reference to the object pointed by 'o1'. o1 = 1; // now, the object that was originally in 'o1' has a // single reference, embodied by the 'o3' variablevar o4 = o3.o2; // reference to 'o2' property of the object. // This object has now 2 references: one as // a property. // The other as the 'o4' variableo3 = '374'; // The object that was originally in 'o1' has now zero // references to it. // It can be garbage-collected. // However, what was its 'o2' property is still // referenced by the 'o4' variable, so it cannot be // freed.o4 = null; // what was the 'o2' property of the object originally in // 'o1' has zero references to it. // It can be garbage collected. 循环在产生问题当遇到循环的时候就会有一个限制。在下面的实例之中，创建两个对象，并且互相引用，因此就会产生一个循环。当函数调用结束之后它们会走出作用域之外，因此它们就没什么用并且可以被释放。但是，基于引用计数的算法认为这两个对象都会被至少引用一次，所以它俩都不会被垃圾收集器收集。 12345678function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 references o2 o2.p = o1; // o2 references o1. This creates a cycle.&#125;f(); 标记-清除算法为了决定哪个对象是需要的，算法会决定是否这个对象是可访问的。 这个算法由以下步骤组成： 这个垃圾收集器构建一个“roots”列表。Root是全局变量，被代码中的引用所保存。在 JavaScript中，“window”就是这样的作为root的全局变量的例子。 所有的root都会被监测并且被标志成活跃的（比如不是垃圾）。所有的子代也会递归地被监测。所有能够由root访问的一切都不会被认为是垃圾。 所有不再被标志成活跃的内存块都被认为是垃圾。这个收集器现在就可以释放这些内存并将它们返还给操作系统。 这个算法要优于之前的因为“一个具有0引用的对象”可以让一个对象不能够再被访问。但是相反的却不一定成立，比如我们遇到循环的时候。 在2012年，所有的现代浏览器都使用标记-清除垃圾收集器。过去几年，JavaScript垃圾收集（代数/增量/并行/并行垃圾收集）领域的所有改进都是对该算法（标记和扫描）的实现进行了改进，但并没有对垃圾收集算法本身的改进， 其目标是确定一个对象是否可达。 在这篇文章中，你可以得到更多关于垃圾收集追踪并且也覆盖到了关于标记-清除算法的优化。 循环不再是一个问题在上述的第一个例子中，在函数调用返回之后，这两个对象不能够被全局对象所访问。因此，垃圾收集器就会发现它们不能够被访问了。 即使在这两个对象之间存在着引用，它们再也不能从root访问了。 列举垃圾收集器的直观行为虽然垃圾收集器很方便，但它们自己也有自己的代价。 其中一个是非确定论。 换句话说，GC是不可预测的。 你不能真正地告诉你什么时候会收集。 这意味着在某些情况下，程序会使用实际需要的更多内存。 在其他情况下，特别敏感的应用程序可能会引起短暂暂停。 虽然非确定性意味着在执行集合时无法确定，但大多数GC实现共享在分配期间执行收集遍历的常见模式。 如果没有执行分配，大多数GC保持空闲状态。 考虑以下情况： 执行相当大的一组分配。 这些元素中的大多数（或全部）被标记为不可访问（假设我们将指向我们不再需要的缓存的引用置空）。 不再执行分配。 在这种情况下，大多数GC不会再运行收集处理。换句话说，即使存在对于收集器来说不可访问的引用，它们也不会被收集器所认领。严格意义来说这并不是泄露，但是依然会导致比平常更多的内存使用。 什么是内存泄露？实质上，内存泄漏可以被定义为应用程序不再需要的内存，但是由于某些原因不会返回到操作系统或可用内存池。 编程语言有支持管理内存的不同方法。 然而，某块内存是否被使用实际上是一个不可判定的问题。 换句话说，只有开发人员可以清楚一个内存是否可以返回到操作系统。 某些编程语言提供了帮助开发者执行此操作的功能。其他的则期望开发人员能够完全明确何时使用一块内存。 维基百科有关于手动和自动内存管理的好文章。 四种常见的JavaScript泄露全局变量JavaScript 使用一种有趣的方式处理未声明的变量：一个未声明变量的引用会在全局对象内部产生一个新的变量。在浏览器的情况，这个全局变量就会是window。换句话说： 123function foo(arg) &#123; bar = "some text";&#125; 等同于：123function foo(arg) &#123; window.bar = "some text";&#125; 如果bar被期望仅仅在foo函数作用域内保持对变量的引用，并且你忘记使用var去声明它，一个意想不到的全局变量就产生了。 在这个例子中，泄露就仅仅是一个字符串并不会带来太多危害，但是它可能会变得更糟。 另外一种可能产生意外的全局变量的方式是： 1234567function foo() &#123; this.var1 = "potential accidental global";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); 为了阻止这些错误的发生，可以在js文件头部添加’use strict’。这将会使用严格模式来解析 JavaScript 从而阻止意外的全局变量。了解更多关于JavaScript执行的模式。 即使我们讨论了未预期的全局变量，但仍然有很多代码用显式的全局变量填充。 这些定义是不可收集的（除非分配为null或重新分配）。 特别是，用于临时存储和处理大量信息的全局变量值得关注。如果你必须使用全局变量来存储大量数据，请确保在完成之后将其分配为null或重新分配。 被遗忘的计时器和回调setInterval 在 JavaScript 中是经常被使用的。 大多数提供观察者和其他模式的回调函数库都会在调用自己的实例变得无法访问之后对其任何引用也设置为不可访问。 但是在setInterval的情况下，这样的代码很常见： 1234567var serverData = loadData();setInterval(function() &#123; var renderer = document.getElementById('renderer'); if(renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); //This will be executed every ~5 seconds. 这个例子说明了计时器可能发生的情况：计时器可能会产生再也不被需要的节点或者数据的引用。 renderer所代表的对象在未来可能被移除，让部分interval 处理器中代码变得不再被需要。然而，这个处理器不能够被收集因为interval依然活跃的（这个interval需要被停止从而表面这种情况）。如果这个interval处理器不能够被收集，那么它的依赖也不能够被收集。这意味这存储大量数据的severData也不能够被收集。 在这种观察者的情况下，做出准确的调用从而在不需要它们的时候立即将其移除是非常重要的（或者相关的对象被置为不可访问的）。 过去，以前特别重要的是某些浏览器（好的老IE 6）无法管理好循环引用（有关更多信息，请参见下文）。 如今，大多数浏览器一旦观察到的对象变得无法访问，就能收集观察者处理器，即使侦听器没有被明确删除。 但是，在处理对象之前，明确删除这些观察者仍然是一个很好的做法。 例如： 1234567891011121314151617var element = document.getElementById('launch-button');var counter = 0;function onClick(event) &#123; counter++; element.innerHtml = 'text ' + counter;&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers // that don't handle cycles well. 当今，现在浏览器（报错IE和Edge）都使用了现代的垃圾收集算法，其能够检测到这些循环并且进行适宜的处理。换句话说，再也不是严格需要在将节点置为不可访问之前调用removeEventListener 。 框架和库（如jQuery）在处理节点之前（在为其使用特定的API时）会删除侦听器。 这是由库内部处理的，这也确保没有泄漏，即使在有问题的浏览器下运行，如…是的，IE 6。 闭包JavaScript 开发的一个关键方面是闭包：一个可以访问外部（封闭）函数变量的内部函数。 由于JavaScript运行时的实现细节，可以通过以下方式泄漏内存： 1234567891011121314151617 var theThing = null; var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) // a reference to 'originalThing' console.log("hi"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log("message"); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 这个代码段会做一件事情：每次 replaceThing 被调用时，theThing 都会获取一个一个包含一个大数组的以及一个新的闭包（someMethod）。同时，unused 会保持一个指向originalThing引用的闭包（从上一个调用的theThing到replaceThing）。可能已经很迷惑了，是不是？重要的事情是一旦在相同的父级作用域为闭包产生作用域，这个作用域就会被共享。 在这种情况下，为someMethod闭包产生的作用域就会被unused 所共享。unused 具有对于originaThing的引用。即使 unused 不再被使用，someMethod依然可以通过replaceThing作用域之外的theThing来使用。并且由于somethod和unused 共享闭包作用域，unused指向originalThing的引用强迫其保持活跃（两个闭包之间的整个共享作用域）。这将会阻止垃圾手机。 当这个代码段重复运行时，可以观察到内存使用量的稳定增长。 当GC运行时，这不会变小。 实质上，创建了一个关闭的链接列表（其root以TheThing变量的形式），并且这些闭包的范围中的每一个都对大数组进行间接引用，导致相当大的泄漏。 DOM 之外的引用有时将DOM节点存储在数据结构中可能是有用的。 假设要快速更新表中的几行内容。 存储对字典或数组中每个DOM行的引用可能是有意义的。 当发生这种情况时，会保留对同一DOM元素的两个引用：一个在DOM树中，另一个在字典中。 如果将来某个时候您决定删除这些行，则需要使两个引用置为不可访问。 1234567891011121314151617var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image')&#125;;function doStuff() &#123; image.src = 'http://example.com/image_name.png';&#125;function removeImage() &#123; // The image is a direct child of the body element. document.body.removeChild(document.getElementById('image')); // At this point, we still have a reference to #button in the //global elements object. In other words, the button element is //still in memory and cannot be collected by the GC.&#125; 还有一个额外的考虑，当涉及对DOM树内部的内部或叶节点的引用时，必须考虑这一点。 假设你在JavaScript代码中保留对表格特定单元格（标记）的引用。 有一天，你决定从DOM中删除该表，但保留对该单元格的引用。 直观地，可以假设GC将收集除了该单元格之外的所有内容。 实际上，这不会发生：该单元格是该表的子节点，并且孩子们保持对父代的引用。 也就是说，从JavaScript代码引用表格单元会导致整个表保留在内存中。 保持对DOM元素的引用时需要仔细考虑。 原文：https://segmentfault.com/a/1190000011229300#articleHeader7]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程]]></title>
    <url>%2Fpost%2F8731ab21.html</url>
    <content type="text"><![CDATA[ES6 中的作业(Jobs)是什么？ES6 中介绍了一种叫 “作业队列（Job Queue）” 的新概念。它是事件循环队列之上的一层。你很有可能会在处理 Promises 的异步的时候遇到它(我们后面也会讨论到它们)。 我们现在只简单介绍一下这个概念，以便当我们讨论 Promises 的异步行为的时候，你能理解这些行为是如何被调度和处理的。 想象一下：作业队列是一个跟在事件队列的每个 tick 的末尾的一个队列。在事件循环队列的一个 tick 期间可能会发生某些异步操作，这不会导致把一整个新事件添加到事件循环队列中，而是会在当前 tick 的作业队列的末尾添加一项(也就是作业)。 这意味着你可以添加一个稍后执行的功能，并且你可以放心，它会在执行任何其他操作之前执行。 作业还能够使更多的作业被添加到同一个队列的末尾。从理论上说，一个作业的“循环”（一个不停的添加其他作业的作业，等等）可能会无限循环，从而使进入下一个事件循环 tick 的程序的必要资源被消耗殆尽。从概念上讲，这就和你写了一个长时间运行的代码或是死循环(就像是 while (true))一样。 作业有点像 setTimeout(callback, 0) 的“hack”，但是它们引入了一个更加明确、更有保证的执行顺序：稍后执行，但是会尽快执行。 回调众所周知，在 JavaScript 程序中，回调是表达和管理异步目前最常用的方式。确实，回调是 JavaScript 中最基础的异步模式。无数的 JS 程序，甚至是非常复杂的 JS 程序，都是使用回调作为异步的基础。 回调也不是没有缺点。许多开发者都尝试去找到更好的异步模式。但是，如果你不理解底层的实际情况，你是不可能有效的去使用任何抽象化的东西。 在下一章中，我们将深入挖掘这些抽象的概念来说明为什么更复杂的异步模式（将会在后续的帖子中讨论）是必须的甚至是被推荐的 嵌套回调123456789101112listen('click', function (e)&#123; setTimeout(function()&#123; ajax('https://api.example.com/endpoint', function (text)&#123; if (text == "hello") &#123; doSomething(); &#125; else if (text == "world") &#123; doSomethingElse(); &#125; &#125;); &#125;, 500);&#125;); 我们有一个三个函数嵌套在一起的函数链，每一步都代表异步序列中的一步。 这种代码我们把它叫做“回调地狱”。但是“回调地狱”显然和嵌套/缩进没有关系。这是个更深层次的问题了。 首先，我们在等待一个“click”事件，然后等待定时器触发，再然后等着 Ajax 的响应返回，在这点上可能会再次重复。 乍一看，这个代码似乎可以分解成连续的几个步骤： 123listen('click', function (e) &#123; // ..&#125;); 然后： 123setTimeout(function()&#123; // ..&#125;, 500); 再然后： 123ajax('https://api.example.com/endpoint', function (text)&#123; // ..&#125;); 最后： 123456if (text == "hello") &#123; doSomething();&#125;else if (text == "world") &#123; doSomethingElse();&#125; 所以，用这样一种顺序的方式来表达你的异步代码是不是看起来更自然一些了？一定会有方法做到这一点，不是吗？ Promises看看下面的代码：1234var x = 1;var y = 2;console.log(x + y);&#125; 这是段简单的代码：它对 x 和 y 求和，然后在控制台打印出来。但，假如 x 或是 y 的值是待确定的呢？比如说，我们需要在使用这两个值之前去服务器检索 x 和 y 的值。然后，有两个函数 loadX 和 loadY，分别从服务器获取 x 和 y 的值。最后，函数 sum 来将获取到的 x 和 y 的值加起来。 看起来就是这样的(相当丑，不是吗？): 12345678910111213141516171819202122232425262728function sum(getX, getY, callback) &#123; var x, y; getX(function(result) &#123; x = result; if (y !== undefined) &#123; callback(x + y); &#125; &#125;); getY(function(result) &#123; y = result; if (x !== undefined) &#123; callback(x + y); &#125; &#125;);&#125;// 一个同步或者异步的函数，获取 `x` 的值function fetchX() &#123; // ..&#125;// 一个同步或者异步的函数，获取 `y` 的值function fetchY() &#123; // ..&#125;sum(fetchX, fetchY, function(result) &#123; console.log(result);&#125;); 这里面的关键点在于 — 这段代码中，x 和 y 是 未来 的值，然后我们还写了一个 sum(…) 函数，并且从外面看它并不关心 x 或者 y 现在是不是可用的。 当然，这种基于回调的方式是粗糙的并且有很多不足。这只是初步理解 未来值 以及不需要去担心它们什么时候可用的第一步。 Promise 值让我们看一下这个简短的例子是如何用 Promises 来表达 x + y 的： 123456789101112131415161718192021222324252627function sum(xPromise, yPromise) &#123; // `Promise.all([ .. ])` 接受一个 promises 的数组， // 并且返回一个新的 promise 对象去等待它们 // 全部完成 return Promise.all([xPromise, yPromise]) // 当 promise 完成的时候，我们就能获取 // `X` and `Y` 的值，并且计算他们 .then(function(values)&#123; // `values` 是一个来自前面完成的 promise // 的消息数组 return values[0] + values[1]; &#125; );&#125;// `fetchX()` and `fetchY()` 返回 promises 的值，有他们各自的// 值，或许*现在* 已经准备好了// 也可能要 *等一会儿*。sum(fetchX(), fetchY())// 我们从返回的 promise 得到了这// 两个数字的和。// 现在我们连续的调用了 `then(...)` 去等待已经完成的// promise。.then(function(sum)&#123; console.log(sum);&#125;); 这段代码可以看到两层 Promises。 fetchX() 和 fetchY() 被直接调用，然后他们的返回值(promises!)被传给 sum(…)。这些 promises 代表的值可能在 现在 或是 将来 准备好，但每个 promise 的自身规范都是相同的。我们以一种与时间无关的方式来解释 x 和 y 的值。它们在一段时间内是 未来值。 第二层 promise 是 sum(…) 创建 (通过 Promise.all([ … ])) 并返回的，我们通过调用 then(…) 来等待返回。当 sum(…) 操作完成的时候，未来值 的总和也就准备就绪了，然后就可以把值打印出来了。我们隐藏了在 sum(…) 函数内部等待 x 和 y 的 未来值 的逻辑。 注意：在 sum(…) 函数中，Promise.all([ … ]) 创建了一个 promise (这个 promise 等待 promiseX and promiseY 的完成)。链式调用 .then(…) 来创建另一个 promise，返回的 values[0] + values[1] 会立即执行完成(还要加上加运算的结果)。因此，我们在 sum(…) 调用结束后加上的 then(…) — 在上面代码的末尾 — 实际上是在第二个 promise 返回后执行，而不是第一个 Promise.all([ … ]) 创建的 promise。还有，尽管我们没有在第二个 then(…) 后面再进行链式调用，但是它也创建了一个 promise，我们可以去观察或是使用它。关于 Promise 的链式调用会在后面详细地解释。 使用 Promises，这个 then(…) 的调用其实有两个方法，第一个方法被调用的时机是在已完成的时候 (就像我们前面使用的那样)，而另一个被调用的时机是已失败的时候： 1234567891011sum(fetchX(), fetchY()).then( // 完成时 function(sum) &#123; console.log( sum ); &#125;, // 失败时 function(err) &#123; console.error( err ); // bummer! &#125;); 如果在获取 x 或者 y 的时候出错了，又或许是在进行加运算的时候失败了，sum(…) 返回的 promise 将会是已失败的状态，并且会将 promise 已失败的值传给 then(…) 的第二个回调处理。 因为 Promises 封装了依赖时间的状态 — 等待内部的值已完成或是已失败 — 从外面看，Promise 是独立于时间的，因此 Promises 可以能通过一种可预测的方式组合起来，而不用去考虑底层的时间或者结果。 而且，一旦 Promise 的状态确定了，那么他就永远也不会改变状态了 — 在这时它会变成一个 不可改变的值 — 然后就可以在有需要的时候多次 观察 它。 实际上链式的 promises 是非常有用的： 12345678910111213141516171819function delay(time) &#123; return new Promise(function(resolve, reject)&#123; setTimeout(resolve, time); &#125;);&#125;delay(1000).then(function()&#123; console.log("after 1000ms"); return delay(2000);&#125;).then(function()&#123; console.log("after another 2000ms");&#125;).then(function()&#123; console.log("step 4 (next Job)"); return delay(5000);&#125;)// ... 调用 delay(2000) 会创建一个在 2000ms 完成的 promise，然后我们返回第一个 then(…) 的成功回调，这会导致第二个 then(…) 的 promise 要再等待 2000ms 执行。 注意：因为 Promise 一旦完成了就不能再改变状态了，所以可以安全的传递到任何地方，因为它不会再被意外或是恶意的修改。这对于在多个地方监听 Promise 的解决方案来说，尤其正确。一方不可能影响到另一方所监听到的结果。不可变听起来像是一个学术性的话题，但是它是 Promise 设计中最基础、最重要方面，不应该被忽略。 用不用 Promise？使用 Promises 最重要的一点在于能否确定一些值是否是真正的 Promise。换句话说，它的值像一个 Promise 吗？ 我们知道 Promises 是由 new Promise(…) 语句构造出来的，你可能会认为 p instanceof Promise 就能判断一个 Promise。其实，并不完全是。 主要是因为另一个浏览器窗口(比如 iframe)获取一个 Promise 的值，它拥有自己的 Promise 类，且不同于当前或其他窗口，所以使用 instance 来区分 Promise 是不准确的。 而且，一个框架或者库可以选择自己的 Promise，而不是使用 ES6 原生的 Promise 实现。事实上，你很可能会在不支持 Promise 的老式浏览器中使用第三方的 Promise 库。 吞噬异常如果在任何一个创建 Promise 或是对其结果观察的过程中，抛出了一个 JavaScript 异常错误，比如说 TypeError 或是 ReferenceError，那么这个异常会被捕获，然后它就会把 Promise 的状态变成已失败。 例如： 1234567891011121314var p = new Promise(function(resolve, reject)&#123; foo.bar(); // 对不起，`foo` 没有定义 resolve(374); // 不会执行 :(&#125;);p.then( function fulfilled()&#123; // 不会执行 :( &#125;, function rejected(err)&#123; // `err` 是 `foo.bar()` 那一行 // 抛出的 `TypeError` 异常对象。 &#125;); 如果一个 Promise 已经结束了，但是在监听结果(在 then(…) 里的回调函数)的时候发生了 JS 异常会怎么样呢？即使这个错误没有丢失，你可能也会对它的处理方式有点惊讶。除非你深入的挖掘一下：123456789101112var p = new Promise( function(resolve,reject)&#123; resolve(374);&#125;);p.then(function fulfilled(message)&#123; foo.bar(); console.log(message); // 不会执行&#125;, function rejected(err)&#123; // 不会执行 &#125;); 这看起来就像 foo.bar() 的异常真的被吞了。当然了，异常并不是被吞了。这是更深层次的问题出现了，我们没有监听到异常。p.then(…) 调用它自己会返回另一个 promise，而这个 promise 会因为 TypeError 的异常变为已失败状态。 处理未捕获的异常还有一些 更好的 办法解决这个问题。 最常见的就是给 Promise 加一个 done(…)，用来标志 Promise 链的结束。done(…) 不会创建或返回一个 Promise，所以传给 done(..) 的回调显然不会将问题报告给一个不存在的 Promise。 在未捕获异常的情况下，这可能才是你期望的：在 done(..) 已失败的处理函数里的任何异常都会抛出一个全局的未捕获异常（通常是在开发者的控制台）。 12345678910var p = Promise.resolve(374);p.then(function fulfilled(msg)&#123; // 数字不会拥有字符串的方法， // 所以会抛出一个错误 console.log(msg.toLowerCase());&#125;).done(null, function() &#123; // 如果有异常发生，它就会被全局抛出 &#125;); ES8 发生了什么？ Async/awaitJavaScript ES8 介绍了 async/await，使得我们能更简单的使用 Promises。我们将简单的介绍 async/await 会带给我们什么以及如何利用它们写出异步的代码。 所以，来让我们看看 async/await 是如何工作的。 使用 async 函数声明来定义一个异步函数。这样的函数返回一个 AsyncFunction 对象。AsyncFunction 对象表示执行包含在这个函数中的代码的异步函数。 当一个 async 函数被调用，它返回一个 Promise。当 async 函数返回一个值，它不是一个 Promise，Promise 将会被自动创建，然后它使用函数的返回值来决定状态。当 async 抛出一个异常，Promise 使用抛出的值进入已失败状态。 一个 async 函数可以包含一个 await 表达式，它会暂停执行这个函数然后等待传给它的 Promise 完成，然后恢复 async 函数的执行，并返回已成功的值。 你可以把 JavaScript 的 Promise 看作是 Java 的 Future 或是 C# 的 Task。 async/await 的目的是简化使用 promises 的写法。 让我们来看看下面的例子： 12345678// 一个标准的 JavaScript 函数function getNumber1() &#123; return Promise.resolve('374');&#125;// 这个 function 做了和 getNumber1 同样的事async function getNumber2() &#123; return 374;&#125; 同样，抛出异常的函数等于返回已失败的 promises： 123456function f1() &#123; return Promise.reject('Some error');&#125;async function f2() &#123; throw 'Some error';&#125; 关键字 await 只能使用在 async 的函数中，并允许你同步等待一个 Promise。如果我们在 async 函数之外使用 promise，我们仍然要用 then 回调函数： 1234567891011121314async function loadData() &#123; // `rp` 是一个请求异步函数 var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // 现在，两个请求都被触发, // 我们就等待它们完成。 var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;&#125;// 但，如果我们没有在 `async function` 里// 我们就必须使用 `then`。loadData().then(() =&gt; console.log('Done')); 你还可以使用 async 函数表达式的方法创建一个 async 函数。async 函数表达式的写法和 async 函数声明差不多。函数表达式和函数声明最主要的区别就是函数名，它可以在 async 函数表达式中省略来创建一个匿名函数。一个 async 函数表达式可以作为一个 IIFE（立即执行函数） 来使用，当它被定义好的时候就会执行。 它看起来是这样的： 1234567891011var loadData = async function() &#123; // `rp` 是一个请求异步函数 var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // 现在，两个请求都被触发, // 我们就等待它们完成。 var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;&#125; 最后，最重要的是不要盲目的选择“最新”的方法去写异步代码。更重要的是理解异步 JavaScript 内部的原理，知道为什么它为什么如此重要以及去理解你选择的方法的内部原理。在程序中每种方法都是有利有弊的。 5 个编写可维护的、健壮的异步代码的技巧1.干净的代码: 使用 async/await 能够让你少写代码。每一次你使用 async/await 你都能跳过一些不必要的步骤：写一个 .then，创建一个匿名函数来处理响应，在回调中命名响应，比如： 1234// `rp` 是一个请求异步函数rp(‘https://api.example.com/endpoint1').then(function(data) &#123; // …&#125;); 对比: 12// `rp` 是一个请求异步函数var response = await rp(‘https://api.example.com/endpoint1'); 错误处理: Async/await 使得我们可以使用相同的代码结构处理同步或者异步的错误 —— 著名的 try/catch 语句。让我们看看用 Async/await 是怎么实现的： 12345678async function loadData() &#123; try &#123; var data = JSON.parse(await getJSON()); console.log(data); &#125; catch(e) &#123; console.log(e); &#125;&#125; 3.条件语句: 使用 async/await 来写条件语句要简单得多： 123456789101112131415function loadData() &#123; return getJSON() .then(function(response) &#123; if (response.needsAnotherRequest) &#123; return makeAnotherRequest(response) .then(function(anotherResponse) &#123; console.log(anotherResponse) return anotherResponse &#125;) &#125; else &#123; console.log(response) return response &#125; &#125;)&#125; 对比： 1234567891011async function loadData() &#123; var response = await getJSON(); if (response.needsAnotherRequest) &#123; var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse &#125; else &#123; console.log(response); return response; &#125;&#125; 4.栈帧: 和 async/await 不同的是，根据promise链返回的错误堆栈信息，并不能发现哪出错了。来看看下面的代码： 1234567891011121314function loadData() &#123; return callAPromise() .then(callback1) .then(callback2) .then(callback3) .then(() =&gt; &#123; throw new Error("boom"); &#125;)&#125;loadData() .catch(function(e) &#123; console.log(err);// Error: boom at callAPromise.then.then.then.then (index.js:8:13)&#125;); 对比： 1234567891011121314async function loadData() &#123; await callAPromise1() await callAPromise2() await callAPromise3() await callAPromise4() await callAPromise5() throw new Error("boom");&#125;loadData() .catch(function(e) &#123; console.log(err); // 输出 // Error: boom at loadData (index.js:7:9)&#125;); 5.调试: 如果你使用了 promises，你就会知道调试它们将会是一场噩梦。比如，你在 .then 里面打了一个断点，并且使用类似 “stop-over” 这样的 debug 快捷方式，调试器不会移动到下一个 .then，因为它只会对同步代码生效。而通过 async/await 你就可以逐步的调试 await 调用了，它就像是一个同步函数一样。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 执行机制]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的。 javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，通常采用异步加载，就是异步任务。关于这部分有严格的文字定义，在这里用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册回调函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 代码演示123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log('发送成功!'); &#125;&#125;)console.log('代码执行结束'); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(‘代码执行结束’)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 通过上面的文字和代码，已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 setTimeoutsetTimeout的作用可以延时执行代码，我们经常这么实现延时3秒执行： 123setTimeout(() =&gt; &#123; console.log('延时3秒')&#125;, 3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，跟所设定的时间不一样？先看一个例子: 1234setTimeout(() =&gt; &#123; task();&#125;,3000)console.log('执行console'); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码 12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明:12345//代码1console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,0); 12345//代码2console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,3000); 代码1的输出结果是:12//先执行这里//执行啦 代码2的输出结果是：123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 setInterval循环的执行代码。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行第一次宏任务中所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束 事件循环，宏任务，微任务的关系如图所示: 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3 宏任务Event Queue 微任务Event Queue process3 process3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 写在最后js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 最后 javascript是一门单线程语言 Event Loop是javascript的执行机制]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript调用堆栈]]></title>
    <url>%2Fpost%2Fc0155143.html</url>
    <content type="text"><![CDATA[JavaScript 引擎JavaScript 引擎说起来最流行的当然是谷歌的 V8 引擎了， V8 引擎使用在 Chrome 以及 Node 中，下面有个简单的图能说明他们的关系： 这个引擎主要由两部分组成: 内存堆：这是内存分配发生的地方 调用栈：这是你的代码执行时的地方 运行时有些浏览器的 API 经常被使用到(比如说：setTimeout)，但是，这些 API 却不是引擎提供的。那么，他们是从哪儿来的呢？事实上这里面实际情况有点复杂。 所以说我们还有很多引擎之外的 API，我们把这些称为浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout等等。 然后我们还拥有如此流行的事件循环和回调队列。 调用栈JavaScript 是一门单线程的语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。 调用栈是一种数据结构，它记录了我们在程序中的位置。如果我们运行到一个函数，它就会将其放置到栈顶。当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情。 让我们来看一看下面的例子： 12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 当程序开始执行的时候，调用栈是空的，然后，步骤如下： 每一个进入调用栈的都称为调用帧。这能清楚的知道当异常发生的时候堆栈追踪是怎么被构造的，堆栈的状态是如何的。让我们看一下下面的代码： 12345678910function foo() &#123; throw new Error('SessionStack will help you resolve crashes :)');&#125;function bar() &#123; foo();&#125;function start() &#123; bar();&#125;start(); 如果这发生在 Chrome 里(假设这段代码实在一个名为 foo.js 的文件中)，那么将会生成以下的堆栈追踪： “堆栈溢出”，当你达到调用栈最大的大小的时候就会发生这种情况，而且这相当容易发生，特别是在你写递归的时候却没有全方位的测试它。我们来看看下面的代码： 1234function foo() &#123; foo();&#125;foo(); 当我们的引擎开始执行这段代码的时候，它从 foo 函数开始。然后这是个递归的函数，并且在没有任何的终止条件的情况下开始调用自己。因此，每执行一步，就会把这个相同的函数一次又一次地添加到调用堆栈中。然后它看起来就像是这样的： 然后，在某一时刻，调用栈中的函数调用的数量超过了调用栈的实际大小，浏览器决定干掉它，抛出一个错误，它看起来就像是这样: 在单个线程上运行代码很容易，因为你不必处理在多线程环境中出现的复杂场景——例如死锁。但是在一个线程上运行也非常有限制。由于 JavaScript 只有一个调用堆栈，当某段代码运行变慢时会发生什么? 并发与事件循环调用栈中的函数调用需要大量的时间来处理，那么这会发生什么情况呢?例如，假设你想在浏览器中使用 JavaScript 进行一些复杂的图片转码。 你可能会问？这算什么问题？事实上，问题是当调用栈有函数要执行，浏览器就不能做任何事，它会被堵塞住。这意味着浏览器不能渲染，不能运行其他的代码，它被卡住了。如果你想在应用里让 UI 很流畅的话，这就会产生问题。 而且这不是唯一的问题，一旦你的浏览器开始处理调用栈中的众多任务，它可能会停止响应相当长一段时间。大多数浏览器都会这么做，报一个错误，询问你是否想终止 web 页面。 这样看来，这并不是最好的用户体验，不是吗？那么，如何在不阻塞 UI 的情况下执行复杂的代码，让浏览器不会不响应?解决方案就是异步回调。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
